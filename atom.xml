<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WordZzzz</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wordzzzz.github.io/"/>
  <updated>2018-02-07T03:21:11.605Z</updated>
  <id>https://wordzzzz.github.io/</id>
  
  <author>
    <name>Word Zzzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题笔记（树）：sum-root-to-leaf-numbers</title>
    <link href="https://wordzzzz.github.io/2018/02/07/Tree4/"/>
    <id>https://wordzzzz.github.io/2018/02/07/Tree4/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-07T03:21:11.605Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree containing digits from0-9only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path1-&gt;2-&gt;3which represents the number123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><pre><code>1</code></pre><p>   / \<br>  2   3</p><p>The root-to-leaf path1-&gt;2represents the number12.<br>The root-to-leaf path1-&gt;3represents the number13.</p><p>Return the sum = 12 + 13 =25.</p><p>给定一个二进制树，只包含0-9的数字，每个根到叶的路径可以代表一个数字。 一个例子是代表数字123的根到叶子路径1-&gt; 2-&gt; 3。 找到所有根到叶子数量的总和。 例如，1 / \ 2 3根到叶子路径1 - &gt; 2表示数字12。 根到叶子路径1-&gt; 3表示数字13。 返回总和= 12 + 13 = 25。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种方法，递归和迭代，递归太简单了，直接贴出代码就不多说了。</p><p>前序遍历需要注意的是，因为stack是后入先出规则，所以我们在入栈的时候，先将右子树入栈，再将坐子树入栈，这样在出栈的时候就可以保证是先左后右了。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            preorder(root-&gt;left, res);</span><br><span class="line">            preorder(root-&gt;right, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; sta;</span><br><span class="line">        sta.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sta.empty())&#123;</span><br><span class="line">            TreeNode *cur = sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                sta.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                sta.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="https://wordzzzz.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（树）：binary-tree-preorder-traversal</title>
    <link href="https://wordzzzz.github.io/2018/02/07/Tree3/"/>
    <id>https://wordzzzz.github.io/2018/02/07/Tree3/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-07T03:20:45.811Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>For example:<br>Given binary tree{1,#,2,3},</p><p>   1<br>    \<br>     2<br>    /<br>   3</p><p>return[1,2,3].</p><p>Note: Recursive solution is trivial, could you do it iteratively?</p><p>给定一个二叉树，返回其节点值的前序遍历。 </p><p>注意：递归解决方案是微不足道的，你可以迭代地做？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用先序遍历的思想(根左右)+数字求和的思想(每一层都比上层和*10+当前根节点的值)。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">preorder</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> preorder(root-&gt;left, sum) + preorder(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> preorder(root, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="https://wordzzzz.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（树）：minimum-depth-of-binary-tree</title>
    <link href="https://wordzzzz.github.io/2018/02/07/Tree1/"/>
    <id>https://wordzzzz.github.io/2018/02/07/Tree1/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-07T03:19:46.063Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>给定一棵二叉树，找到它的最小深度。最小深度是沿着从根节点到最近叶节点的最短路径的节点数量。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>DFS和BFS都可以，但是很明显，BFS更快，因为BFS只要找到第一个叶子结点就可以停止遍历了看，而DFS需要通过迭代来遍历所有的结点。</p><p>这里我重点说一下BFS，循环的终止条件是now结点无左右子树，即size前后无变化。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = run(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = run(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> min(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        TreeNode *last, *now;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, size = <span class="number">0</span>;</span><br><span class="line">        last = now = root;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            now = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            size = que.size();</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left)</span><br><span class="line">                que.push(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right)</span><br><span class="line">                que.push(now-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(que.size() == size)  <span class="comment">//循环终止条件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(last == now)&#123;</span><br><span class="line">                level++;</span><br><span class="line">                <span class="keyword">if</span>(que.size() != <span class="number">0</span>)</span><br><span class="line">                    last = que.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="https://wordzzzz.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（树）：binary-tree-postorder-traversal</title>
    <link href="https://wordzzzz.github.io/2018/02/07/Tree2/"/>
    <id>https://wordzzzz.github.io/2018/02/07/Tree2/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-07T03:20:13.994Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>For example:<br>Given binary tree{1,#,2,3},</p><p>   1<br>    \<br>     2<br>    /<br>   3</p><p>return[3,2,1].</p><p>Note: Recursive solution is trivial, could you do it iteratively?</p><p>给定一个二叉树，返回其节点值的后序遍历。 </p><p>注意：递归解决方案是微不足道的，你可以迭代地做？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种方法，递归和迭代，递归太简单了，直接贴出代码就不多说了。</p><p>后序遍历的非递归版可以说是三种遍历中最难的了，因为要先穷举左右结点，最后才是根结点。在外循环中，第一步还是依次将左子树入栈；然后看栈顶元素，如果栈顶元素没有右孩子，或者右孩子时候已经遍历过，那么就弹出栈顶元素，并记录；否则，遍历右子树。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            postorder(root-&gt;left, res);</span><br><span class="line">            postorder(root-&gt;right, res);</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root, *last = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span> || !sta.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                sta.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = sta.top();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right == <span class="literal">NULL</span> || cur-&gt;right == last)&#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                last = cur;</span><br><span class="line">                cur = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="https://wordzzzz.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（模拟）：pascals-triangle-ii</title>
    <link href="https://wordzzzz.github.io/2018/02/02/Simulation2/"/>
    <id>https://wordzzzz.github.io/2018/02/02/Simulation2/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-02-02T12:13:49.803Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an index k, return the k th row of the Pascal’s triangle.</p><p>For example, given k = 3,<br>Return[1,3,3,1].</p><p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p><p>给定一个索引k，返回帕斯卡三角形的第k行。 例如，给定k = 3， 返回[1,3,3,1]。 注意： 你可以优化你的算法只使用O（K）额外的空间？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>基本的想法是从头到尾迭代地更新数组。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dummp(rowIndex+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowIndex; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j)</span><br><span class="line">                dummp[j] += dummp[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> dummp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Simulation" scheme="https://wordzzzz.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（穷举）：max-points-on-a-line</title>
    <link href="https://wordzzzz.github.io/2018/02/02/Exhaustive/"/>
    <id>https://wordzzzz.github.io/2018/02/02/Exhaustive/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-02-02T12:12:48.156Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p>给定2D平面上的n个点，找出位于同一直线上的最大点数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两点确定一条直线，同时，对于斜率不为零的直线，都有y=kx+b。对于重复点，肯定也算是共线，所以，我们首先计算重复点的个数，然后计算斜率为0时共线的点个数，最后再计算其他斜率下共线的点的个数。</p><p>需要两重循环，第一重循环遍历起始点a，第二重循环遍历剩余点b。</p><ul><li>如果a和b重合，duplicate累加；</li><li>如果a和b不重合，且两者斜率为0，则numVertical累加；</li><li>如果a和b不重合，且两者斜率不为零，则计算斜率并计入map中，同时更新map中对应值；</li><li>内循环结束后，返回max(local + duplicate, numVertical + duplicate)与之前的最大值res的最大值，local和numVertical算是不同斜率下的最大值；</li><li>外循环结束后，返回res。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">            <span class="keyword">int</span> numVertical = <span class="number">0</span>, local = <span class="number">1</span>, duplicate = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(points[i].x == points[j].x)</span><br><span class="line">                    <span class="keyword">if</span>(points[i].y == points[j].y)  <span class="comment">//重复点</span></span><br><span class="line">                        duplicate++;</span><br><span class="line">                    <span class="keyword">else</span>                            <span class="comment">//垂直点</span></span><br><span class="line">                        numVertical == <span class="number">0</span> ? numVertical = <span class="number">2</span> : numVertical++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">double</span> slope = (points[i].y - points[j].y) * <span class="number">1.0</span> / (points[i].x - points[j].x);</span><br><span class="line">                    <span class="built_in">map</span>[slope] == <span class="number">0</span> ? <span class="built_in">map</span>[slope] = <span class="number">2</span> : <span class="built_in">map</span>[slope]++;</span><br><span class="line">                    local = max(local, <span class="built_in">map</span>[slope]);</span><br><span class="line">                &#125;</span><br><span class="line">            local = max(local + duplicate, numVertical + duplicate);</span><br><span class="line">            res = max(res, local);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Exhaustive" scheme="https://wordzzzz.github.io/tags/Exhaustive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（模拟）：pascals-triangle</title>
    <link href="https://wordzzzz.github.io/2018/02/02/Simulation1/"/>
    <id>https://wordzzzz.github.io/2018/02/02/Simulation1/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-02-02T12:13:21.779Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given numRows, generate the first numRows of Pascal’s triangle.</p><p>For example, given numRows = 5,<br>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定numRows，生成帕斯卡三角形的前numRows行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目比较古老，几行代码就能搞定，注意一下代码中的边界条件。</p><p>我感觉像下面这样写会更直观一些，每一行两头的1我们都直接添加即可，从第三行开始，假定用res[][]表示下面各个值的位置，那么第三行的2所在的位置就是res[2][1]。res[2][1] = res[1][1] + res[1][0]，推广之后为res[i][j] = res[i][j] + res[i][j-1]，这就是中间这些数的计算公式，还是要注意边界问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3 1</span><br><span class="line">1 4 6 4 1</span><br></pre></td></tr></table></figure><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i)&#123;</span><br><span class="line">        res[i].push_back(<span class="number">1</span>);                                <span class="comment">//第一个位置为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                res[i].push_back(res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]);  <span class="comment">//j从1开始，那么只有i&gt;=2的时候才会执行这部分</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                res[i].push_back(<span class="number">1</span>);                            <span class="comment">//最后一个位置也为1，需要注意是不能再第一行中添加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Simulation" scheme="https://wordzzzz.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（模拟）：divide-two-integers</title>
    <link href="https://wordzzzz.github.io/2018/02/02/Simulation3/"/>
    <id>https://wordzzzz.github.io/2018/02/02/Simulation3/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-02-02T12:14:16.797Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p><p>不用乘法，除法和取模运算符来计算两个整数相除的结果。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设我们要划分15和3，所以15是dividend、3是divisor。那么划分只需要我们找出可以从dividend中减去多少次divisor，而不会造成dividend负面影响。</p><p>首先是15-3=12，然后让我们尝试去减去更多。3左移一位得6，15-6=9。6左移一位是12，15-12=3。当我们再次对12进行左移得到24时，已经比15大了，所以15最多可以减去12。12是3的四倍，那么我们怎么得到这个4呢？其实我们可以在3（cur）左移的时候，对1（multiple）进行同样的左移操作即可，这样，当cur成为12的时候，multiple正好是4。</p><p>接下来，把15-12剩下的3再次进行循环，得出multiple为1，所以最后得到4+1=5次。</p><p>根据问题陈述，我们需要处理一些例外，例如溢出。</p><p>那么有两种情况可能会导致溢出：</p><ul><li>divisor = 0;</li><li>dividend = INT_MIN和divisor = -1（因为abs(INT_MIN) = INT_MAX + 1）。</li></ul><p>当然，我们也需要考虑相对容易的标志。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!divisor || dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvd = <span class="built_in">labs</span>(dividend);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvs = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cur = dvs, multiple = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= cur &lt;&lt; <span class="number">1</span>)&#123;</span><br><span class="line">                cur &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                multiple &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= cur;</span><br><span class="line">            res += multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Simulation" scheme="https://wordzzzz.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>鱼眼摄像头标定与畸变校正（双OPENCV版本）</title>
    <link href="https://wordzzzz.github.io/2018/01/28/OPENCV/"/>
    <id>https://wordzzzz.github.io/2018/01/28/OPENCV/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-01-28T05:51:11.704Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/fisheye_calibration" target="_blank" rel="noopener">https://github.com/WordZzzz/fisheye_calibration</a></strong></li><li><strong>软件版本：VS2013+OPENCV2.4.13 OR VS2013+OPENCV3.4.0</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><p>&emsp;&emsp;最近在整理自己以前做过的一些东西，这是基于opencv的鱼眼摄像头畸变校正程序的<a href="https://github.com/WordZzzz/fisheye_calibration" target="_blank" rel="noopener">github地址</a>。</p><p>其中：</p><ul><li>normal_calibrate：基于OPENCV2与OPENCV3通用的函数实现，可实现USB摄像头实时畸变校正；</li><li>fishey_calibrate：基于OPENCV3独有的fishyey结构体实现，可实现USB摄像头实时畸变校正；</li><li>fishey_calibrate_img：基于OPENCV3独有的fishyey结构体实现，可实现单张图片畸变校正；</li></ul><p>&emsp;&emsp;opencv1.0 2.0版只有一种摄像机标定模型，就是普通的小孔成像模型，在cv：：空间下。而从opencv3.0开始，新增了一种鱼眼相机标定模型，在fisheye::空间下。两种模型的主要区别在于像与物的投影关系不同，具体的文献资料依然是数不胜数，这里就不赘述。根据opencv官方文档的建议，在畸变程度较大的广角镜头（比如：鱼眼镜头）上进行摄像机标定和畸变校正，最好是用fisheye模型，该模型在图像边缘畸变程度很大的地方比普通相机模型的效果要好。</p><p>&emsp;&emsp;当然，还是要贴上官方文档的：</p><ul><li><a href="https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html" target="_blank" rel="noopener">Camera calibration With OpenCV2</a>；</li><li><a href="https://docs.opencv.org/trunk/db/d58/group__calib3d__fisheye.html" target="_blank" rel="noopener">Camera calibration With OpenCV3</a>；</li></ul><hr><p>华丽的分割线</p><hr><h2 id="可供参考资料"><a href="#可供参考资料" class="headerlink" title="可供参考资料"></a>可供参考资料</h2><p>&emsp;&emsp;以下是在写这篇博客的时候偶然发现的对opencv两个版本标定过程的讲解，这里直接copy过来并稍微做了一下排版，因为自己忙于为找工作做准备，实在是没时间自己整理了。<a href="http://www.cnblogs.com/riddick/p/7811877.html" target="_blank" rel="noopener">原文链接</a>。</p><p>&emsp;&emsp;图像算法中会经常用到摄像机的畸变校正，有必要总结分析OpenCV中畸变校正方法，其中包括普通针孔相机模型和鱼眼相机模型fisheye两种畸变校正方法。</p><p>&emsp;&emsp;普通相机模型畸变校正函数针对OpenCV中的cv::initUndistortRectifyMap()，鱼眼相机模型畸变校正函数对应OpenCV中的cv::fisheye::initUndistortRectifyMap()。两种方法算出映射Mapx和Mapy后，统一用cv::Remap()函数进行插值得到校正后的图像。</p><h3 id="FishEye模型的畸变校正。"><a href="#FishEye模型的畸变校正。" class="headerlink" title="FishEye模型的畸变校正。"></a>FishEye模型的畸变校正。</h3><p>&emsp;&emsp;方便起见，直接贴出OpenCV源码，我在里面加了注释说明。建议参考<a href="https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap" target="_blank" rel="noopener">OpenCV官方文档</a>看畸变模型原理会更清楚。</p><p>&emsp;&emsp;简要流程就是：</p><ul><li><p>1.求内参矩阵的逆，由于摄像机坐标系的三维点到二维图像平面，需要乘以旋转矩阵R和内参矩阵K。那么反向投影回去则是二维图像坐标乘以  K*R的逆矩阵。</p></li><li><p>2.将目标图像中的每一个像素点坐标(j,i)，乘以1中求出的逆矩阵iR，转换到摄像机坐标系（_x,_y,_w）,并归一化得到z=1平面下的三维坐标(x,y,1)。</p></li><li><p>3.求出平面模型下像素点对应鱼眼半球模型下的极坐标(r, theta)。</p></li><li><p>4.利用鱼眼畸变模型求出拥有畸变时像素点对应的theta_d。</p></li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180128134953810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li><p>5.利用求出的theta_d值将三维坐标点重投影到二维图像平面得到(u,v)，(u,v)即为目标图像对应的畸变图像中像素点坐标。</p></li><li><p>6.使用cv::Remap（）函数，根据mapx,mapy取出对应坐标位置的像素值赋值给目标图像，一般采用双线性插值法，得到畸变校正后的目标图像。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P,</span><br><span class="line">    <span class="keyword">const</span> cv::Size&amp; size, <span class="keyword">int</span> m1type, OutputArray map1, OutputArray map2 )</span><br><span class="line">&#123;</span><br><span class="line">    CV_Assert( m1type == CV_16SC2 || m1type == CV_32F || m1type &lt;=<span class="number">0</span> );</span><br><span class="line">    map1.create( size, m1type &lt;= <span class="number">0</span> ? CV_16SC2 : m1type );</span><br><span class="line">    map2.create( size, map1.type() == CV_16SC2 ? CV_16UC1 : CV_32F );</span><br><span class="line"></span><br><span class="line">    CV_Assert((K.depth() == CV_32F || K.depth() == CV_64F) &amp;&amp; (D.depth() == CV_32F || D.depth() == CV_64F));</span><br><span class="line">    CV_Assert((P.empty() || P.depth() == CV_32F || P.depth() == CV_64F) &amp;&amp; (R.empty() || R.depth() == CV_32F || R.depth() == CV_64F));</span><br><span class="line">    CV_Assert(K.size() == Size(<span class="number">3</span>, <span class="number">3</span>) &amp;&amp; (D.empty() || D.total() == <span class="number">4</span>));</span><br><span class="line">    CV_Assert(R.empty() || R.size() == Size(<span class="number">3</span>, <span class="number">3</span>) || R.total() * R.channels() == <span class="number">3</span>);</span><br><span class="line">    CV_Assert(P.empty() || P.size() == Size(<span class="number">3</span>, <span class="number">3</span>) || P.size() == Size(<span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从内参矩阵K中取出归一化焦距fx,fy; cx,cy</span></span><br><span class="line">    cv::Vec2d f, c;</span><br><span class="line">    <span class="keyword">if</span> (K.depth() == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        Matx33f camMat = K.getMat();</span><br><span class="line">        f = Vec2f(camMat(<span class="number">0</span>, <span class="number">0</span>), camMat(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        c = Vec2f(camMat(<span class="number">0</span>, <span class="number">2</span>), camMat(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matx33d camMat = K.getMat();</span><br><span class="line">        f = Vec2d(camMat(<span class="number">0</span>, <span class="number">0</span>), camMat(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        c = Vec2d(camMat(<span class="number">0</span>, <span class="number">2</span>), camMat(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从畸变系数矩阵D中取出畸变系数k1,k2,k3,k4</span></span><br><span class="line">    Vec4d k = Vec4d::all(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!D.empty())</span><br><span class="line">        k = D.depth() == CV_32F ? (Vec4d)*D.getMat().ptr&lt;Vec4f&gt;(): *D.getMat().ptr&lt;Vec4d&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旋转矩阵RR转换数据类型为CV_64F，如果不需要旋转，则RR为单位阵</span></span><br><span class="line">    cv::Matx33d RR  = cv::Matx33d::eye();</span><br><span class="line">    <span class="keyword">if</span> (!R.empty() &amp;&amp; R.total() * R.channels() == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Vec3d rvec;</span><br><span class="line">        R.getMat().convertTo(rvec, CV_64F);</span><br><span class="line">        RR = Affine3d(rvec).rotation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!R.empty() &amp;&amp; R.size() == Size(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        R.getMat().convertTo(RR, CV_64F);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新的内参矩阵PP转换数据类型为CV_64F</span></span><br><span class="line">    cv::Matx33d PP = cv::Matx33d::eye();</span><br><span class="line">    <span class="keyword">if</span> (!P.empty())</span><br><span class="line">        P.getMat().colRange(<span class="number">0</span>, <span class="number">3</span>).convertTo(PP, CV_64F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键一步：新的内参矩阵*旋转矩阵，然后利用SVD分解求出逆矩阵iR，后面用到</span></span><br><span class="line">    cv::Matx33d iR = (PP * RR).inv(cv::DECOMP_SVD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反向映射，遍历目标图像所有像素位置，找到畸变图像中对应位置坐标(u,v)，并分别保存坐标(u,v)到mapx和mapy中</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.height; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span>* m1f = map1.getMat().ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">float</span>* m2f = map2.getMat().ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">short</span>*  m1 = (<span class="keyword">short</span>*)m1f;</span><br><span class="line">        ushort* m2 = (ushort*)m2f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二维图像平面坐标系-&gt;摄像机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> _x = i*iR(<span class="number">0</span>, <span class="number">1</span>) + iR(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">               _y = i*iR(<span class="number">1</span>, <span class="number">1</span>) + iR(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">               _w = i*iR(<span class="number">2</span>, <span class="number">1</span>) + iR(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size.width; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//归一化摄像机坐标系，相当于假定在Z=1平面上</span></span><br><span class="line">            <span class="keyword">double</span> x = _x/_w, y = _y/_w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//求鱼眼半球体截面半径r</span></span><br><span class="line">            <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">            <span class="comment">//求鱼眼半球面上一点与光心的连线和光轴的夹角Theta</span></span><br><span class="line">            <span class="keyword">double</span> theta = <span class="built_in">atan</span>(r);</span><br><span class="line">            <span class="comment">//畸变模型求出theta_d，相当于有畸变的角度值</span></span><br><span class="line">            <span class="keyword">double</span> theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*theta4;</span><br><span class="line">            <span class="keyword">double</span> theta_d = theta * (<span class="number">1</span> + k[<span class="number">0</span>]*theta2 + k[<span class="number">1</span>]*theta4 + k[<span class="number">2</span>]*theta6 + k[<span class="number">3</span>]*theta8);</span><br><span class="line">            <span class="comment">//利用有畸变的Theta值，将摄像机坐标系下的归一化三维坐标，重投影到二维图像平面，得到(j,i)对应畸变图像中的(u,v)</span></span><br><span class="line">            <span class="keyword">double</span> scale = (r == <span class="number">0</span>) ? <span class="number">1.0</span> : theta_d / r;</span><br><span class="line">            <span class="keyword">double</span> u = f[<span class="number">0</span>]*x*scale + c[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> v = f[<span class="number">1</span>]*y*scale + c[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存(u,v)坐标到mapx,mapy</span></span><br><span class="line">            <span class="keyword">if</span>( m1type == CV_16SC2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iu = cv::saturate_cast&lt;<span class="keyword">int</span>&gt;(u*cv::INTER_TAB_SIZE);</span><br><span class="line">                <span class="keyword">int</span> iv = cv::saturate_cast&lt;<span class="keyword">int</span>&gt;(v*cv::INTER_TAB_SIZE);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">0</span>] = (<span class="keyword">short</span>)(iu &gt;&gt; cv::INTER_BITS);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">short</span>)(iv &gt;&gt; cv::INTER_BITS);</span><br><span class="line">                m2[j] = (ushort)((iv &amp; (cv::INTER_TAB_SIZE<span class="number">-1</span>))*cv::INTER_TAB_SIZE + (iu &amp; (cv::INTER_TAB_SIZE<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( m1type == CV_32FC1 )</span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m2f[j] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这三条语句是上面 ”//二维图像平面坐标系-&gt;摄像机坐标系“的一部分，是矩阵iR的第一列，这样写能够简化计算</span></span><br><span class="line">            _x += iR(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            _y += iR(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            _w += iR(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通相机模型的畸变校正"><a href="#普通相机模型的畸变校正" class="headerlink" title="普通相机模型的畸变校正"></a>普通相机模型的畸变校正</h3><p>&emsp;&emsp;同样建议参考<a href="https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html" target="_blank" rel="noopener">OpenCV官方文档</a>阅读代码。</p><p>&emsp;&emsp;主要流程和上面Fisheye模型差不多，只有第4部分的畸变模型不一样，普通相机的畸变模型如下：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180128135032366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p> <p>&emsp;&emsp;同样把源代码贴上，并加上注解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> cv::initUndistortRectifyMap( InputArray _cameraMatrix, InputArray _distCoeffs,</span><br><span class="line">                              InputArray _matR, InputArray _newCameraMatrix,</span><br><span class="line">                              Size size, <span class="keyword">int</span> m1type, OutputArray _map1, OutputArray _map2 )</span><br><span class="line">&#123;</span><br><span class="line">    Mat cameraMatrix = _cameraMatrix.getMat(), distCoeffs = _distCoeffs.getMat();</span><br><span class="line">    Mat matR = _matR.getMat(), newCameraMatrix = _newCameraMatrix.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( m1type &lt;= <span class="number">0</span> )</span><br><span class="line">        m1type = CV_16SC2;</span><br><span class="line">    CV_Assert( m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2 );</span><br><span class="line">    _map1.create( size, m1type );</span><br><span class="line">    Mat map1 = _map1.getMat(), map2;</span><br><span class="line">    <span class="keyword">if</span>( m1type != CV_32FC2 )</span><br><span class="line">    &#123;</span><br><span class="line">        _map2.create( size, m1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );</span><br><span class="line">        map2 = _map2.getMat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _map2.release();</span><br><span class="line"></span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; R = Mat_&lt;<span class="keyword">double</span>&gt;::eye(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; A = Mat_&lt;<span class="keyword">double</span>&gt;(cameraMatrix), Ar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !newCameraMatrix.empty() )</span><br><span class="line">        Ar = Mat_&lt;<span class="keyword">double</span>&gt;(newCameraMatrix);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Ar = getDefaultNewCameraMatrix( A, size, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !matR.empty() )</span><br><span class="line">        R = Mat_&lt;<span class="keyword">double</span>&gt;(matR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !distCoeffs.empty() )</span><br><span class="line">        distCoeffs = Mat_&lt;<span class="keyword">double</span>&gt;(distCoeffs);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        distCoeffs.create(<span class="number">14</span>, <span class="number">1</span>, CV_64F);</span><br><span class="line">        distCoeffs = <span class="number">0.</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CV_Assert( A.size() == Size(<span class="number">3</span>,<span class="number">3</span>) &amp;&amp; A.size() == R.size() );</span><br><span class="line">    CV_Assert( Ar.size() == Size(<span class="number">3</span>,<span class="number">3</span>) || Ar.size() == Size(<span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LU分解求新的内参矩阵Ar与旋转矩阵R乘积的逆矩阵iR</span></span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; iR = (Ar.colRange(<span class="number">0</span>,<span class="number">3</span>)*R).inv(DECOMP_LU);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* ir = &amp;iR(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从旧的内参矩阵中取出光心位置u0,v0,和归一化焦距fx,fy</span></span><br><span class="line">    <span class="keyword">double</span> u0 = A(<span class="number">0</span>, <span class="number">2</span>),  v0 = A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> fx = A(<span class="number">0</span>, <span class="number">0</span>),  fy = A(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尼玛14个畸变系数，不过大多用到的只有(k1,k2,p1,p2)，最多加一个k3，用不到的置为0</span></span><br><span class="line">    CV_Assert( distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">4</span>) || distCoeffs.size() == Size(<span class="number">4</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">5</span>) || distCoeffs.size() == Size(<span class="number">5</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">8</span>) || distCoeffs.size() == Size(<span class="number">8</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">12</span>) || distCoeffs.size() == Size(<span class="number">12</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">14</span>) || distCoeffs.size() == Size(<span class="number">14</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( distCoeffs.rows != <span class="number">1</span> &amp;&amp; !distCoeffs.isContinuous() )</span><br><span class="line">        distCoeffs = distCoeffs.t();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* <span class="keyword">const</span> distPtr = distCoeffs.ptr&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">    <span class="keyword">double</span> k1 = distPtr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> k2 = distPtr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">double</span> p1 = distPtr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> p2 = distPtr[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">double</span> k3 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">5</span> ? distPtr[<span class="number">4</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k4 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">5</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k5 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">6</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k6 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">7</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s1 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">8</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s2 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">9</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s3 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">10</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s4 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">11</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> tauX = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">14</span> ? distPtr[<span class="number">12</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> tauY = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">14</span> ? distPtr[<span class="number">13</span>] : <span class="number">0.</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tauX,tauY这个是什么梯形畸变，用不到的话matTilt为单位阵</span></span><br><span class="line">    <span class="comment">// Matrix for trapezoidal distortion of tilted image sensor</span></span><br><span class="line">    cv::Matx33d matTilt = cv::Matx33d::eye();</span><br><span class="line">    cv::detail::computeTiltProjectionMatrix(tauX, tauY, &amp;matTilt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.height; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span>* m1f = map1.ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">float</span>* m2f = map2.empty() ? <span class="number">0</span> : map2.ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">short</span>* m1 = (<span class="keyword">short</span>*)m1f;</span><br><span class="line">        ushort* m2 = (ushort*)m2f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用逆矩阵iR将二维图像坐标(j,i)转换到摄像机坐标系(_x,_y,_w)</span></span><br><span class="line">        <span class="keyword">double</span> _x = i*ir[<span class="number">1</span>] + ir[<span class="number">2</span>], _y = i*ir[<span class="number">4</span>] + ir[<span class="number">5</span>], _w = i*ir[<span class="number">7</span>] + ir[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size.width; j++, _x += ir[<span class="number">0</span>], _y += ir[<span class="number">3</span>], _w += ir[<span class="number">6</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//摄像机坐标系归一化，令Z=1平面</span></span><br><span class="line">            <span class="keyword">double</span> w = <span class="number">1.</span>/_w, x = _x*w, y = _y*w;</span><br><span class="line">             <span class="comment">//这一部分请看OpenCV官方文档，畸变模型部分</span></span><br><span class="line">            <span class="keyword">double</span> x2 = x*x, y2 = y*y;</span><br><span class="line">            <span class="keyword">double</span> r2 = x2 + y2, _2xy = <span class="number">2</span>*x*y;</span><br><span class="line">            <span class="keyword">double</span> kr = (<span class="number">1</span> + ((k3*r2 + k2)*r2 + k1)*r2)/(<span class="number">1</span> + ((k6*r2 + k5)*r2 + k4)*r2);</span><br><span class="line">            <span class="keyword">double</span> xd = (x*kr + p1*_2xy + p2*(r2 + <span class="number">2</span>*x2) + s1*r2+s2*r2*r2);</span><br><span class="line">            <span class="keyword">double</span> yd = (y*kr + p1*(r2 + <span class="number">2</span>*y2) + p2*_2xy + s3*r2+s4*r2*r2);</span><br><span class="line">           <span class="comment">//根据求取的xd,yd将三维坐标重投影到二维畸变图像坐标(u,v)</span></span><br><span class="line">            cv::Vec3d vecTilt = matTilt*cv::Vec3d(xd, yd, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> invProj = vecTilt(<span class="number">2</span>) ? <span class="number">1.</span>/vecTilt(<span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> u = fx*invProj*vecTilt(<span class="number">0</span>) + u0;</span><br><span class="line">            <span class="keyword">double</span> v = fy*invProj*vecTilt(<span class="number">1</span>) + v0;</span><br><span class="line">            <span class="comment">//保存u,v的值到Mapx,Mapy中</span></span><br><span class="line">            <span class="keyword">if</span>( m1type == CV_16SC2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iu = saturate_cast&lt;<span class="keyword">int</span>&gt;(u*INTER_TAB_SIZE);</span><br><span class="line">                <span class="keyword">int</span> iv = saturate_cast&lt;<span class="keyword">int</span>&gt;(v*INTER_TAB_SIZE);</span><br><span class="line">                m1[j*<span class="number">2</span>] = (<span class="keyword">short</span>)(iu &gt;&gt; INTER_BITS);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">short</span>)(iv &gt;&gt; INTER_BITS);</span><br><span class="line">                m2[j] = (ushort)((iv &amp; (INTER_TAB_SIZE<span class="number">-1</span>))*INTER_TAB_SIZE + (iu &amp; (INTER_TAB_SIZE<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( m1type == CV_32FC1 )</span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m2f[j] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j*<span class="number">2</span>] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m1f[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">希望对需要的人能有所帮助，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="OPENCV" scheme="https://wordzzzz.github.io/categories/OPENCV/"/>
    
    
      <category term="OPENCV2" scheme="https://wordzzzz.github.io/tags/OPENCV2/"/>
    
      <category term="OPENCV3" scheme="https://wordzzzz.github.io/tags/OPENCV3/"/>
    
      <category term="畸变校正" scheme="https://wordzzzz.github.io/tags/%E7%95%B8%E5%8F%98%E6%A0%A1%E6%AD%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（递归）：valid-palindrome</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Recursive/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Recursive/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:41:18.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br>“A man, a plan, a canal: Panama”is a palindrome.<br>“race a car”is not a palindrome.</p><p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p><p>For the purpose of this problem, we define empty string as valid palindrome.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>额，判断字符串是否为回文，这道题貌似没什么好说的，需要注意的是空字符串也算回文哦。</p><p>从两边开始遍历字符串，如果遇到非数字字符的就跳过，然后比较当前两个字符是否相等；相等就进入下一个循环，否则返回false。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>; i &lt; j; ++i, --j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; <span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromeCore</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; !<span class="built_in">isalnum</span>(s[start]))</span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; !<span class="built_in">isalnum</span>(s[end]))</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end &amp;&amp; <span class="built_in">tolower</span>(s[start]) != <span class="built_in">tolower</span>(s[end]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPalindromeCore(s, ++start, --end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isPalindromeCore(s, <span class="number">0</span>, s.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Recursive" scheme="https://wordzzzz.github.io/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：minimum-window-substring</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy3/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy3/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:42:52.897Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br>S =”ADOBECODEBANC”<br>T =”ABC”</p><p>Minimum window is”BANC”.</p><p>Note:<br>If there is no such window in S that covers all characters in T, return the emtpy string””.</p><p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题被自己的无知给坑了，在java里面传人substring的两个参数分别是截取字符串起始位置和截止位置，在本题中应该写成substring(head, head+d);在C++里面传人substr的两个参数分别是截取字符串起始位置和截取字符串长度，在本题中应该写成substr(head, d)。</p><p>这道题的思路是：</p><ul><li>begin开始指向0， end一直后移，直到begin - end区间包含T中所有字符。<br>记录窗口长度d</li><li>然后begin开始后移移除元素，直到移除的字符是T中的字符则停止，此时T中有一个字符没被<br>包含在窗口，<br>继续后移end，直到T中的所有字符被包含在窗口，重新记录最小的窗口d。</li><li>如此循环知道end到S中的最后一个字符。<br>时间复杂度为O(n)</li></ul><p>下面贴一下大神的模板，对于大多数子字符串问题，我们给了一个字符串，并且需要找到满足一些限制的子字符串。一般的方法是使用两个指针辅助的hashmap。模板如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter; <span class="comment">// check whether the substring is valid</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">//two pointers, one point to tail and one  head</span></span><br><span class="line">        <span class="keyword">int</span> d; <span class="comment">//the length of substring</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>() &#123; <span class="comment">/* initialize the hash map here */</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]-- ?)&#123;  <span class="comment">/* modify counter here */</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="comment">/* counter condition */</span>)&#123; </span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">/* update d here if finding minimum*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//increase begin to make it invalid/valid again</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++ ?)&#123; <span class="comment">/*modify counter here*/</span> &#125;</span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update d here if finding maximum*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有一点需要提到的是，当要求查找最大子字符串时，我们应该在内部while循环之后更新最大值，以保证子字符串是有效的。另一方面，当要求查找最小子字符串时，我们应该更新内部while循环内的最小值。</p><p>解决最多两个不同字符的最长子字符串的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="keyword">while</span>(counter &gt; <span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]-- == <span class="number">1</span>) counter--;</span><br><span class="line">            d = max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解决最长子字符串不重复字符的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++ &gt; <span class="number">0</span>) counter++; </span><br><span class="line">            <span class="keyword">while</span>(counter&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]-- &gt; <span class="number">1</span>) counter--;</span><br><span class="line">            d=max(d, end - begin); <span class="comment">//while valid, update d</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> counter = t.size(), begin = <span class="number">0</span>, end = <span class="number">0</span>, d = INT_MAX, head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]-- &gt;<span class="number">0</span>) counter--; <span class="comment">//in t</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123; <span class="comment">//valid</span></span><br><span class="line">                <span class="keyword">if</span>(end - begin &lt; d)  d = end - (head = begin);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++ == <span class="number">0</span>) counter++;  <span class="comment">//make it invalid</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d == INT_MAX? <span class="string">""</span>:s.substr(head, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808" target="_blank" rel="noopener">参考链接：minimum-window-substring</a></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：maximal-rectangle</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy2/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy2/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:42:23.580Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>给定一个用0和1填充的2D二进制矩阵，找到包含所有1的最大矩形并返回其面积。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚看到这道题的时候，一脸无奈。我们还是先来看一下Largest Rectangle in Histogram这道题目吧。</p><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h3><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126101534175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126101634504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p><p>我们先把代码贴出来，然后边看代码边捋清思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);<span class="comment">//追加一个零用来做终止条件。</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; height.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i] &gt;= height[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                maxSize = max(maxSize, cur * (s.empty() ? i : i - <span class="number">1</span> - s.top()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>首先，我们需要新建stack来保存遍历过程中的递增序列。如果栈是空的，那么索引i入栈。所以当i=0时，将0入栈。注意栈内保存的是索引，不是高度。然后i++。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126110920004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>当i=1的时候，发现height[i]小于了栈内的元素，于是出栈。这时候stack为空，所以面积的计算是height[t] * i。t是刚刚弹出的stack顶元素。也就是蓝色部分的面积。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111432408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>这时候stack为空了，那就继续入栈。注意到只要是连续递增的序列，我们都要keep pushing，直到我们遇到了i=4，height[i]=2小于了栈顶的元素。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111452015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>这时候开始计算矩形面积。首先弹出栈顶元素，t=3。即下图绿色部分。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111528463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>接下来注意到栈顶的（索引指向的）元素还是大于当前i指向的元素，于是出栈，并继续计算面积，桃红色部分。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111658101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>最后，栈顶的（索引指向的）元素大于了当前i指向的元素，循环继续，入栈并推动i前进。直到我们再次遇到下降的元素，也就是我们最后人为添加的dummy元素0.</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111715452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>同理，我们计算栈内的面积。由于当前i是最小元素，所以所有的栈内元素都要被弹出并参与面积计算。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111731018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>注意我们在计算面积的时候已经更新过了maxSize 。</p><p>我们可以看到，stack中总是保持递增的元素的索引，然后当遇到较小的元素后，依次出栈并计算栈中bar能围成的面积，直到栈中元素小于当前元素。</p><h3 id="maximal-rectangle"><a href="#maximal-rectangle" class="headerlink" title="maximal-rectangle"></a>maximal-rectangle</h3><p>这道题的解法灵感来自于Largest Rectangle in Histogram这道题，假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据Largest Rectangle in Histogram中的largestRectangleArea函数我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。算法时间复杂度为O(m*n)，这解法真是太棒了，其实应该算是动态规划的题目了。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);<span class="comment">//追加一个零用来做终止条件。</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; height.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i] &gt;= height[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                maxSize = max(maxSize, cur * (s.empty() ? i : i - <span class="number">1</span> - s.top()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxRec = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height(matrix[<span class="number">0</span>].size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)<span class="comment">//这里的数字1一定要加单引号哦~</span></span><br><span class="line">                    height[j]++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxRec = max(maxRec, largestRectangleArea(height));<span class="comment">//对每一行都求一次最大值，而不是只有最后一行。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="noopener">参考链接</a></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：gas-station</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy1/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy1/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:41:55.145Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i isgas[i].</p><p>You have a car with an unlimited gas tank and it costscost[i]of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p><p>Note:<br>The solution is guaranteed to be unique.</p><p>沿着一个圆形的路线有N个加油站，那里的加油站的天然气数量是gas [i]。 你有一辆带有无限制燃气罐的汽车，从车站i到下一站（i + 1）需要花费天然气。 你从一个加油站开始，开始时邮箱为空。 如果您可以在电路上巡回一次，则返回启动加油站的索引，否则返回-1。 注意：解决方案保证是唯一的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从start出发，如果油量足够，可以一直向后走end++；油量不够的时候，<br>start向后退，最终start == end的时候，如果有解一定是当前start所在位置。</p><p>因为是个环，所以我们将最后一个元素设置为起点，第一个元素设置为start下一点，这样可以用统一的判断条件start &lt; end来作为循环的条件，当start和end两者相等时，循环结束。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gas.size() &lt;= <span class="number">0</span> || cost.size() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = gas.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = gas[start] - cost[start];</span><br><span class="line">        <span class="keyword">while</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum += gas[end] - cost[end];</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                --start;</span><br><span class="line">                sum += gas[start] - cost[start];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：median-of-two-sorted-arrays</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST6/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST6/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:14:00.693Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求在O(log (m+n))时间内找到中位数，所以像那些合并之后再二分查找、或者一边比较一边合并到总量一半的方法肯定是不行的。</p><p>我们可以将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m+n)/2小的数。所以只要解决了第k小数的问题，原问题也得以解决。</p><p>首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。如果A[k/2-1] &lt; B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。</p><p>当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。)</p><p>通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件：</p><ul><li>如果A或者B为空，则直接返回B[k-1]或者A[k-1]；</li><li>如果k为1，我们只需要返回A[0]和B[0]中的较小值；</li><li>如果A[k/2-1]=B[k/2-1]，返回其中一个；</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findKth(B, n, A, m, k);  <span class="comment">//始终保持元素较少的数组位于前面的位置</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B[k<span class="number">-1</span>];                  <span class="comment">//如果位于前面的数组为空，则直接返回后面数组的第k-1个元素</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(A[<span class="number">0</span>], B[<span class="number">0</span>]);         <span class="comment">//如果k等于1，则返回两个数组头元素的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pa = min(k / <span class="number">2</span>, m), pb = k - pa;</span><br><span class="line">        <span class="keyword">if</span>(A[pa<span class="number">-1</span>] &lt; B[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(A + pa, m - pa, B, n, k - pa);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[pa - <span class="number">1</span>] &gt; B[pb - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(A, m, B + pb, n - pb, k - pb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A[pa<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">        <span class="keyword">if</span>(total &amp; <span class="number">0x1</span>)</span><br><span class="line">            <span class="keyword">return</span> findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(A, m, B, n, total/<span class="number">2</span>)</span><br><span class="line">                   + findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：reverse-nodes-in-k-group</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST1/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST1/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:09:28.469Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.</p><p>Only constant memory is allowed.</p><p>For example,<br>Given this linked list:1-&gt;2-&gt;3-&gt;4-&gt;5；</p><p>For k = 2, you should return:2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return:3-&gt;2-&gt;1-&gt;4-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解法有两种，一种是申请额外空间来依次对k个元素进行排序，时间复杂度O(n)，空间复杂度O(k)。另一种是在原链表中进行反转，不需要额外空间，所以算法复杂度为O(n)，空间复杂度为O(1)。</p><p>本文中对第二种解法进行详细的讲解。</p><ul><li>首先，单个链表的反转我想大家肯定都会，那就是遍历链表，每遇见一个结点就扔到第一位。因为涉及到第一个结点的操作，所以我们一定要有指向第一个结点的指针，这里在传参的时候需要注意。</li><li>接下来，我们采用整除来每次提取k个结点。需要注意的同样是参数的传递，怎么对接自己得把握好。就拿例题中的题目（list:1-&gt;2-&gt;3-&gt;4-&gt;5；k=3）来说，我的代码传入reverseList的参数应该是指向1的上一个结点的指针和指向4的指针。</li><li>最后，贴代码呗。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *slow, ListNode *fast)</span></span>&#123;</span><br><span class="line">        ListNode *last = slow-&gt;next;</span><br><span class="line">        ListNode *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != fast)&#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = slow-&gt;next;</span><br><span class="line">            slow-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">                slow = reverseList(slow, fast-&gt;next);</span><br><span class="line">                fast = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：add-two-numbers</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST5/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST5/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:13:11.020Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个链表求和，需要考虑进位问题。</p><p>首先新建链表，用于存储求和之后的结点；循环的终止条件是，直到l1或l2都为空且进位标志位为0；循环内，每次都进行求和运算和更新head的值。</p><p>在求carry的时候我们采用判断而不是除法，这一点大家需要注意，并且在以后的程序设计中也要尽量较少乘除法这种比较耗时的运算操作。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;                      <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> sum;                            <span class="comment">//求和</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode (<span class="number">0</span>); <span class="comment">//新建链表</span></span><br><span class="line">        ListNode *head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || carry)&#123;</span><br><span class="line">            sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            head-&gt;next = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：swap-nodes-in-pairs</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST2/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST2/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:10:10.036Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given1-&gt;2-&gt;3-&gt;4, you should return the list as2-&gt;1-&gt;4-&gt;3.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过这么多次的编程练习，链表的顺序交换我相信大家早已轻车熟路。本题中，我们先写一个交换相邻结点的函数swap，此函数交换输入的两个相邻链表结点之后，返回新的第一结点。然后我们开始考虑主函数，同样的新建一个指向头结点的指针（只要头结点有可能被替换，我们既需要这么做），然后遍历整个链表调用交换函数swap即可。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swap</span><span class="params">(ListNode *slow, ListNode *fast)</span></span>&#123;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = slow;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(;cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>; cur = cur-&gt;next-&gt;next)</span><br><span class="line">            cur-&gt;next = swap(cur-&gt;next, cur-&gt;next-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：merge-k-sorted-lists</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST3/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST3/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:11:07.273Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>之前做过一道题是对两个排序链表进行合并，这次是k个。所以，需要在原来的基础长做一些封装。</p><p>按照归并排序的思想，我们通过二分法得到中点进行递归，自下而上进行两两归并，直到只剩最后一个链表。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeList(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeList</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(high &lt;= low)</span><br><span class="line">            <span class="keyword">return</span> lists[low];</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        ListNode *left = mergeList(lists, low, mid);</span><br><span class="line">        ListNode *right = mergeList(lists, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val &lt; right-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-nth-node-from-end-of-list</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST4/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST4/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:12:03.256Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, remove the n th node from the end of list and return its head.</p><p>For example,</p><p>   Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>删除倒数第n个结点，我们就需要找到倒数第n个结点。于是，我们可以利用快慢指针来实现。</p><p>首先，fast走n步指向第n个结点；接着，fast和slow一起走，直到fast指向尾结点；最后，删除元素（这里需要注意的是加入pre来判断删除元素是否为头结点）。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//fast先走n步，到达第n个结点</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">//fast和slow一起走，直到fast走到链表尾部</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处用于判断删除的结点是否为头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list</title>
    <link href="https://wordzzzz.github.io/2018/01/17/LIST1/"/>
    <id>https://wordzzzz.github.io/2018/01/17/LIST1/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:09:34.419Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>For example,<br>Given1-&gt;1-&gt;2, return1-&gt;2.<br>Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单问题不要想的太复杂，直接嵌套循环搞定喽。外循环用来遍历链表，内循环用来遍历重复元素，如果重复就一直传递指针。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *dummy = head;</span><br><span class="line">        <span class="keyword">while</span>(dummy != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(dummy-&gt;next != <span class="literal">NULL</span> &amp;&amp; dummy-&gt;val == dummy-&gt;next-&gt;val)&#123;</span><br><span class="line">                dummy-&gt;next = dummy-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
</feed>
