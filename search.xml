<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（树）：sum-root-to-leaf-numbers]]></title>
    <url>%2F2018%2F02%2F07%2FTree4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a binary tree containing digits from0-9only, each root-to-leaf path could represent a number. An example is the root-to-leaf path1-&gt;2-&gt;3which represents the number123. Find the total sum of all root-to-leaf numbers. For example, 1 / \ 2 3 The root-to-leaf path1-&gt;2represents the number12.The root-to-leaf path1-&gt;3represents the number13. Return the sum = 12 + 13 =25. 给定一个二进制树，只包含0-9的数字，每个根到叶的路径可以代表一个数字。 一个例子是代表数字123的根到叶子路径1-&gt; 2-&gt; 3。 找到所有根到叶子数量的总和。 例如，1 / \ 2 3根到叶子路径1 - &gt; 2表示数字12。 根到叶子路径1-&gt; 3表示数字13。 返回总和= 12 + 13 = 25。 解题思路两种方法，递归和迭代，递归太简单了，直接贴出代码就不多说了。 前序遍历需要注意的是，因为stack是后入先出规则，所以我们在入栈的时候，先将右子树入栈，再将坐子树入栈，这样在出栈的时候就可以保证是先左后右了。 C++版代码实现递归1234567891011121314151617181920212223242526/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void preorder(TreeNode *root, vector&lt;int&gt; &amp;res)&#123; if(root)&#123; res.push_back(root-&gt;val); preorder(root-&gt;left, res); preorder(root-&gt;right, res); &#125; &#125; vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; preorder(root, res); return res; &#125;&#125;; 迭代1234567891011121314151617181920212223242526272829/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; stack&lt;TreeNode *&gt; sta; sta.push(root); while(!sta.empty())&#123; TreeNode *cur = sta.top(); sta.pop(); res.push_back(cur-&gt;val); if(cur-&gt;right) sta.push(cur-&gt;right); if(cur-&gt;left) sta.push(cur-&gt;left); &#125; return res; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（树）：binary-tree-preorder-traversal]]></title>
    <url>%2F2018%2F02%2F07%2FTree3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree{1,#,2,3}, 1 \ 2 / 3 return[1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 给定一个二叉树，返回其节点值的前序遍历。 注意：递归解决方案是微不足道的，你可以迭代地做？ 解题思路采用先序遍历的思想(根左右)+数字求和的思想(每一层都比上层和*10+当前根节点的值)。 C++版代码实现123456789101112131415161718192021222324252627/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int preorder(TreeNode *root, int sum)&#123; if(root == NULL) return 0; sum = sum * 10 + root-&gt;val; if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return sum; return preorder(root-&gt;left, sum) + preorder(root-&gt;right, sum); &#125; int sumNumbers(TreeNode *root) &#123; if(root == NULL) return 0; int sum = 0; return preorder(root, sum); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（树）：minimum-depth-of-binary-tree]]></title>
    <url>%2F2018%2F02%2F07%2FTree1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 给定一棵二叉树，找到它的最小深度。最小深度是沿着从根节点到最近叶节点的最短路径的节点数量。 解题思路DFS和BFS都可以，但是很明显，BFS更快，因为BFS只要找到第一个叶子结点就可以停止遍历了看，而DFS需要通过迭代来遍历所有的结点。 这里我重点说一下BFS，循环的终止条件是now结点无左右子树，即size前后无变化。 C++版代码实现深度优先搜索1234567891011121314class Solution &#123;public: int run(TreeNode *root) &#123; if(root == NULL) return false; if(root-&gt;left == NULL) return run(root-&gt;right) + 1; if(root-&gt;right == NULL) return run(root-&gt;left) + 1; int leftDepth = run(root-&gt;left); int rightDepth = run(root-&gt;right); return min(leftDepth, rightDepth) + 1; &#125;&#125;; 广度优先搜索1234567891011121314151617181920212223242526272829class Solution &#123;public: int run(TreeNode *root) &#123; if(root == NULL) return false; queue&lt;TreeNode *&gt; que; TreeNode *last, *now; int level = 1, size = 0; last = now = root; que.push(root); while(!que.empty())&#123; now = que.front(); que.pop(); size = que.size(); if(now-&gt;left) que.push(now-&gt;left); if(now-&gt;right) que.push(now-&gt;right); if(que.size() == size) //循环终止条件 break; if(last == now)&#123; level++; if(que.size() != 0) last = que.back(); &#125; &#125; return level; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（树）：binary-tree-postorder-traversal]]></title>
    <url>%2F2018%2F02%2F07%2FTree2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a binary tree, return the postorder traversal of its nodes’ values. For example:Given binary tree{1,#,2,3}, 1 \ 2 / 3 return[3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 给定一个二叉树，返回其节点值的后序遍历。 注意：递归解决方案是微不足道的，你可以迭代地做？ 解题思路两种方法，递归和迭代，递归太简单了，直接贴出代码就不多说了。 后序遍历的非递归版可以说是三种遍历中最难的了，因为要先穷举左右结点，最后才是根结点。在外循环中，第一步还是依次将左子树入栈；然后看栈顶元素，如果栈顶元素没有右孩子，或者右孩子时候已经遍历过，那么就弹出栈顶元素，并记录；否则，遍历右子树。 C++版代码实现递归1234567891011121314151617181920212223242526/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void postorder(TreeNode *root, vector&lt;int&gt; &amp;res)&#123; if(root)&#123; postorder(root-&gt;left, res); postorder(root-&gt;right, res); res.push_back(root-&gt;val); &#125; &#125; vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; postorder(root, res); return res; &#125;&#125;; 迭代1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode *&gt; sta; TreeNode *cur = root, *last = NULL; while(cur != NULL || !sta.empty())&#123; while(cur != NULL)&#123; sta.push(cur); cur = cur-&gt;left; &#125; cur = sta.top(); if(cur-&gt;right == NULL || cur-&gt;right == last)&#123; sta.pop(); res.push_back(cur-&gt;val); last = cur; cur = NULL; &#125;else cur = cur-&gt;right; &#125; return res; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（模拟）：pascals-triangle-ii]]></title>
    <url>%2F2018%2F02%2F02%2FSimulation2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given an index k, return the k th row of the Pascal’s triangle. For example, given k = 3,Return[1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? 给定一个索引k，返回帕斯卡三角形的第k行。 例如，给定k = 3， 返回[1,3,3,1]。 注意： 你可以优化你的算法只使用O（K）额外的空间？ 解题思路基本的想法是从头到尾迭代地更新数组。 C++版代码实现12345678910class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; dummp(rowIndex+1, 1); for(int i = 1; i &lt; rowIndex; ++i) for(int j = i; j &gt; 0; --j) dummp[j] += dummp[j-1]; return dummp; &#125;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（穷举）：max-points-on-a-line]]></title>
    <url>%2F2018%2F02%2F02%2FExhaustive%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 给定2D平面上的n个点，找出位于同一直线上的最大点数。 解题思路两点确定一条直线，同时，对于斜率不为零的直线，都有y=kx+b。对于重复点，肯定也算是共线，所以，我们首先计算重复点的个数，然后计算斜率为0时共线的点个数，最后再计算其他斜率下共线的点的个数。 需要两重循环，第一重循环遍历起始点a，第二重循环遍历剩余点b。 如果a和b重合，duplicate累加； 如果a和b不重合，且两者斜率为0，则numVertical累加； 如果a和b不重合，且两者斜率不为零，则计算斜率并计入map中，同时更新map中对应值； 内循环结束后，返回max(local + duplicate, numVertical + duplicate)与之前的最大值res的最大值，local和numVertical算是不同斜率下的最大值； 外循环结束后，返回res。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for a point. * struct Point &#123; * int x; * int y; * Point() : x(0), y(0) &#123;&#125; * Point(int a, int b) : x(a), y(b) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; if(points.size() &lt;= 2) return points.size(); int res = 0; for(int i = 0; i &lt; points.size() - 1; ++i)&#123; unordered_map&lt;double, int&gt; map; int numVertical = 0, local = 1, duplicate = 0; for(int j = i + 1; j &lt; points.size(); ++j) if(points[i].x == points[j].x) if(points[i].y == points[j].y) //重复点 duplicate++; else //垂直点 numVertical == 0 ? numVertical = 2 : numVertical++; else &#123; double slope = (points[i].y - points[j].y) * 1.0 / (points[i].x - points[j].x); map[slope] == 0 ? map[slope] = 2 : map[slope]++; local = max(local, map[slope]); &#125; local = max(local + duplicate, numVertical + duplicate); res = max(res, local); &#125; return res; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Exhaustive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（模拟）：pascals-triangle]]></title>
    <url>%2F2018%2F02%2F02%2FSimulation1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 给定numRows，生成帕斯卡三角形的前numRows行。 解题思路题目比较古老，几行代码就能搞定，注意一下代码中的边界条件。 我感觉像下面这样写会更直观一些，每一行两头的1我们都直接添加即可，从第三行开始，假定用res[][]表示下面各个值的位置，那么第三行的2所在的位置就是res[2][1]。res[2][1] = res[1][1] + res[1][0]，推广之后为res[i][j] = res[i][j] + res[i][j-1]，这就是中间这些数的计算公式，还是要注意边界问题。 1234511 11 2 11 3 3 11 4 6 4 1 C++版代码实现1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res(numRows); for(int i = 0; i &lt; numRows; ++i)&#123; res[i].push_back(1); //第一个位置为1 for(int j = 1; j &lt; i; ++j) res[i].push_back(res[i-1][j-1] + res[i-1][j]); //j从1开始，那么只有i&gt;=2的时候才会执行这部分 if(i &gt; 0) res[i].push_back(1); //最后一个位置也为1，需要注意是不能再第一行中添加 &#125; return res; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（模拟）：divide-two-integers]]></title>
    <url>%2F2018%2F02%2F02%2FSimulation3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Divide two integers without using multiplication, division and mod operator. 不用乘法，除法和取模运算符来计算两个整数相除的结果。 解题思路假设我们要划分15和3，所以15是dividend、3是divisor。那么划分只需要我们找出可以从dividend中减去多少次divisor，而不会造成dividend负面影响。 首先是15-3=12，然后让我们尝试去减去更多。3左移一位得6，15-6=9。6左移一位是12，15-12=3。当我们再次对12进行左移得到24时，已经比15大了，所以15最多可以减去12。12是3的四倍，那么我们怎么得到这个4呢？其实我们可以在3（cur）左移的时候，对1（multiple）进行同样的左移操作即可，这样，当cur成为12的时候，multiple正好是4。 接下来，把15-12剩下的3再次进行循环，得出multiple为1，所以最后得到4+1=5次。 根据问题陈述，我们需要处理一些例外，例如溢出。 那么有两种情况可能会导致溢出： divisor = 0; dividend = INT_MIN和divisor = -1（因为abs(INT_MIN) = INT_MAX + 1）。 当然，我们也需要考虑相对容易的标志。 C++版代码实现1234567891011121314151617181920class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || dividend == INT_MIN &amp;&amp; divisor == -1) return INT_MAX; long long dvd = labs(dividend); long long dvs = labs(divisor); int res = 0; while(dvd &gt;= dvs)&#123; long long cur = dvs, multiple = 1; while(dvd &gt;= cur &lt;&lt; 1)&#123; cur &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= cur; res += multiple; &#125; return ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -res : res; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鱼眼摄像头标定与畸变校正（双OPENCV版本）]]></title>
    <url>%2F2018%2F01%2F28%2FOPENCV%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/fisheye_calibration 软件版本：VS2013+OPENCV2.4.13 OR VS2013+OPENCV3.4.0 编&emsp;&emsp;者：WordZzzz [toc] 我的代码&emsp;&emsp;最近在整理自己以前做过的一些东西，这是基于opencv的鱼眼摄像头畸变校正程序的github地址。 其中： normal_calibrate：基于OPENCV2与OPENCV3通用的函数实现，可实现USB摄像头实时畸变校正； fishey_calibrate：基于OPENCV3独有的fishyey结构体实现，可实现USB摄像头实时畸变校正； fishey_calibrate_img：基于OPENCV3独有的fishyey结构体实现，可实现单张图片畸变校正； &emsp;&emsp;opencv1.0 2.0版只有一种摄像机标定模型，就是普通的小孔成像模型，在cv：：空间下。而从opencv3.0开始，新增了一种鱼眼相机标定模型，在fisheye::空间下。两种模型的主要区别在于像与物的投影关系不同，具体的文献资料依然是数不胜数，这里就不赘述。根据opencv官方文档的建议，在畸变程度较大的广角镜头（比如：鱼眼镜头）上进行摄像机标定和畸变校正，最好是用fisheye模型，该模型在图像边缘畸变程度很大的地方比普通相机模型的效果要好。 &emsp;&emsp;当然，还是要贴上官方文档的： Camera calibration With OpenCV2； Camera calibration With OpenCV3； 华丽的分割线 可供参考资料&emsp;&emsp;以下是在写这篇博客的时候偶然发现的对opencv两个版本标定过程的讲解，这里直接copy过来并稍微做了一下排版，因为自己忙于为找工作做准备，实在是没时间自己整理了。原文链接。 &emsp;&emsp;图像算法中会经常用到摄像机的畸变校正，有必要总结分析OpenCV中畸变校正方法，其中包括普通针孔相机模型和鱼眼相机模型fisheye两种畸变校正方法。 &emsp;&emsp;普通相机模型畸变校正函数针对OpenCV中的cv::initUndistortRectifyMap()，鱼眼相机模型畸变校正函数对应OpenCV中的cv::fisheye::initUndistortRectifyMap()。两种方法算出映射Mapx和Mapy后，统一用cv::Remap()函数进行插值得到校正后的图像。 FishEye模型的畸变校正。&emsp;&emsp;方便起见，直接贴出OpenCV源码，我在里面加了注释说明。建议参考OpenCV官方文档看畸变模型原理会更清楚。 &emsp;&emsp;简要流程就是： 1.求内参矩阵的逆，由于摄像机坐标系的三维点到二维图像平面，需要乘以旋转矩阵R和内参矩阵K。那么反向投影回去则是二维图像坐标乘以 K*R的逆矩阵。 2.将目标图像中的每一个像素点坐标(j,i)，乘以1中求出的逆矩阵iR，转换到摄像机坐标系（_x,_y,_w）,并归一化得到z=1平面下的三维坐标(x,y,1)。 3.求出平面模型下像素点对应鱼眼半球模型下的极坐标(r, theta)。 4.利用鱼眼畸变模型求出拥有畸变时像素点对应的theta_d。 5.利用求出的theta_d值将三维坐标点重投影到二维图像平面得到(u,v)，(u,v)即为目标图像对应的畸变图像中像素点坐标。 6.使用cv::Remap（）函数，根据mapx,mapy取出对应坐标位置的像素值赋值给目标图像，一般采用双线性插值法，得到畸变校正后的目标图像。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;opencv2\opencv.hpp&gt;void cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size&amp; size, int m1type, OutputArray map1, OutputArray map2 )&#123; CV_Assert( m1type == CV_16SC2 || m1type == CV_32F || m1type &lt;=0 ); map1.create( size, m1type &lt;= 0 ? CV_16SC2 : m1type ); map2.create( size, map1.type() == CV_16SC2 ? CV_16UC1 : CV_32F ); CV_Assert((K.depth() == CV_32F || K.depth() == CV_64F) &amp;&amp; (D.depth() == CV_32F || D.depth() == CV_64F)); CV_Assert((P.empty() || P.depth() == CV_32F || P.depth() == CV_64F) &amp;&amp; (R.empty() || R.depth() == CV_32F || R.depth() == CV_64F)); CV_Assert(K.size() == Size(3, 3) &amp;&amp; (D.empty() || D.total() == 4)); CV_Assert(R.empty() || R.size() == Size(3, 3) || R.total() * R.channels() == 3); CV_Assert(P.empty() || P.size() == Size(3, 3) || P.size() == Size(4, 3)); //从内参矩阵K中取出归一化焦距fx,fy; cx,cy cv::Vec2d f, c; if (K.depth() == CV_32F) &#123; Matx33f camMat = K.getMat(); f = Vec2f(camMat(0, 0), camMat(1, 1)); c = Vec2f(camMat(0, 2), camMat(1, 2)); &#125; else &#123; Matx33d camMat = K.getMat(); f = Vec2d(camMat(0, 0), camMat(1, 1)); c = Vec2d(camMat(0, 2), camMat(1, 2)); &#125; //从畸变系数矩阵D中取出畸变系数k1,k2,k3,k4 Vec4d k = Vec4d::all(0); if (!D.empty()) k = D.depth() == CV_32F ? (Vec4d)*D.getMat().ptr&lt;Vec4f&gt;(): *D.getMat().ptr&lt;Vec4d&gt;(); //旋转矩阵RR转换数据类型为CV_64F，如果不需要旋转，则RR为单位阵 cv::Matx33d RR = cv::Matx33d::eye(); if (!R.empty() &amp;&amp; R.total() * R.channels() == 3) &#123; cv::Vec3d rvec; R.getMat().convertTo(rvec, CV_64F); RR = Affine3d(rvec).rotation(); &#125; else if (!R.empty() &amp;&amp; R.size() == Size(3, 3)) R.getMat().convertTo(RR, CV_64F); //新的内参矩阵PP转换数据类型为CV_64F cv::Matx33d PP = cv::Matx33d::eye(); if (!P.empty()) P.getMat().colRange(0, 3).convertTo(PP, CV_64F); //关键一步：新的内参矩阵*旋转矩阵，然后利用SVD分解求出逆矩阵iR，后面用到 cv::Matx33d iR = (PP * RR).inv(cv::DECOMP_SVD); //反向映射，遍历目标图像所有像素位置，找到畸变图像中对应位置坐标(u,v)，并分别保存坐标(u,v)到mapx和mapy中 for( int i = 0; i &lt; size.height; ++i) &#123; float* m1f = map1.getMat().ptr&lt;float&gt;(i); float* m2f = map2.getMat().ptr&lt;float&gt;(i); short* m1 = (short*)m1f; ushort* m2 = (ushort*)m2f; //二维图像平面坐标系-&gt;摄像机坐标系 double _x = i*iR(0, 1) + iR(0, 2), _y = i*iR(1, 1) + iR(1, 2), _w = i*iR(2, 1) + iR(2, 2); for( int j = 0; j &lt; size.width; ++j) &#123; //归一化摄像机坐标系，相当于假定在Z=1平面上 double x = _x/_w, y = _y/_w; //求鱼眼半球体截面半径r double r = sqrt(x*x + y*y); //求鱼眼半球面上一点与光心的连线和光轴的夹角Theta double theta = atan(r); //畸变模型求出theta_d，相当于有畸变的角度值 double theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*theta4; double theta_d = theta * (1 + k[0]*theta2 + k[1]*theta4 + k[2]*theta6 + k[3]*theta8); //利用有畸变的Theta值，将摄像机坐标系下的归一化三维坐标，重投影到二维图像平面，得到(j,i)对应畸变图像中的(u,v) double scale = (r == 0) ? 1.0 : theta_d / r; double u = f[0]*x*scale + c[0]; double v = f[1]*y*scale + c[1]; //保存(u,v)坐标到mapx,mapy if( m1type == CV_16SC2 ) &#123; int iu = cv::saturate_cast&lt;int&gt;(u*cv::INTER_TAB_SIZE); int iv = cv::saturate_cast&lt;int&gt;(v*cv::INTER_TAB_SIZE); m1[j*2+0] = (short)(iu &gt;&gt; cv::INTER_BITS); m1[j*2+1] = (short)(iv &gt;&gt; cv::INTER_BITS); m2[j] = (ushort)((iv &amp; (cv::INTER_TAB_SIZE-1))*cv::INTER_TAB_SIZE + (iu &amp; (cv::INTER_TAB_SIZE-1))); &#125; else if( m1type == CV_32FC1 ) &#123; m1f[j] = (float)u; m2f[j] = (float)v; &#125; //这三条语句是上面 ”//二维图像平面坐标系-&gt;摄像机坐标系“的一部分，是矩阵iR的第一列，这样写能够简化计算 _x += iR(0, 0); _y += iR(1, 0); _w += iR(2, 0); &#125; &#125;&#125; 普通相机模型的畸变校正&emsp;&emsp;同样建议参考OpenCV官方文档阅读代码。 &emsp;&emsp;主要流程和上面Fisheye模型差不多，只有第4部分的畸变模型不一样，普通相机的畸变模型如下： &emsp;&emsp;同样把源代码贴上，并加上注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;opencv2\opencv.hpp&gt;void cv::initUndistortRectifyMap( InputArray _cameraMatrix, InputArray _distCoeffs, InputArray _matR, InputArray _newCameraMatrix, Size size, int m1type, OutputArray _map1, OutputArray _map2 )&#123; Mat cameraMatrix = _cameraMatrix.getMat(), distCoeffs = _distCoeffs.getMat(); Mat matR = _matR.getMat(), newCameraMatrix = _newCameraMatrix.getMat(); if( m1type &lt;= 0 ) m1type = CV_16SC2; CV_Assert( m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2 ); _map1.create( size, m1type ); Mat map1 = _map1.getMat(), map2; if( m1type != CV_32FC2 ) &#123; _map2.create( size, m1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 ); map2 = _map2.getMat(); &#125; else _map2.release(); Mat_&lt;double&gt; R = Mat_&lt;double&gt;::eye(3, 3); Mat_&lt;double&gt; A = Mat_&lt;double&gt;(cameraMatrix), Ar; if( !newCameraMatrix.empty() ) Ar = Mat_&lt;double&gt;(newCameraMatrix); else Ar = getDefaultNewCameraMatrix( A, size, true ); if( !matR.empty() ) R = Mat_&lt;double&gt;(matR); if( !distCoeffs.empty() ) distCoeffs = Mat_&lt;double&gt;(distCoeffs); else &#123; distCoeffs.create(14, 1, CV_64F); distCoeffs = 0.; &#125; CV_Assert( A.size() == Size(3,3) &amp;&amp; A.size() == R.size() ); CV_Assert( Ar.size() == Size(3,3) || Ar.size() == Size(4, 3)); //LU分解求新的内参矩阵Ar与旋转矩阵R乘积的逆矩阵iR Mat_&lt;double&gt; iR = (Ar.colRange(0,3)*R).inv(DECOMP_LU); const double* ir = &amp;iR(0,0); //从旧的内参矩阵中取出光心位置u0,v0,和归一化焦距fx,fy double u0 = A(0, 2), v0 = A(1, 2); double fx = A(0, 0), fy = A(1, 1); //尼玛14个畸变系数，不过大多用到的只有(k1,k2,p1,p2)，最多加一个k3，用不到的置为0 CV_Assert( distCoeffs.size() == Size(1, 4) || distCoeffs.size() == Size(4, 1) || distCoeffs.size() == Size(1, 5) || distCoeffs.size() == Size(5, 1) || distCoeffs.size() == Size(1, 8) || distCoeffs.size() == Size(8, 1) || distCoeffs.size() == Size(1, 12) || distCoeffs.size() == Size(12, 1) || distCoeffs.size() == Size(1, 14) || distCoeffs.size() == Size(14, 1)); if( distCoeffs.rows != 1 &amp;&amp; !distCoeffs.isContinuous() ) distCoeffs = distCoeffs.t(); const double* const distPtr = distCoeffs.ptr&lt;double&gt;(); double k1 = distPtr[0]; double k2 = distPtr[1]; double p1 = distPtr[2]; double p2 = distPtr[3]; double k3 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 5 ? distPtr[4] : 0.; double k4 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 8 ? distPtr[5] : 0.; double k5 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 8 ? distPtr[6] : 0.; double k6 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 8 ? distPtr[7] : 0.; double s1 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 12 ? distPtr[8] : 0.; double s2 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 12 ? distPtr[9] : 0.; double s3 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 12 ? distPtr[10] : 0.; double s4 = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 12 ? distPtr[11] : 0.; double tauX = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 14 ? distPtr[12] : 0.; double tauY = distCoeffs.cols + distCoeffs.rows - 1 &gt;= 14 ? distPtr[13] : 0.; //tauX,tauY这个是什么梯形畸变，用不到的话matTilt为单位阵 // Matrix for trapezoidal distortion of tilted image sensor cv::Matx33d matTilt = cv::Matx33d::eye(); cv::detail::computeTiltProjectionMatrix(tauX, tauY, &amp;matTilt); for( int i = 0; i &lt; size.height; i++ ) &#123; float* m1f = map1.ptr&lt;float&gt;(i); float* m2f = map2.empty() ? 0 : map2.ptr&lt;float&gt;(i); short* m1 = (short*)m1f; ushort* m2 = (ushort*)m2f; //利用逆矩阵iR将二维图像坐标(j,i)转换到摄像机坐标系(_x,_y,_w) double _x = i*ir[1] + ir[2], _y = i*ir[4] + ir[5], _w = i*ir[7] + ir[8]; for( int j = 0; j &lt; size.width; j++, _x += ir[0], _y += ir[3], _w += ir[6] ) &#123; //摄像机坐标系归一化，令Z=1平面 double w = 1./_w, x = _x*w, y = _y*w; //这一部分请看OpenCV官方文档，畸变模型部分 double x2 = x*x, y2 = y*y; double r2 = x2 + y2, _2xy = 2*x*y; double kr = (1 + ((k3*r2 + k2)*r2 + k1)*r2)/(1 + ((k6*r2 + k5)*r2 + k4)*r2); double xd = (x*kr + p1*_2xy + p2*(r2 + 2*x2) + s1*r2+s2*r2*r2); double yd = (y*kr + p1*(r2 + 2*y2) + p2*_2xy + s3*r2+s4*r2*r2); //根据求取的xd,yd将三维坐标重投影到二维畸变图像坐标(u,v) cv::Vec3d vecTilt = matTilt*cv::Vec3d(xd, yd, 1); double invProj = vecTilt(2) ? 1./vecTilt(2) : 1; double u = fx*invProj*vecTilt(0) + u0; double v = fy*invProj*vecTilt(1) + v0; //保存u,v的值到Mapx,Mapy中 if( m1type == CV_16SC2 ) &#123; int iu = saturate_cast&lt;int&gt;(u*INTER_TAB_SIZE); int iv = saturate_cast&lt;int&gt;(v*INTER_TAB_SIZE); m1[j*2] = (short)(iu &gt;&gt; INTER_BITS); m1[j*2+1] = (short)(iv &gt;&gt; INTER_BITS); m2[j] = (ushort)((iv &amp; (INTER_TAB_SIZE-1))*INTER_TAB_SIZE + (iu &amp; (INTER_TAB_SIZE-1))); &#125; else if( m1type == CV_32FC1 ) &#123; m1f[j] = (float)u; m2f[j] = (float)v; &#125; else &#123; m1f[j*2] = (float)u; m1f[j*2+1] = (float)v; &#125; &#125; &#125;&#125; 希望对需要的人能有所帮助，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>OPENCV</category>
      </categories>
      <tags>
        <tag>OPENCV2</tag>
        <tag>OPENCV3</tag>
        <tag>畸变校正</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（递归）：valid-palindrome]]></title>
    <url>%2F2018%2F01%2F26%2FRecursive%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama”is a palindrome.“race a car”is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 解题思路额，判断字符串是否为回文，这道题貌似没什么好说的，需要注意的是空字符串也算回文哦。 从两边开始遍历字符串，如果遇到非数字字符的就跳过，然后比较当前两个字符是否相等；相等就进入下一个循环，否则返回false。 C++版代码实现循环12345678910111213141516class Solution &#123;public: bool isPalindrome(string s) &#123; if(s.size() == 0) return true; for(int i = 0, j = s.size() - 1; i &lt; j; ++i, --j)&#123; while(i &lt; j &amp;&amp; !isalnum(s[i])) i++; while(i &lt; j &amp;&amp; !isalnum(s[j])) j--; if(i &lt; j &amp;&amp; tolower(s[i]) != tolower(s[j])) return false; &#125; return true; &#125;&#125;; 递归1234567891011121314151617181920class Solution &#123;public: bool isPalindromeCore(string &amp;s, int start, int end)&#123; if(start &gt;= end) return true; while(start &lt; end &amp;&amp; !isalnum(s[start])) start++; while(start &lt; end &amp;&amp; !isalnum(s[end])) end--; if(start &lt; end &amp;&amp; tolower(s[start]) != tolower(s[end])) return false; return isPalindromeCore(s, ++start, --end); &#125; bool isPalindrome(string s) &#123; if(s.size() == 0) return true; return isPalindromeCore(s, 0, s.size()); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（贪心）：minimum-window-substring]]></title>
    <url>%2F2018%2F01%2F26%2FGreedy3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S =”ADOBECODEBANC”T =”ABC” Minimum window is”BANC”. Note:If there is no such window in S that covers all characters in T, return the emtpy string””. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 解题思路这道题被自己的无知给坑了，在java里面传人substring的两个参数分别是截取字符串起始位置和截止位置，在本题中应该写成substring(head, head+d);在C++里面传人substr的两个参数分别是截取字符串起始位置和截取字符串长度，在本题中应该写成substr(head, d)。 这道题的思路是： begin开始指向0， end一直后移，直到begin - end区间包含T中所有字符。记录窗口长度d 然后begin开始后移移除元素，直到移除的字符是T中的字符则停止，此时T中有一个字符没被包含在窗口，继续后移end，直到T中的所有字符被包含在窗口，重新记录最小的窗口d。 如此循环知道end到S中的最后一个字符。时间复杂度为O(n) 下面贴一下大神的模板，对于大多数子字符串问题，我们给了一个字符串，并且需要找到满足一些限制的子字符串。一般的方法是使用两个指针辅助的hashmap。模板如下。 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end &lt; s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; 有一点需要提到的是，当要求查找最大子字符串时，我们应该在内部while循环之后更新最大值，以保证子字符串是有效的。另一方面，当要求查找最小子字符串时，我们应该更新内部while循环内的最小值。 解决最多两个不同字符的最长子字符串的代码如下： 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end &lt; s.size())&#123; if(map[s[end++]]++ == 0) counter++; while(counter &gt; 2) if(map[s[begin++]]-- == 1) counter--; d = max(d, end - begin); &#125; return d; &#125; 解决最长子字符串不重复字符的代码如下： 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end &lt; s.size())&#123; if(map[s[end++]]++ &gt; 0) counter++; while(counter&gt;0) if(map[s[begin++]]-- &gt; 1) counter--; d=max(d, end - begin); //while valid, update d &#125; return d; &#125; C++版代码实现12345678910111213141516class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c: t) map[c]++; int counter = t.size(), begin = 0, end = 0, d = INT_MAX, head = 0; while(end &lt; s.size())&#123; if(map[s[end++]]-- &gt;0) counter--; //in t while(counter == 0)&#123; //valid if(end - begin &lt; d) d = end - (head = begin); if(map[s[begin++]]++ == 0) counter++; //make it invalid &#125; &#125; return d == INT_MAX? "":s.substr(head, d); &#125;&#125;; 参考链接：minimum-window-substring 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（贪心）：maximal-rectangle]]></title>
    <url>%2F2018%2F01%2F26%2FGreedy2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area. 给定一个用0和1填充的2D二进制矩阵，找到包含所有1的最大矩形并返回其面积。 解题思路刚看到这道题的时候，一脸无奈。我们还是先来看一下Largest Rectangle in Histogram这道题目吧。 Largest Rectangle in HistogramGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2,1,5,6,2,3],return 10. 我们先把代码贴出来，然后边看代码边捋清思路。 12345678910111213141516171819class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123; stack&lt;int&gt; s; height.push_back(0);//追加一个零用来做终止条件。 int maxSize = 0; int i = 0; while(i &lt; height.size())&#123; if(s.empty() || height[i] &gt;= height[s.top()]) s.push(i++); else&#123; int cur = height[s.top()]; s.pop(); maxSize = max(maxSize, cur * (s.empty() ? i : i - 1 - s.top())); &#125; &#125; return maxSize; &#125;&#125;; 首先，我们需要新建stack来保存遍历过程中的递增序列。如果栈是空的，那么索引i入栈。所以当i=0时，将0入栈。注意栈内保存的是索引，不是高度。然后i++。 当i=1的时候，发现height[i]小于了栈内的元素，于是出栈。这时候stack为空，所以面积的计算是height[t] * i。t是刚刚弹出的stack顶元素。也就是蓝色部分的面积。 这时候stack为空了，那就继续入栈。注意到只要是连续递增的序列，我们都要keep pushing，直到我们遇到了i=4，height[i]=2小于了栈顶的元素。 这时候开始计算矩形面积。首先弹出栈顶元素，t=3。即下图绿色部分。 接下来注意到栈顶的（索引指向的）元素还是大于当前i指向的元素，于是出栈，并继续计算面积，桃红色部分。 最后，栈顶的（索引指向的）元素大于了当前i指向的元素，循环继续，入栈并推动i前进。直到我们再次遇到下降的元素，也就是我们最后人为添加的dummy元素0. 同理，我们计算栈内的面积。由于当前i是最小元素，所以所有的栈内元素都要被弹出并参与面积计算。 注意我们在计算面积的时候已经更新过了maxSize 。 我们可以看到，stack中总是保持递增的元素的索引，然后当遇到较小的元素后，依次出栈并计算栈中bar能围成的面积，直到栈中元素小于当前元素。 maximal-rectangle这道题的解法灵感来自于Largest Rectangle in Histogram这道题，假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据Largest Rectangle in Histogram中的largestRectangleArea函数我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。算法时间复杂度为O(m*n)，这解法真是太棒了，其实应该算是动态规划的题目了。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123; stack&lt;int&gt; s; height.push_back(0);//追加一个零用来做终止条件。 int maxSize = 0; int i = 0; while(i &lt; height.size())&#123; if(s.empty() || height[i] &gt;= height[s.top()]) s.push(i++); else&#123; int cur = height[s.top()]; s.pop(); maxSize = max(maxSize, cur * (s.empty() ? i : i - 1 - s.top())); &#125; &#125; return maxSize; &#125;&#125;; int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty()) return 0; int maxRec = 0; vector&lt;int&gt; height(matrix[0].size(), 0); for(int i = 0; i &lt; matrix.size(); ++i)&#123; for(int j = 0; j &lt; matrix[0].size(); ++j)&#123; if(matrix[i][j] == '1')//这里的数字1一定要加单引号哦~ height[j]++; else height[j] = 0; &#125; maxRec = max(maxRec, largestRectangleArea(height));//对每一行都求一次最大值，而不是只有最后一行。 &#125; return maxRec; &#125;&#125;; 参考链接 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（贪心）：gas-station]]></title>
    <url>%2F2018%2F01%2F26%2FGreedy1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述There are N gas stations along a circular route, where the amount of gas at station i isgas[i]. You have a car with an unlimited gas tank and it costscost[i]of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note:The solution is guaranteed to be unique. 沿着一个圆形的路线有N个加油站，那里的加油站的天然气数量是gas [i]。 你有一辆带有无限制燃气罐的汽车，从车站i到下一站（i + 1）需要花费天然气。 你从一个加油站开始，开始时邮箱为空。 如果您可以在电路上巡回一次，则返回启动加油站的索引，否则返回-1。 注意：解决方案保证是唯一的。 解题思路从start出发，如果油量足够，可以一直向后走end++；油量不够的时候，start向后退，最终start == end的时候，如果有解一定是当前start所在位置。 因为是个环，所以我们将最后一个元素设置为起点，第一个元素设置为start下一点，这样可以用统一的判断条件start &lt; end来作为循环的条件，当start和end两者相等时，循环结束。 C++版代码实现12345678910111213141516171819202122class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; if(gas.size() &lt;= 0 || cost.size() &lt;= 0) return -1; int start = gas.size() - 1; int end = 0; int sum = gas[start] - cost[start]; while(start &gt; end)&#123; if(sum &gt;= 0)&#123; sum += gas[end] - cost[end]; ++end; &#125; else&#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：median-of-two-sorted-arrays]]></title>
    <url>%2F2018%2F01%2F22%2FLIST6%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 解题思路要求在O(log (m+n))时间内找到中位数，所以像那些合并之后再二分查找、或者一边比较一边合并到总量一半的方法肯定是不行的。 我们可以将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m+n)/2小的数。所以只要解决了第k小数的问题，原问题也得以解决。 首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。如果A[k/2-1] &lt; B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。 当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。) 通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件： 如果A或者B为空，则直接返回B[k-1]或者A[k-1]； 如果k为1，我们只需要返回A[0]和B[0]中的较小值； 如果A[k/2-1]=B[k/2-1]，返回其中一个； C++版代码实现1234567891011121314151617181920212223242526272829class Solution &#123;public: double findKth(int A[], int m, int B[], int n, int k)&#123; if(m &gt; n) return findKth(B, n, A, m, k); //始终保持元素较少的数组位于前面的位置 if(m == 0) return B[k-1]; //如果位于前面的数组为空，则直接返回后面数组的第k-1个元素 if(k == 1) return min(A[0], B[0]); //如果k等于1，则返回两个数组头元素的最小值 int pa = min(k / 2, m), pb = k - pa; if(A[pa-1] &lt; B[pb-1]) return findKth(A + pa, m - pa, B, n, k - pa); else if(A[pa - 1] &gt; B[pb - 1]) return findKth(A, m, B + pb, n - pb, k - pb); else return A[pa-1]; &#125; double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int total = m + n; if(total &amp; 0x1) return findKth(A, m, B, n, total / 2 + 1); else return (findKth(A, m, B, n, total/2) + findKth(A, m, B, n, total / 2 + 1)) / 2; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：reverse-nodes-in-k-group]]></title>
    <url>%2F2018%2F01%2F22%2FLIST1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example,Given this linked list:1-&gt;2-&gt;3-&gt;4-&gt;5； For k = 2, you should return:2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return:3-&gt;2-&gt;1-&gt;4-&gt;5 解题思路解法有两种，一种是申请额外空间来依次对k个元素进行排序，时间复杂度O(n)，空间复杂度O(k)。另一种是在原链表中进行反转，不需要额外空间，所以算法复杂度为O(n)，空间复杂度为O(1)。 本文中对第二种解法进行详细的讲解。 首先，单个链表的反转我想大家肯定都会，那就是遍历链表，每遇见一个结点就扔到第一位。因为涉及到第一个结点的操作，所以我们一定要有指向第一个结点的指针，这里在传参的时候需要注意。 接下来，我们采用整除来每次提取k个结点。需要注意的同样是参数的传递，怎么对接自己得把握好。就拿例题中的题目（list:1-&gt;2-&gt;3-&gt;4-&gt;5；k=3）来说，我的代码传入reverseList的参数应该是指向1的上一个结点的指针和指向4的指针。 最后，贴代码呗。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *reverseList(ListNode *slow, ListNode *fast)&#123; ListNode *last = slow-&gt;next; ListNode *cur = last-&gt;next; while(cur != fast)&#123; last-&gt;next = cur-&gt;next; cur-&gt;next = slow-&gt;next; slow-&gt;next = cur; cur = last-&gt;next; &#125; return last; &#125; ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head == NULL || k == 1) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *slow = dummy; ListNode *fast = head; int i = 0; while(fast != NULL)&#123; i++; if(i % k == 0)&#123; slow = reverseList(slow, fast-&gt;next); fast = slow-&gt;next; &#125; else fast = fast-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：add-two-numbers]]></title>
    <url>%2F2018%2F01%2F22%2FLIST5%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 解题思路两个链表求和，需要考虑进位问题。 首先新建链表，用于存储求和之后的结点；循环的终止条件是，直到l1或l2都为空且进位标志位为0；循环内，每次都进行求和运算和更新head的值。 在求carry的时候我们采用判断而不是除法，这一点大家需要注意，并且在以后的程序设计中也要尽量较少乘除法这种比较耗时的运算操作。 C++版代码实现12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL || l2 == NULL) return (l1 == NULL) ? l2 : l1; int carry = 0; //进位 int sum; //求和 ListNode *dummy = new ListNode (0); //新建链表 ListNode *head = dummy; while(l1 || l2 || carry)&#123; sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry; ListNode *cur = new ListNode(sum % 10); carry = (sum &gt;= 10) ? 1 : 0; head-&gt;next = cur; head = cur; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：swap-nodes-in-pairs]]></title>
    <url>%2F2018%2F01%2F22%2FLIST2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list, swap every two adjacent nodes and return its head. For example,Given1-&gt;2-&gt;3-&gt;4, you should return the list as2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解题思路通过这么多次的编程练习，链表的顺序交换我相信大家早已轻车熟路。本题中，我们先写一个交换相邻结点的函数swap，此函数交换输入的两个相邻链表结点之后，返回新的第一结点。然后我们开始考虑主函数，同样的新建一个指向头结点的指针（只要头结点有可能被替换，我们既需要这么做），然后遍历整个链表调用交换函数swap即可。 C++版代码实现123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *swap(ListNode *slow, ListNode *fast)&#123; slow-&gt;next = fast-&gt;next; fast-&gt;next = slow; return fast; &#125; ListNode *swapPairs(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *cur = dummy; for(;cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL; cur = cur-&gt;next-&gt;next) cur-&gt;next = swap(cur-&gt;next, cur-&gt;next-&gt;next); return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：merge-k-sorted-lists]]></title>
    <url>%2F2018%2F01%2F22%2FLIST3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解题思路之前做过一道题是对两个排序链表进行合并，这次是k个。所以，需要在原来的基础长做一些封装。 按照归并排序的思想，我们通过二分法得到中点进行递归，自下而上进行两两归并，直到只剩最后一个链表。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.size() == 0) return NULL; return mergeList(lists, 0, lists.size()-1); &#125; ListNode *mergeList(vector&lt;ListNode *&gt; &amp;lists, int low, int high)&#123; if(high &lt;= low) return lists[low]; int mid = (low + high) / 2; ListNode *left = mergeList(lists, low, mid); ListNode *right = mergeList(lists, mid+1, high); return merge(left, right); &#125; ListNode *merge(ListNode *left, ListNode *right) &#123; if(left == NULL) return right; if(right == NULL) return left; ListNode *dummy = new ListNode(0); ListNode *cur = dummy; while(left != NULL &amp;&amp; right != NULL)&#123; if(left-&gt;val &lt; right-&gt;val)&#123; cur-&gt;next = left; left = left-&gt;next; &#125; else&#123; cur-&gt;next = right; right = right-&gt;next; &#125; cur = cur-&gt;next; &#125; cur-&gt;next = left ? left : right; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：remove-nth-node-from-end-of-list]]></title>
    <url>%2F2018%2F01%2F22%2FLIST4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list, remove the n th node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 解题思路删除倒数第n个结点，我们就需要找到倒数第n个结点。于是，我们可以利用快慢指针来实现。 首先，fast走n步指向第n个结点；接着，fast和slow一起走，直到fast指向尾结点；最后，删除元素（这里需要注意的是加入pre来判断删除元素是否为头结点）。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if(head == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; ListNode *pre = NULL; //fast先走n步，到达第n个结点 while(--n) fast = fast-&gt;next; //fast和slow一起走，直到fast走到链表尾部 while(fast-&gt;next != NULL)&#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next; &#125; //此处用于判断删除的结点是否为头结点 if(pre != NULL) pre-&gt;next = slow-&gt;next; else head = head-&gt;next; return head; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list]]></title>
    <url>%2F2018%2F01%2F17%2FLIST1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given1-&gt;1-&gt;2, return1-&gt;2.Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3. 解题思路简单问题不要想的太复杂，直接嵌套循环搞定喽。外循环用来遍历链表，内循环用来遍历重复元素，如果重复就一直传递指针。 C++版代码实现1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL) return NULL; ListNode *dummy = head; while(dummy != NULL)&#123; while(dummy-&gt;next != NULL &amp;&amp; dummy-&gt;val == dummy-&gt;next-&gt;val)&#123; dummy-&gt;next = dummy-&gt;next-&gt;next; &#125; dummy = dummy-&gt;next; &#125; return head; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：merge-two-sorted-lists]]></title>
    <url>%2F2018%2F01%2F17%2FLIST3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 解题思路这道题剑指offer上应该也是有的，我就不去翻了。既然已经排序了，事情就变得简单多了，自下而上的归并排序的最后一步嘛~我们还是申请个新的结点，然后直接遍历两个链表元素比大小就好。 需要注意的是循环的终止条件，循环结束后还要把剩下的链表追加到cur的屁股后面哦。 C++版代码实现123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; ListNode *dummy = new ListNode(0); ListNode *cur = dummy; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; cur-&gt;next = l1 ? l1 : l2; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：rotate-list]]></title>
    <url>%2F2018%2F01%2F17%2FLIST4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a list, rotate the list to the right by k places, where k is non-negative. For example:Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLand k =2,return4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 解题思路 遍历链表得到链表长度并定位fast到尾结点； 根据链表长度，slow找到新的尾结点，slow的下一个结点便是新的头结点因为k可能比len大，所以需要取余数； 原先的尾结点与原先的头节点相连，dummy的next指针更新指向新的头结点，同时断开新的尾节点与新的头结点之间的联系。 C++版代码实现1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *rotateRight(ListNode *head, int k) &#123; if(k == 0 || head == NULL || head-&gt;next == NULL) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *fast = head; ListNode *slow = head; int len; //计算链表长度，同时fast指向尾结点 for(len = 1; fast-&gt;next != NULL; ++len) fast = fast-&gt;next; //根据得到的链表长度，找到需要切开的结点 for(int i = 1; i &lt; len - k % len; ++i) slow = slow-&gt;next; fast-&gt;next = dummy-&gt;next; //尾结点连接到头节点，形成环状链表 dummy-&gt;next = slow-&gt;next; //fast的下一个结点作为新的头结点 slow-&gt;next = NULL; //slow结点和新的头结点断开 return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list-ii]]></title>
    <url>%2F2018%2F01%2F17%2FLIST2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return1-&gt;2-&gt;5.Given1-&gt;1-&gt;1-&gt;2-&gt;3, return2-&gt;3. 解题思路因为第一个元素就有可能是重复节点，所以我们需要新建一个头节点指针，这一点在之前的几道题都有提到过。然后设置快慢指针，fast从head开始遍历，slow总是比fast慢一步；如果fast当前元素和它的下一个元素不相等，则更新slow、fast；否则，遍历重复元素，直到fast落到最后一个重复元素上，然后更新slow（跳过重复节点，直接指向fast的下一个节点）、fast。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *fast = head; ListNode *slow = dummy; while(fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; if(fast-&gt;next-&gt;val != fast-&gt;val) //更新slow slow = fast; else&#123; //遍历重复的元素，fast落到重复元素的最后一个元素上。 while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;val == fast-&gt;val) fast = fast-&gt;next; //删掉slow和fast之间的元素 slow-&gt;next = fast-&gt;next; &#125; //更新fast fast = fast-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：convert-sorted-list-to-binary-search-tree]]></title>
    <url>%2F2018%2F01%2F16%2FLIST2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 解题思路升序链表转换成高度平衡的二叉搜索树，我们只需要找到链表的中点当作root然后左右递归就可以了。求链表中点当然还是用快慢指针了。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; return toBST(head, NULL); &#125; TreeNode *toBST(ListNode *head, ListNode *tail)&#123; if(head == tail) return NULL; ListNode *fast = head; ListNode *slow = head; while(fast != tail &amp;&amp; fast-&gt;next != tail)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode(slow-&gt;val); root-&gt;left = toBST(head, slow); root-&gt;right = toBST(slow-&gt;next, tail); return root; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：copy-list-with-random-pointer]]></title>
    <url>%2F2018%2F01%2F16%2FLIST1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解题思路我们可以将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。 大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。 我们这里采用三步走战略，也是剑指offer上推崇的方法： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。 有图思路更清晰： 这道题，我就不照搬之前的博客了，直接贴一种更简洁的代码。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *copy, *p; if(head == NULL) return NULL; //复制链表 for(p = head; p; p = p-&gt;next)&#123; copy = new RandomListNode(p-&gt;label); copy-&gt;next = p-&gt;next; p = p-&gt;next = copy; &#125; //复制random for(p = head; p; p = copy-&gt;next)&#123; copy = p-&gt;next; copy-&gt;random = (p-&gt;random ? p-&gt;random-&gt;next:NULL); &#125; //split链表 for(p = head, head = copy = p-&gt;next; p;)&#123; p = p-&gt;next = copy-&gt;next; copy = copy-&gt;next = (p ? p-&gt;next:NULL); &#125; return head; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：partition-list]]></title>
    <url>%2F2018%2F01%2F16%2FLIST4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example,Given1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2and x = 3,return1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 解题思路牛客网上面的答案都是新建两个链表，小于x的放到一个链表里面，不小于的放到另一个链表里面，这种答案感觉好没劲哦。所以最后我采用的是O(n)时间复杂度，O(1)空间复杂度的解法。 具体说来，还是用快慢指针遍历链表，slow指向连续小于x的最后一个元素，fast指向当前元素不小于x但是下个元素小于x的元素。理解清楚这两个指针的对应关系之后，我们很容易将fast指向的元素的下一个元素追加到slow之后，同时更新slow和fast的指。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *partition(ListNode *head, int x) &#123; if(head == NULL) return NULL; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *fast = dummy; ListNode *slow = dummy; while(fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; if(fast-&gt;next-&gt;val &gt;= x) fast = fast-&gt;next; else&#123; if(fast == slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; else&#123; ListNode *tmp = fast-&gt;next; fast-&gt;next = tmp-&gt;next; tmp-&gt;next = slow-&gt;next; slow-&gt;next = tmp; slow = slow-&gt;next; &#125; &#125; &#125; return dummy-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：reverse-linked-list-ii]]></title>
    <url>%2F2018%2F01%2F16%2FLIST3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 解题思路可能是因为反转链表i太简单了，所以牛客网只有ii么，应该是这样的，哈哈哈。 头指针是必不可少的，因为有可能会要求全部反转。首先定位到需要反转的第一个元素，然后每次都将它后面的元素往它前面放。他们之间的关系大家最好自己画图捋一遍，这样记得比较清楚。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *reverseBetween(ListNode *head, int m, int n) &#123; if(head == NULL) return NULL; int diff = n - m; ListNode *preHead = new ListNode(0); preHead-&gt;next = head; ListNode *preCur = preHead; ListNode *cur = head; for(int i = 1; i &lt; m; ++i)&#123; preCur = cur; cur = cur-&gt;next; &#125; for(int i = 0; i &lt; diff; ++i)&#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; tmp-&gt;next = preCur-&gt;next; preCur-&gt;next = tmp; &#125; return preHead-&gt;next; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：linked-list-cycle-ii]]></title>
    <url>%2F2018%2F01%2F15%2FLIST4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list, return the node where the cycle begins. If there is no cycle, returnnull. Follow up:Can you solve it without using extra space? 解题思路 同linked-list-cycle-i一题，使用快慢指针方法，判定是否存在环，并记录两指针相遇位置(Z)； 有环的情况下， 求链表的入环节点：遍历链表，把每个元素指向下个链表的指针赋值为NULL，则循环要么在链表结尾停止，要么在环状链表入口处停止。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: //判断是否为环状链表 bool hasCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return false; ListNode *fast = head; ListNode *slow = head; while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow-&gt;val == fast-&gt;val) return true; &#125; return false; &#125; //检测函数 ListNode *detectCycle(ListNode *head) &#123; if(hasCycle(head)) &#123; ListNode *temp = NULL; while(head -&gt;next) &#123; temp = head -&gt;next; head -&gt;next = NULL; head = temp; &#125; return head; &#125; else return NULL; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：sort-list]]></title>
    <url>%2F2018%2F01%2F15%2FLIST1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Sort a linked list in O(n log n) time using constant space complexity. 解题思路因为题目要求复杂度为O(nlogn),故可以考虑归并排序的思想。 前一段时间刚刚总结了八大排序，感兴趣的同学们可以由此穿越：数据结构与算法系列之一：八大排序之归并排序。 递归版归并排序的一般步骤为： 将待排序数组（链表）取中点并一分为二； 递归地对左半部分进行归并排序； 递归地对右半部分进行归并排序； 将两个半部分进行合并（merge）,得到结果。 所以对应此题目，可以划分为三个小问题： 找到链表中点 （快慢指针思路，快指针一次走两步，慢指针一次走一步，快指针在链表末尾时，慢指针恰好在链表中点）； 写出merge函数，即如何合并链表。 写出mergesort函数，实现上述步骤。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: //快慢指针获取链表中点 ListNode *getMiddle(ListNode *head)&#123; ListNode *fast = head; ListNode *slow = head; while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; //合并链表 ListNode *mergeList(ListNode *left, ListNode *right)&#123; if(left == NULL) return right; if(right == NULL) return left; ListNode *tmp = new ListNode(0); ListNode *head = tmp; while(left != NULL &amp;&amp; right != NULL)&#123; if(left-&gt;val &gt; right-&gt;val)&#123; head-&gt;next = right; right = right-&gt;next; &#125; else&#123; head-&gt;next = left; left = left-&gt;next; &#125; head = head-&gt;next; &#125; if(left == NULL) head-&gt;next = right; if(right == NULL) head-&gt;next = left; return tmp-&gt;next; &#125; //排序函数 ListNode *sortList(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *middle = getMiddle(head); ListNode *right = sortList(middle-&gt;next); middle-&gt;next = NULL; //左链表的结尾不能再指向右链表的开头 ListNode *left = sortList(head); return mergeList(left, right); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：reorder-list]]></title>
    <url>%2F2018%2F01%2F15%2FLIST2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a singly linked list L: L 0→L 1→…→L n-1→L n,reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→… You must do this in-place without altering the nodes’ values. For example,Given{1,2,3,4}, reorder it to{1,4,2,3}. 解题思路要求in-place，所以不能使用辅助空间。可以采用快慢指针先找到中间点，将原列表分成两个部分，然后再将后半部分反转链表，最后再根据题目规则一前一后合并成一个链表。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getMiddle(ListNode *head)&#123; ListNode *fast = head; ListNode *slow = head; while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; ListNode *reverseList(ListNode *head)&#123; ListNode *pReversedHead = NULL; ListNode *pNode = head; ListNode *pPrev = NULL; while(pNode != NULL)&#123; ListNode *pNext = pNode-&gt;next; if(pNext == NULL) pReversedHead = pNode; pNode-&gt;next = pPrev; pPrev = pNode; pNode = pNext; &#125; return pReversedHead; &#125; void mergeList(ListNode *left, ListNode *right)&#123; while(left != NULL &amp;&amp; right != NULL)&#123; ListNode *curLeft = left-&gt;next; ListNode *curRight = right-&gt;next; left-&gt;next = right; right-&gt;next = curLeft; left = curLeft; right = curRight; &#125; &#125; void reorderList(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return ; ListNode *middle = getMiddle(head); ListNode *right = reverseList(middle-&gt;next); middle-&gt;next = NULL; ListNode *left = head; mergeList(left, right); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记（链表）：linked-list-cycle]]></title>
    <url>%2F2018%2F01%2F15%2FLIST3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/LeetCode 刷题平台：https://www.nowcoder.com/ta/leetcode 题&emsp;&emsp;库：Leetcode经典编程题 编&emsp;&emsp;者：WordZzzz [toc] 题目描述Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 解题思路又双叒叕是快慢指针，话不多说，上代码。 C++版代码实现123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return false; ListNode *fast = head; ListNode *slow = head; while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow-&gt;val == fast-&gt;val) return true; &#125; return false; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的个人博客之旅：从jekyll到hexo]]></title>
    <url>%2F2018%2F01%2F10%2FHEXO%2F</url>
    <content type="text"><![CDATA[[toc] 前言&emsp;&emsp;喜欢写Blog的人，会经历三个阶段。 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 引自阮一峰 &emsp;&emsp;第一阶段我已经经历过了，目前在CSDN的文章仍然在更新。但是作为一个免费空间，一个技术博客的聚集地，其管理和运营虽说正在变得越来越好，但是恶心人的事件也时有发生，比如对新手不友好的审核机制、近期改版造成的各种不兼容问题。 &emsp;&emsp;于是，就想着挣脱枷锁，向第二第三阶段发展。 &emsp;&emsp;我这人吧凡事都考虑的比较详尽，，我感觉我如果再去经历第二阶段的话既浪费精力又消耗时间，而且自己也过了玩网站、玩博客的年纪，如果申请个域名再搞个网站，我不知道这股热度会持续多久。 &emsp;&emsp;所以，我就直接跳到了第三个阶段，开始在github上搭建自己的博客。由于自己对前端一无所知，即使使用现成的博客框架，刚开始玩的时候特别费劲。但是经过不断摸索，我的博客已经基本成型，传送门开启：wordzzzz的个人博客-托管于github wordzzzz的个人博客-托管于gitee。 &emsp;&emsp;本篇博文并不打算长篇大论的介绍基于GitHub Pages或者Gitee Pages搭建博客的步骤，因为这类的文章实在是太多了，青菜萝卜又各有所爱，不如给出资源，让大家自己折腾。所以我只是在此有序贴出我在搭建博客的过程中用到的各种有用资源，以及搭建博客的大致流程，也算是对我这段时间的一个告别仪式吧。 GitHub Pages&emsp;&emsp;我想在GitHub Pages推出之前，由于技术门槛的存在，第三个阶段应该会很少有人涉足。所以在开始一切之前，我们先来看看什么是GitHub Pages。 &emsp;&emsp;Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。 &emsp;&emsp;网站首页就是搭建GitHub Pages的过程其中第一步之后，选择不同的git客户端选项，会出现相应的初始化步骤，很人性化。 &emsp;&emsp;大家可以跟着上面的链接先在自己的github新建仓库，仓库名称为username.github.io，其中username要替换成你github的名称，比如我的github名称为wordzzzz，所以我新建的仓库就应该是wordzzzz.github.io。那么等我以后搭建好了我的博客，我就可以通过https://wordzzzz.github.io来访问我的主页了。 &emsp;&emsp;到现在为止，只是搭建博客的准备工作。搭建博客的下一步是选择合适的静态博客框架。 jekyll or hexo&emsp;&emsp;目前有两大静态博客主流框架：jekyll和hexo。 &emsp;&emsp;我一开始用的是jekyll，这是中文社区翻译出来的中文开发文档。我使用的主题是Minimal Mistakes，开发文档很详细。但是后来由于jekyll体验不是很好（中文资料少，我英语比较差我会说嘛），依赖环境总是出问题（需要安装ruby），markdown采用的是Kramdown（Kramdown对我之前的一些博客格式支持的不是很好，我自己写文档用的都是小书匠，然后发表到CSDN，所以并不想花时间在改格式上面），而且我使用的这个主题是个人维护的，种种原因导致最后做出来的博客很难符合我的胃口，最后被我扔进了停尸房jekyll_mysite。 &emsp;&emsp;就在我将要放弃之时，hexo拯救了我。对，没错，它有中文开发文档。而在hexo界，使用最多的主题就是next了。光是看到这两份资料，我就已经激动的不行了，这种扁平化设计的网站，不就正是我需要的么。加上详尽的开发文档和丰富的第三方接口，让我对它爱不释手。最终定稿了自己的个人博客，存储在githubwordzzzz的个人博客-托管于github和giteewordzzzz的个人博客-托管于gitee上。 next主题&emsp;&emsp;next主题支持三种外观显示，支持多国语言，5套代码高亮主题，可以深度定制。在其Github上，更是有三个主题的代表作，其中我最喜欢的莫过于基于Muse scheme的wanghao的博客。于是，我就在wanghao的博客的基础上进行了相应的更改，形成了我现在的博客，主题文件全部在我的github上，欢迎大家fork、star、follow。 &emsp;&emsp;其实先按照hexo配置开发环境，再按照next文档配置站点文件，完全可以轻松搭建起自己的博客。但是还是藏不住内心那颗年轻的心啊，终究还是搜罗了一些好玩的东西放到了自己的博客上，比如音乐播放器。 &emsp;&emsp;下面我先简单介绍一下基于github平台、hexo框架的next主题博客开发步骤： Github上新建username.github.io仓库并初始化 PC端安装hexo及其依赖项并熟悉开发流程 下载我的主题文件或者下载next主题文件 按照next官方教程验证主题 按照next官方教程配置站点文件和主题文件 按照next官方教程集成第三方服务 生成静态文件 开启本地服务查看站点效果 部署至Github &emsp;&emsp;文档都非常详细，下面我主要就第三方服务做一些说明。我提到的大部分三方服务在next的官方文档都提及到了，所以具体配置大家跟着官方文档走就行，我只是为每一类服务选择哪个做一下建议。 评论系统&emsp;&emsp;我用的韩国的livere，从国内到国外，支持几乎全部社交账号登陆，具体步骤请按照next的官方文档操作。 数据统计与分析&emsp;&emsp;百度统计和google分析我都加上了，具体步骤请按照next的官方文档操作。 阅读量统计&emsp;&emsp;我用的LeanCloud，具体操作步骤请直接跳转至 为NexT主题添加文章阅读量统计功能。 内容分享服务&emsp;&emsp;我采用的是need-more-share2，直接在主题配置文件里面打开就行。 搜索服务&emsp;&emsp;我采用的是Swiftype，具体步骤请按照next的官方文档操作。 网站收录&emsp;&emsp;Google Webmaster tools收录特别快，具体步骤请按照next的官方文档操作。但是百度站长收录的就很慢了，我的到现在还没被收录。 其他服务&emsp;&emsp;NexT 借助于 MathJax 来显示数学公式，此选项默认关闭，如果博客中有公式，那么一定要打开这个选项。 next进阶&emsp;&emsp;最后想说一下其他一些配置，比如添加背景图片、侧边栏头像旋转、侧边栏鼠标滑入显示、背景音乐等等，此处大部分参考这个博客。 &emsp;&emsp;next人性化的为用户提供了custom接口，我们可以在不影响主题文件的基础上进行个性化定制。 给页面添加背景图片&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1234567891011body &#123; background: url(/images/blogbk.jpg) no-repeat; /* 背景图垂直、水平均居中 */ background-position: center center; /* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */ background-attachment: fixed; /* 让背景图基于容器大小伸缩 */ background-size: cover; /* 设置背景颜色，背景图加载过程中会显示背景色 */ background-color: rgba(0, 0, 0, 0.5);&#125; &emsp;&emsp;其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。 给侧边栏添加背景图片&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 1234567#sidebar &#123; background:url(/images/sidebar.jpg); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: rgba(255, 255, 255, 1);&#125;&#125; 文字背景色以及半透明的设置&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 12345.content &#123; border-radius: 20px; padding: 30px 60px 30px 60px; background:rgba(255, 255, 255, 0.8) none repeat scroll !important; &#125; &emsp;&emsp;其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。 评论(来必力)添加背景色&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 12345#lv-container &#123; border-radius: 20px; padding: 30px 60px 30px 60px; background:rgba(255, 255, 255, 0.8) none repeat scroll !important; &#125; &emsp;&emsp;和上面一样，背景色和圆角可自己调整更改。 实现点击出现桃心效果&emsp;&emsp;在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js &emsp;&emsp;然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 侧边栏头像旋转&emsp;&emsp;打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 设置鼠标划入侧边栏才显示站点信息：设置自定义div&emsp;&emsp;在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置： 1&lt;nav class="site-state motion-element"&gt; &emsp;&emsp;在其上添加以下代码： 123456789101112&lt;!--my custom code begin--&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $("#sidebar").hover(function()&#123; $("#mydivshow").velocity('stop').velocity(&#123;opacity: 1&#125;); &#125;,function()&#123; $("#mydivshow").velocity('stop').velocity(&#123;opacity: 0&#125;); &#125;);&lt;/script&gt;&lt;div id="mydivshow" class="mydivshow"&gt;&lt;!--my custom code end--&gt; &emsp;&emsp;然后找到代码行： 1234&lt;/section&gt;&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;&lt;!--noindex--&gt;&lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; &emsp;&emsp;在此的上方添加一个，如下所示： 12345678&lt;!--my custom code begin--&gt;&lt;/div&gt;&lt;!--my custom code end--&gt;&lt;/section&gt;&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;&lt;!--noindex--&gt; &lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; &lt;div class="post-toc"&gt; 自定义区域的初始化设置&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码： 1#mydivshow&#123;opacity: 0;&#125; 注：具体代码添加位置以及代码里的section.site-overview可以自己修改，和末尾的是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。 自定义音乐播放器&emsp;&emsp;描述：本站所用的音乐播放器是由DIYgod所制作的APlayer，其详细资料可参见这里。 安装APlayer插件1$ npm install aplayer --save &emsp;&emsp;安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。 生成音乐播放器&emsp;&emsp;在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。 &emsp;&emsp;打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码： 123456789101112131415161718192021&lt;div id="player1" class="aplayer"&gt;&lt;/div&gt;&lt;script src="/js/src/APlayer.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var ap = new APlayer(&#123; element: document.getElementById('player1'), // Optional, player element narrow: false, // Optional, narrow style autoplay: false, // Optional, autoplay song(s), not supported by mobile browsers showlrc: 0, // Optional, show lrc, can be 0, 1, 2, see: ###With lrc mutex: true, // Optional, pause other players when this player playing theme: '#e6d0b2', // Optional, theme color, default: #b7daff mode: 'random', // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` preload: 'metadata', // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' listmaxheight: '513px', // Optional, max height of play list music: &#123; // Required, music info, see: ###With playlist title: '你曾是少年', // Required, music title author: 'cover', // Required, music author url: 'http://mp3.qqmusic.cc/yq/102426570.mp3', // Required, music url pic: '/images/visitor.jpg', // Optional, music picture &#125;&#125;);&lt;/script&gt; &emsp;&emsp;这里的歌曲url必须是在线音乐，当时现在大部分播放器都不会曝露出真实的歌曲播放地址，找资源很是费劲。这里给大家推荐一个解析平台，大部分的qq音乐还是可以解析出来或者直接在该平台上找到播放链接的。大家可以写多个music结构，以此来添加多个音乐。 &emsp;&emsp;当然，我们还可以通过添加网易云音乐外链的方式在我们的博客中添加音乐。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码： 123&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=458789090&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;&lt;/div&gt; &emsp;&emsp;替换上述代码中的iframe标签之间的内容，就可以替换不同的音乐进行播放了。网易云音乐的歌单也可以生成外链，前提是歌单里的歌曲都有版权哦~ 自定义播放器样式&emsp;&emsp;包含颜色更改，列表歌曲信息的排版修改。 &emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码： 123456789101112131415.aplayer-list ol li:hover &#123; /*列表悬停颜色*/ background:rgba(255, 255, 255, 1) none repeat scroll !important;&#125;.aplayer-list ol li &#123; /*列表底色*/ background:rgba(255, 255, 255, 1);&#125;.aplayer-list-light &#123; /*列表播放歌曲颜色*/ background:rgba(255, 255, 255, 1) none repeat scroll !important;&#125;#player1 &#123; /*边框样式*/ border-radius: 6px; div,ol &#123;border-radius: 6px;&#125; &#125;#player1 *&#123;color: rgba(255, 255, 255, 1);&#125; /*字体颜色*//*列表歌曲信息的排版*/.aplayer-list-index&#123;float:left;&#125;.aplayer-list-title&#123;float:left;&#125;.aplayer-list-author&#123;float:right;&#125; 自定义萌萌哒音乐播放控制边栏&emsp;&emsp;这一步要在自定义音乐播放器的配置完成之后才能进行，因为aplayer-controler依赖于aplayer来实现播放功能。 安装aplayer-controler插件1npm install aplayer-controler --save 添加js代码&emsp;&emsp;安装APlayer-Controler的js文件：APlayer-Controler.js &emsp;&emsp;将其放入theme/next/source/js/src下。 创建按钮区域&emsp;&emsp;在theme/next/layout/_custom/文件夹下新建一个myapcontroler.swig的文件。向其中添加以下代码： 1234567891011121314151617181920212223242526&lt;script src="/js/src/Aplayer-Controler.js"&gt;&lt;/script&gt;&lt;div id="AP-controler"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var myapc=new APlayer_Controler(&#123; APC_dom:$('#AP-controler'), aplayer:ap, //此为绑定的aplayer对象 attach_right:true, position:&#123;top:'300px',bottom:''&#125;, fixed:true, btn_width:100, btn_height:120, img_src:['http://oty1v077k.bkt.clouddn.com/bukagirl.jpg', 'http://oty1v077k.bkt.clouddn.com/jumpgirl.jpg', 'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg', 'http://oty1v077k.bkt.clouddn.com/%E8%90%8C1.gif'], img_style:&#123;repeat:'no-repeat',position:'center',size:'contain'&#125;, ctrls_color:'rgba(173,255,47,0.8)', ctrls_hover_color:'rgba(255,140,0,0.7)', tips_on:true, tips_width:140, tips_height:25, tips_color:'rgba(255,255,255,0.6)', tips_content:&#123;&#125;, timeout:30 &#125;);&lt;/script&gt; 将控制按钮加入body页面&emsp;&emsp;在theme/next/layout文件夹下打开_layout.swig文件，在前添加以下代码： 1&#123;% include '_custom/myapcontroler.swig' %&#125; &emsp;&emsp;到此，自定义音乐播放控制边栏就基本完成，完成整个配置需要根据自己的主题背景进一步修改完善。 本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序综述]]></title>
    <url>%2F2018%2F01%2F09%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort 编&emsp;&emsp;者：WordZzzz [toc] 前言&emsp;&emsp;剑指offer刷完了，是时候总结一波数据结构与算法了。本系列文章暂定包括数据结构中树和图的各种操作，以及查找、排序等基本算法和动态规划等高级算法。本系列文章只是作为总结性的文献，为自己日后的面试做准备。 概述&emsp;&emsp;直接引自维基百科：排序算法。总结性强。 &emsp;&emsp;在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则： 输出结果为递增序列（递增是针对所需的排序顺序而言） 输出结果是原输入的一种排列、或是重组 &emsp;&emsp;虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表） 分类&emsp;&emsp;在计算机科学所使用的排序算法通常被分类为： 计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，坏的性能是O(n2)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。 内存使用量（以及其他电脑资源的使用） 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 依据排序的方法：插入、交换、选择、合并等等。 稳定性&emsp;&emsp;当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。 1(4, 1) (3, 1) (3, 7)（5, 6） &emsp;&emsp;在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有： 12(3, 1) (3, 7) (4, 1) (5, 6) （维持次序）(3, 7) (3, 1) (4, 1) (5, 6) （次序被改变） &emsp;&emsp;不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。实现的一个方式是人工扩充键值的比较（比如上面的比较中加入第二个标准：第二个键值的大小），从而在键值相同的两个对象之间进行比较时，使用在原先数据次序中的条目。然而，要记录这种次序通常牵涉到额外的空间负担。 排序算法列表&emsp;&emsp;在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。 稳定的排序 冒泡排序（bubble sort）— O(n2) 插入排序（insertion sort）— O(n2) 鸡尾酒排序（cocktail sort）— O(n2) 桶排序（bucket sort）— O(n)；需要O(k)额外空间 计数排序（counting sort）— O(n+k)；需要O(n+k)额外空间 归并排序（merge sort）— O(n log n)；需要O(n)额外空间 原地归并排序 — O(n log2 n)如果使用最佳的现在版本 二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间 鸽巢排序（pigeonhole sort）— O(n+k)；需要O(k)额外空间 基数排序（radix sort）— O(n·k)；需要O(n)额外空间 侏儒排序（gnome sort）— O(n2) 图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间 块排序（block sort）— O(n log n) 不稳定的排序 选择排序（selection sort）— O(n2) 希尔排序（shell sort）— O(n log2 n)如果使用最佳的现在版本 Clover排序算法（Clover sort）— O(n)期望时间，O(n2)最坏情况 梳排序 — O(n log n) 堆排序（heap sort）— O(n log n) 平滑排序（smooth sort）— O(n log n) 快速排序（quick sort）— O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序 内省排序（introsort）—O (n log n) 耐心排序（patience sort）— O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence） 不实用的排序 Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷 Stupid排序 — O(n3);递归版本需要O(n2)额外内存 珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件 煎饼排序 — O(n),但需要特别的硬件 臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间 ==概述到此结束，下面分八篇文章依次对典型的八种排序进行图文并茂的讲解和c++实现。== &emsp;&emsp;先贴一下八大排序的性能概括图： &emsp;&emsp;再贴出来以后要用到的main函数和头文件。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdexcept&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; #define M 5int main() &#123; int arr[] = &#123;2,4,6,8,9,7,5,3,1&#125;; int len = sizeof(arr) / sizeof(*arr);// double arr[] = &#123;4.5, 2.3,6.7, 3.5, 1.1&#125;;// const int len = sizeof(arr) / sizeof(arr[0]);// BubbleSort(arr, len);// BubbleSort1(arr, len);// BubbleSort2(arr, len);// BubbleSort3(arr, len);// InsertSort(arr, len);// ShellSort(arr, len); // QuickSort(arr, len);// QuickSortIteration(arr, len);// SelectSort(arr, len); // HeapSort(arr, len); // MergeSort(arr, len); MergeSortIteration(arr, len); for(auto v : arr)&#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; &emsp;&emsp;最后就要打开传送门了： csdn告诉我今天上传博客的次数到达上限了，然而我还有两个没有上传，那我只好先引流到我的个人博客了。 插入排序：（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 希尔排序：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。 选择排序：（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。 冒泡排序：（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。 快速排序：（小数，基准元素，大数）。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 归并排序：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。 基数排序：一种多关键字的排序算法，可用桶排序实现。 参考链接：维基百科数据结构与算法可视化可视化数据结构与算法排序算法可视化经典排序算法总结与实现]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之基数排序]]></title>
    <url>%2F2018%2F01%2F08%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 基数排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。 &emsp;&emsp;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。 步骤&emsp;&emsp;它是这样实现的： 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。 然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 &emsp;&emsp;基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 演示&emsp;&emsp;wordzzzz的小数据规模演示： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 获取数组a中最大值 */template&lt;typename T&gt;int get_max(T *array, const int length)&#123; int i, max; max = array[0]; for (i = 1; i &lt; length; i++) if (array[i] &gt; max) max = array[i]; return max;&#125;/* * 对数组按照"某个位数"进行排序(桶排序) */template&lt;typename T&gt;void count_sort(T *array, const int length, int exp)&#123; T* output = (T*)malloc(sizeof(T) * length); if (output == NULL) &#123; fputs("Error: out of memory\n", stderr); abort(); &#125; int i, buckets[10] = &#123; 0 &#125;; for (i = 0; i &lt; length; i++) // 将数据出现的次数存储在buckets[]中 buckets[(array[i] / exp) % 10]++; for (i = 1; i &lt; 10; i++) // 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。 buckets[i] += buckets[i - 1]; for (i = length - 1; i &gt;= 0; i--) // 将数据存储到临时数组output[]中，这里的对应关系一定要捋清楚 output[--buckets[(array[i] / exp) % 10]] = array[i]; for (i = 0; i &lt; length; i++) // 将排序好的数据赋值给array[] array[i] = output[i];&#125;/* * 基数排序 */template&lt;typename T&gt;void RadixSort(T *array, const int length)&#123; int exp; // 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；... int max = get_max(array, length); // 数组array中的最大值 for (exp = 1; max / exp &gt; 0; exp *= 10) // 从个位开始，对数组array按"指数"进行排序 count_sort(array, length, exp);&#125; 算法复杂度 数据结构 数组 平均时间复杂度 $O(d*(n+r))$ 最好情况 $O(d*(n+r))$ 最坏情况 $O(d*(n+r))$ 空间复杂度 $O(n+r)$ &emsp;&emsp;其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。 分析&emsp;&emsp;如果捋不清上述代码中的数组对应关系，可以参考一下下面这两张图的讲解，来源：http://www.cnblogs.com/skywang12345/p/3603669.html。 个位的数值范围是[0,10)。因此，参见桶数组buckets[]，将数组按照个位数值添加到桶中。 接着是根据桶数组buckets[]来进行排序。假设将排序后的数组存在output[]中；找出output[]和buckets[]之间的联系就可以对数据进行排序了。 &emsp;&emsp;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。 &emsp;&emsp;基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之归并排序]]></title>
    <url>%2F2018%2F01%2F07%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 归并排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 ${\displaystyle O(n\log n)}$ 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 步骤&emsp;&emsp;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 递归法（Bottom-up）原理如下（假设序列共有 ${\displaystyle n}$ 个元素）： 将序列每相邻两个数字进行归并操作，形成 ${\displaystyle ceil(n/2)}$ 个序列，排序后每个序列包含两/一个元素。 若此时序列数不是1个则将上述序列再次归并，形成 ${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素。 重复步骤2，直到所有元素排序完毕，即序列数为1。 迭代法（Top-down） 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。 设定两个指针，最初位置分别为两个已经排序序列的起始位置。 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。 重复步骤3直到某一指针到达序列尾。 将另一序列剩下的所有元素直接复制到合并序列尾。 演示&emsp;&emsp;wikipedia的大数据规模演示： &emsp;&emsp;wordzzzz的小数据规模演示： 代码递归版123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 归并排序递归版 */ template &lt;typename T&gt;void Merge(T *array, T *reg, int left, int mid, int right) &#123; int left1 = left, right1 = mid; int left2 = mid + 1, right2 = right; int k = left; while (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2) reg[k++] = array[left1] &lt; array[left2] ? array[left1++] : array[left2++]; while (left1 &lt;= right1) reg[k++] = array[left1++]; while (left2 &lt;= right2) reg[k++] = array[left2++]; for (k = left; k &lt;= right; k++) array[k] = reg[k];&#125;template &lt;typename T&gt; void MergeSortRecursive(T *array, T *reg, int left, int right) &#123; if (left &gt;= right) return; int mid = left + ((right - left) &gt;&gt; 1); MergeSortRecursive(array, reg, left, mid); //左序列排序 MergeSortRecursive(array, reg, mid + 1, right); //右序列排序 Merge(array, reg, left, mid, right); //合并左右序列&#125; template &lt;typename T&gt; void MergeSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; T* reg = (T*)malloc(sizeof(T) * length); if (reg == NULL) &#123; fputs("Error: out of memory\n", stderr); abort(); &#125; MergeSortRecursive(array, reg, 0, length - 1); delete[] reg;&#125; 迭代版123456789101112131415161718192021222324252627282930313233343536/** 归并排序迭代版*/template&lt;typename T&gt; void MergeSortIteration(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; T* regB = (T*)malloc(sizeof(T) * length); if (regB == NULL) &#123; fputs("Error: out of memory\n", stderr); abort(); &#125; for (int seg = 1; seg &lt; length; seg += seg) &#123; //步长，每次翻倍 for (int left = 0; left &lt; length; left += seg + seg) &#123; int low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);//因为可能会超出length int k = low; int left1 = low, right1 = mid; int left2 = mid, right2 = high; while (left1 &lt; right1 &amp;&amp; left2 &lt; right2) //这里的表达式没有等号，都是左闭右开区间 regB[k++] = array[left1] &lt; array[left2] ? array[left1++] : array[left2++]; while (left1 &lt; right1) regB[k++] = array[left1++]; while (left2 &lt; right2) regB[k++] = array[left2++]; &#125; for (int i = 0; i &lt; length; i++) //更新array array[i] = regB[i]; &#125; delete[] regB;&#125; 算法复杂度 数据结构 数组 最坏时间复杂度 ${\displaystyle O(n\log n)}$ 最优时间复杂度 ${\displaystyle O(n)}$ 平均时间复杂度 ${\displaystyle O(n\log n)}$ 空间复杂度 ${\displaystyle O(n)}$ &emsp;&emsp;比较操作的次数介于 ${\displaystyle (n\log n)/2}$ 和 ${\displaystyle n\log n-n+1}$ 。 赋值操作的次数是 ${\displaystyle (2n\log n)}$ 。归并算法的空间复杂度为： ${\displaystyle \Theta (n)}$。 分析&emsp;&emsp;对于归并排序有几点说明： 和快速排序一样，归并排序在小数组上面的表现不如插入排序。 辅助数组是一个共用的数组。如果在每个归并的过程中都申请一个临时数组会造成比较大的时间开销。 归并的过程需要将元素复制到辅助数组，再从辅助数组排序复制回原数组，会拖慢排序速度。 &emsp;&emsp;归并排序有以下几点优化方法： 和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用。（代码见下面的归并排序递归版优化） 在merge()调用之前，可以判断一下a[mid]是否小于等于a[mid+1]。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么a[mid]是第一个子数组的最大值，a[mid+1]是第二个子数组的最小值。当a[mid]&lt;=a[mid+1]时，数组整体有序。 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。（代码见下面的归并排序迭代版优化） 递归版优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 归并排序递归版合并函数 */ template &lt;typename T&gt;void Merge(T *array, T *reg, int left, int mid, int right) &#123; int left1 = left, right1 = mid; int left2 = mid + 1, right2 = right; int k = left; while (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2) reg[k++] = array[left1] &lt; array[left2] ? array[left1++] : array[left2++]; while (left1 &lt;= right1) reg[k++] = array[left1++]; while (left2 &lt;= right2) reg[k++] = array[left2++]; for (k = left; k &lt;= right; k++) array[k] = reg[k];&#125;/** 归并排序递归版递归函数优化*/template &lt;typename T&gt;void MergeSortRecursive1(T *array, T *reg, int left, int right) &#123; if (left &gt;= right) return; if (right - left &lt;= M) //序列长度小于阈值就采用插入排序 InsertSort(array, left, right); else&#123; int mid = left + ((right - left) &gt;&gt; 1); MergeSortRecursive1(array, reg, left, mid); //左序列排序 MergeSortRecursive1(array, reg, mid + 1, right); //右序列排序 Merge(array, reg, left, mid, right); //合并左右序列 &#125;&#125;template &lt;typename T&gt; void MergeSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; T* reg = (T*)malloc(sizeof(T) * length); if (reg == NULL) &#123; fputs("Error: out of memory\n", stderr); abort(); &#125; MergeSortRecursive1(array, reg, 0, length - 1); delete[] reg;&#125; 迭代版优化12345678910111213141516171819202122232425262728293031323334353637383940414243/** 归并排序迭代版优化*/template&lt;typename T&gt;void MergeSortIteration1(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; T* regA = array; T* regB = (T*)malloc(sizeof(T) * length); if (regB == NULL) &#123; fputs("Error: out of memory\n", stderr); abort(); &#125; for (int seg = 1; seg &lt; length; seg += seg) &#123; //步长，每次翻倍 for (int left = 0; left &lt; length; left += seg + seg) &#123; int low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);//因为可能会超出length int k = low; int left1 = low, right1 = mid; int left2 = mid, right2 = high; while (left1 &lt; right1 &amp;&amp; left2 &lt; right2) //这里的表达式没有等号，都是左闭右开区间 regB[k++] = regA[left1] &lt; regA[left2] ? regA[left1++] : regA[left2++]; while (left1 &lt; right1) regB[k++] = regA[left1++]; while (left2 &lt; right2) regB[k++] = regA[left2++]; &#125; T* temp = regA; //优化：交换辅助数组与原始数组的角色 regA = regB; regB = temp; &#125; if (regA != array) &#123; //如果regA != array，则说明现在regA是辅助数组 for (int i = 0; i &lt; length; i++) //所以需要拷贝数据到regB，也就是array。 regB[i] = regA[i]; regB = regA; //regB重新指向辅助数组 &#125; delete[] regB;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之快速排序]]></title>
    <url>%2F2018%2F01%2F06%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 快速排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 ${\displaystyle n}$ 个项目要 ${\displaystyle O(n\log n)}$ （大O符号）次比较。在最坏状况下则需要 ${\displaystyle O(n^{2})}$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 ${\displaystyle O(n\log n)}$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 步骤&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 &emsp;&emsp;步骤为： 从数列中挑出一个元素，称为”基准”（pivot）. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 &emsp;&emsp;wikipedia的大数据规模演示： &emsp;&emsp;wordzzzz的小数据规模演示： 代码&emsp;&emsp;先给出公用接口，之后的三个递归实现和一个迭代实现在代码中都有详细的说明，我就不再在此赘述。 公用接口123456789101112131415161718/* * 快速排序主体函数（递归） */template &lt;typename T&gt; void QuickSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument(&quot;Array must not be empty&quot;); if (length &lt;= 0) return; Partion1(array, 0, length - 1);// Partion2(array, 0, length - 1);// Partion3(array, 0, length - 1);// PartionInsert(array, 0, length - 1);// PartionSecond(array, 0, length - 1);// PartionThird(array, 0, length - 1);&#125; 递归法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/* * 快速排序1： * 将第一个元素array[left]提出来作pivot，i=left(该索引之前的数比pivot小，初始值为left)， * j从left+1开始遍历数组，找到一个比pivot小的数，i+1，如果i和j序列号不等就交换（小值到前）。 * j到最右端之后，for循环结束，再把pivot与i所指数据做交换，当前pivot就到达了它的最终位置。 */ template &lt;typename T&gt;void Partion1(T *array, int left, int right)&#123; if (left &gt;= right) return; int i = left; int j = left + 1; T pivot = array[left]; // 取第一个数为基准 for (; j &lt;= right; ++j)&#123; // 循环直至 j 扫描至 right if (array[j] &lt; pivot)&#123; // 如果遇到比基准小的数，i右移一位 i++; if (j != i)&#123; // 如果i与j不重合，则交换他们指向的值 swap(array[j],array[i]); &#125; &#125; &#125; swap(array[left], array[i]); // 基准值的位置确定 Partion1(array, left, i - 1); Partion1(array, i + 1, right);&#125;/* * 快速排序2： * 将第一个元素array[left]提出来作pivot，i = left+1从左向右遍历找到一个比pivot大的数停止， * 然后等待j从右往左遍历找到一个pivot小的数，两者交换，然后继续寻找直到i=j，for循环结束。 * 之后我们需要做判断，如果pivot比i所指数据大就交换两者，否则i回退一步（因为开始忽略了首元素）。 */template &lt;typename T&gt;void Partion2(T *array, int left, int right) &#123; if (left &gt;= right) return; int i = left + 1; int j = right; T pivot = array[left]; // 取第一个数为基准 while (i &lt; j)&#123; // 循环直至 i,j 相遇 while (i &lt; j &amp;&amp; array[j] &gt;= pivot) // j向左遍历，直到找到比pivot小的值 --j; while (i &lt; j &amp;&amp; array[i] &lt; pivot) // i向右遍历，直到找到比pivot大的值 ++i; if (i &lt; j) // 如果i &lt; j，就交换刚才找到的那两个值 swap(array[j], array[i]); &#125; if (array[i] &lt;= array[left]) // 这里一定要做判断再决定是否交换 swap(array[i], array[left]); else // 如果不交换，说明left是最小，但i是不是第二小不确定，所以需要下次判断 --i; Partion2(array, left, i - 1); Partion2(array, i + 1, right);&#125;/* * 快速排序3： * 将第一个元素array[left]提出来作pivot，然后从j = right向前搜索第一个比pivot小的元素假设为array[k]， * 该元素放在array[left]的位置。因为array[left]已经保存pivot覆盖也没关系，于是array[k]又可以被覆盖了， * 从前往后搜索比pivot大的元素放到array[k]。一直进行下去直到i=j。 */template &lt;typename T&gt; void Partion3(T *array, int left, int right) &#123; if (left &gt;= right) return; int i = left; int j = right; T pivot = array[left]; // 取第一个数为基准 while (i &lt; j)&#123; // 循环直至 i,j 相遇 while (i &lt; j &amp;&amp; array[j] &gt;= pivot) --j; if (i &lt; j) array[i++] = array[j]; // 从右向左扫描，将比基准小的数填到左边 while (i &lt; j &amp;&amp; array[i] &lt; pivot) ++i; if (i &lt; j) array[j--] = array[i]; // 从左向右扫描，将比基准大的数填到右边 &#125; array[i] = pivot; // 将基准数填回 Partion3(array, left, i - 1); Partion3(array, i + 1, right);&#125; 迭代法123456789101112131415161718192021222324252627282930313233343536/* * 快速排序迭代实现 */template&lt;typename T&gt;void QuickSortIteration(T *array, const int length) &#123; stack&lt;pair&lt;int, int&gt;&gt; trace; trace.push(make_pair(0, length - 1)); // 将数组首尾压栈 while (!trace.empty()) &#123; auto top = trace.top(); // 将栈顶元素保存下来 trace.pop(); // 弹出栈顶 int i = top.first; // 取出首尾地址 int j = top.second; T pivot = array[i]; // 取第一个数为基准 while (i &lt; j) &#123; // 循环直至 i,j 相遇 while (i &lt; j &amp;&amp; array[j] &gt;= pivot) --j; if (i &lt; j) array[i++] = array[j]; // 从右向左扫描，将比基准小的数填到左边 while (i &lt; j &amp;&amp; array[i] &lt; pivot) ++i; if (i &lt; j) array[j--] = array[i]; // 从左向右扫描，将比基准大的数填到右边 &#125; array[i] = pivot; // 将基准数填回 if (i &gt; top.first) trace.push(make_pair(top.first, i - 1)); if (j &lt; top.second) trace.push(make_pair(j + 1, top.second)); &#125;&#125; 算法复杂度 数据结构 不定 最坏时间复杂度 ${\displaystyle O(n^{2})}$ 最优时间复杂度 ${\displaystyle O(n\log n)}$ 平均时间复杂度 ${\displaystyle O(n\log n)}$ 空间复杂度 根据实现的方式不同而不同 分析&emsp;&emsp;快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。 &emsp;&emsp;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 ${\displaystyle O(n\log n)}$ 。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 ${\displaystyle O(\log n)}$ 的空间。然而，堆排序需要有效率的随机存取才能变成可行。 &emsp;&emsp;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 ${\displaystyle O(n\log n)}$ 运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 ${\displaystyle \Omega (n)}$ 额外的空间。 局限性&emsp;&emsp;快排的优化、归并排序的优化一向是面试的考察重点，至于算法的优化，重点还是要知道现有算法的不足之处。 当序列长度很小时，快排效率低，研究表明长度在5~25的数组，快排表现不如插入排序。 当pivot选择不当是，会导致树的不平衡，这样导致快排的时间复杂度为${\displaystyle O(n^{2})}$。 当数组中有大量重复的元素，快排效率将非常之低。 优化&emsp;&emsp;针对上面提出的快排的局限性，我们依次做出优化策略： 当当前序列长度小于特定值时，直接采用插入排序，或者不做处理，等到快排都执行完毕后（大致有序）在执行一次插入排序。 针对pivot的选择，不再选取固定值，而是采用其他选取策略，如随机、三值取中等。 如果数组中重复元素多，就采用三路划分算法：以某个数为基准将一个数组分成三部分：第一部分表示小于该pivot，第二部分等于pivot，第三部分大于pivot，要得到三部分得区间范围。 &emsp;&emsp;下面的代码是对上述改进算法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** 快速排序3优化1：* 当排序的子序列小于预定的值M时，采用插入排序*/template &lt;typename T&gt;void PartionInsert(T *array, int left, int right) &#123; if (left &gt;= right) return; if (right - left &lt;= M) InsertSort(array, left, right); else&#123; int i = left; int j = right; T pivot = array[left]; // 取第一个数为基准 while (i &lt; j)&#123; // 循环直至 i,j 相遇 while (i &lt; j &amp;&amp; array[j] &gt;= pivot) --j; if (i &lt; j) array[i++] = array[j]; // 从右向左扫描，将比基准小的数填到左边 while (i &lt; j &amp;&amp; array[i] &lt; pivot) ++i; if (i &lt; j) array[j--] = array[i]; // 从左向右扫描，将比基准大的数填到右边 &#125; array[i] = pivot; // 将基准数填回 PartionInsert(array, left, i - 1); PartionInsert(array, i + 1, right); &#125;&#125;//产生随机数template &lt;typename T&gt;void Random(T *array, int left, int right)&#123; int size = right - left + 1; int i = left + rand() % size; swap(array[i], array[left]);&#125;//取中位数移至lefttemplate &lt;typename T&gt;void Median(T *array, int left, int right)&#123; int mid = left + ((right - left )&gt;&gt; 1); int minIndex = right; if (array[minIndex] &gt; array[mid]) minIndex = mid; if (array[minIndex] &gt; array[left]) minIndex = left; if (minIndex != right) //三个判断，把最小值移到最右侧 swap(array[minIndex], array[right]); if (array[mid] &lt; array[left]) //那么剩下的两个数，最小的那个就是中位数了 swap(array[left], array[mid]);&#125;/** 快速排序3优化2：* 取随机数或者三值取中作为基准值*/template &lt;typename T&gt;void PartionSecond(T *array, int left, int right) &#123; if (left &gt;= right) return;// Random(array, left, right); // 优化2-1：取随机数至最左端（基准值） Median(array, left, right); // 优化2-2：取中位数至最左端（基准值） int i = left; int j = right; T pivot = array[left]; // 取第一个数为基准 while (i &lt; j)&#123; // 循环直至 i,j 相遇 while (i &lt; j &amp;&amp; array[j] &gt;= pivot) --j; if (i &lt; j) array[i++] = array[j]; // 从右向左扫描，将比基准小的数填到左边 while (i &lt; j &amp;&amp; array[i] &lt; pivot) ++i; if (i &lt; j) array[j--] = array[i]; // 从左向右扫描，将比基准大的数填到右边 &#125; array[i] = pivot; // 将基准数填回 PartionSecond(array, left, i - 1); PartionSecond(array, i + 1, right);&#125;/** 快速排序3优化3：* 重复数据比较多的话，可以分为小于等于大于三段*/template &lt;typename T&gt;void PartionThird(T *array, int left, int right) &#123; if (left &gt;= right) return; int less = left; int greater = right; int it = left; T pivot = array[left]; // 取第一个数为基准 while (it &lt;= greater)&#123; // 循环直至it和greater相遇 if (array[it] == pivot) // 如果等于pivot，it右移 ++it; else if (array[it] &lt; pivot)&#123; // 如果小于pivot，扔左边，it和less右移 swap(array[less], array[it]); ++it; ++less; &#125; else&#123; // 如果大于pivot，扔右边，greater左移 swap(array[greater], array[it]); --greater; &#125; &#125; PartionThird(array, left, less - 1); PartionThird(array, greater + 1, right);&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之冒泡排序]]></title>
    <url>%2F2018%2F01%2F05%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 冒泡排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 &emsp;&emsp;冒泡排序对 ${\displaystyle n}$ 个项目需要${\displaystyle O(n)}$ )的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。 步骤冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 演示&emsp;&emsp;wikipedia的大数据规模演示： &emsp;&emsp;wordzzzz的小数据规模演示： 代码123456789101112131415161718192021/* * 标准冒泡排序：嵌套循环比大小。 */ template &lt;typename T&gt;void BubbleSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; for (int i = 0; i &lt; length - 1; ++i)&#123; //外循环，每次循环确定一个最大值 for (int j = 0; j &lt; length - 1 - i; ++j)&#123; //内循环，用于交换数据，遍历次数递减 if (array[j] &gt; array[j + 1])&#123; //如果当前数据比后面的数据大，则交换 T tmp = array[j + 1]; array[j + 1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 算法复杂度 数据结构 数组 最坏时间复杂度 ${\displaystyle O(n^{2})}$ 最优时间复杂度 ${\displaystyle O(n)}$ 平均时间复杂度 ${\displaystyle O(n^{2})}$ 空间复杂度 总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$ 分析&emsp;&emsp;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 ${\displaystyle O(n^{2})}$次交换，而插入排序只要最多 ${\displaystyle O(n)}$ 交换。冒泡排序的实现（类似上面）通常会对已经排序好的数列拙劣地运行（ ${\displaystyle O(n^{2})}$ ），而插入排序在这个例子只需要 ${\displaystyle O(n)}$ 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。 &emsp;&emsp;在面试中，一般都会涉及到算法的优化，重点考察的其实还是你对现有算法的理解，分析现有算法的缺点，就能找到优化的思路。 优化1：冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 ${\displaystyle O(n)}$ 。在这个情况，已经排序好的数列就无交换的需要。优化2：可以记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。优化3：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。 优化代码如下： 优化1： 123456789101112131415161718192021222324/* * 冒泡排序优化1：如果某次内循环没有改变任何数据，则结束。 */template &lt;typename T&gt; void BubbleSort1(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; bool flag = false; //设置标志位，用来判断内循环是否有数据交换 for (int i = 0; i &lt; length - 1; ++i)&#123; //外循环，每次循环确定一个最大值 flag = false; //外循环第一步需要重置标志位 for (int j = 0; j &lt; length - 1 - i; ++j)&#123; //内循环，用于交换数据，遍历次数递减 if (array[j] &gt; array[j + 1])&#123; //如果当前数据比后面的数据大，则交换 T tmp = array[j + 1]; array[j + 1] = array[j]; array[j] = tmp; flag = true; //如果有交换，则标志位置1 &#125; &#125; if (!flag) return; //如果本次循环没有数据交换，则结束排序 &#125; &#125; 优化2： 1234567891011121314151617181920212223242526/** 冒泡排序优化2：在优化1的基础上，记录上次排序结束位置，减少排序次数。*/template &lt;typename T&gt;void BubbleSort2(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; int k = length; int flag = k; //设置标志位，用来判断内循环是否有数据交换 for (int i = 0; i &lt; length - 1; ++i)&#123; //外循环，每次循环确定一个最大值 k = flag; flag = 0; //外循环第一步需要重置标志位 for (int j = 0; j &lt; k - 1; ++j)&#123; //内循环，用于交换数据，遍历次数递减 if (array[j] &gt; array[j + 1])&#123; //如果当前数据比后面的数据大，则交换 T tmp = array[j + 1]; array[j + 1] = array[j]; array[j] = tmp; flag = j + 1; //如果有交换，更新交换位置的记录 &#125; &#125; if (!flag) return; //如果本次循环没有数据交换，则结束排序 &#125;&#125; 优化3： 1234567891011121314151617181920212223242526272829303132333435363738/* *冒泡排序优化3：鸡尾酒排序，一个外循环内跑两个内循环。 */template &lt;typename T&gt;void BubbleSort3(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; int low = 0; int high = length - 1; while (high &gt; low) &#123; for (int i = low; i &lt; high; ++i) //正向冒泡，确定最大值 &#123; if (array[i] &gt; array[i + 1]) &#123; T temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; &#125; &#125; --high; for (int j = high; j &gt; low; --j) //反向冒泡，确定最小值 &#123; if (array[j] &lt; array[j - 1]) &#123; T temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; ++low; &#125;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之堆排序]]></title>
    <url>%2F2018%2F01%2F04%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 堆排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 &emsp;&emsp;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点i的左子节点在位置 ${\displaystyle (2i+1)}$。 父节点i的右子节点在位置 ${\displaystyle (2i+2)}$。 子节点i的父节点在位置 ${\displaystyle floor((i-1)/2)}$。 &emsp;&emsp;在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序。 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。 步骤&emsp;&emsp;基于以上堆相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用del_max()函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是： 创建一个堆 ${\displaystyle H[0..n-1]}$。 把堆首（最大值）和堆尾互换。 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置。 重复步骤2，直到堆的尺寸为1。 演示&emsp;&emsp;wikipedia的大数据规模演示： 代码递归版1234567891011121314151617181920212223242526272829303132333435363738394041/** 堆排序递归版*/template &lt;typename T&gt;void MaxHeapifyRecursive(T *array, int i, int heapSize) &#123; int sonl = 2 * i + 1; int sonr = 2 * i + 2; int dad = i; if (sonl &lt;= heapSize &amp;&amp; array[sonl]&gt;array[i])&#123; //如果左子结点大于父结点，则父结点指向子结点 dad = sonl; &#125; if (sonr &lt;= heapSize &amp;&amp; array[sonr]&gt;array[dad])&#123; //如果右子结点大于父结点，则父结点指向子结点 dad = sonr; &#125; if (dad != i)&#123; //如果dad != i则说明父结点不是最大值，交换后递归执行MaxHeapifyRecursive swap(array[i], array[dad]); MaxHeapifyRecursive(array, dad, heapSize); &#125;&#125;template &lt;typename T&gt;void HeapSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; //初始化，i从最后一个父结点开始调整 for (int i = length / 2 - 1; i &gt;= 0; --i)&#123; //构建最大堆 MaxHeapifyRecursive(array, i, length - 1);// MaxHeapifyIteration(array, i, length - 1); &#125; //先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕 for (int i = length - 1; i &gt;= 0; --i)&#123; swap(array[0], array[i]); MaxHeapifyRecursive(array, 0, i - 1);// MaxHeapifyIteration(array, 0, i - 1); &#125;&#125; 迭代版123456789101112131415161718192021222324252627282930313233343536373839404142/** 堆排序迭代版*/template &lt;typename T&gt;void MaxHeapifyIteration(T *array, int left, int right) &#123; //建立父结点指针和子结点指针 int dad = left; int son = dad * 2 + 1; while (son &lt;= right) &#123; //若子结点指针在范围内才做比较 if (son + 1 &lt;= right &amp;&amp; array[son] &lt; array[son + 1]) //先比较两个子结点的大小，选择最大的 son++; if (array[dad] &gt; array[son]) //如果父结点大于子结点代表调整完毕，直接跳出循环 return; else &#123; //否则交换父子内容在继续子结点和孙结点的比较 swap(array[dad], array[son]); dad = son; son = dad * 2 + 1; &#125; &#125;&#125;template &lt;typename T&gt;void HeapSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; //初始化，i从最后一个父结点开始调整 for (int i = length / 2 - 1; i &gt;= 0; --i)&#123; //构建最大堆 // MaxHeapifyRecursive(array, i, length - 1); MaxHeapifyIteration(array, i, length - 1); &#125; //先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕 for (int i = length - 1; i &gt;= 0; --i)&#123; swap(array[0], array[i]);// MaxHeapifyRecursive(array, 0, i - 1); MaxHeapifyIteration(array, 0, i - 1); &#125;&#125; 算法复杂度 数据结构 数组 最坏时间复杂度 ${\displaystyle O(n\log n)}$ 最优时间复杂度 ${\displaystyle O(n\log n)}$ 平均时间复杂度 ${\displaystyle O(n\log n)}$ 空间复杂度 ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary 分析&emsp;&emsp;原地堆排序已经是空间优化版本了，因为它不再需要申请额外的空间。 &emsp;&emsp;整个算法的过程分为建堆和排序两个过程，首先对现有数组建立最大堆，然后一边提取堆顶的最大值，一边减小堆的尺寸，最后堆尺寸为1时，排序也就完成了。如果大家对整个算法的执行过程不太了解，可以看一下下面这两张图，第一张是建堆的过程示意图，第二张是排序的过程示意图。图片来自：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/ 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之选择排序]]></title>
    <url>%2F2018%2F01%2F03%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 选择排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 &emsp;&emsp;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 ${\displaystyle n}$ 个元素的表进行排序总共进行至多 ${\displaystyle n-1}$ 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 步骤 找到列表中的最小值。 把它和第一个位置的元素交换。 列表其余部分重复上面的步骤(从第二个位置开始，且每次加1)。 演示&emsp;&emsp;wikipedia的大数据规模演示： &emsp;&emsp;wordzzzz的小数据规模演示： 代码1234567891011121314151617181920212223/**直接选择排序*/template &lt;typename T&gt;void SelectSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; for (int i = 0; i &lt; length - 1; ++i)&#123; //外循环，每次选出一个最小的元素放到前面 int min = i; for (int j = i + 1; j &lt; length; ++j) //内循环，确定最小元素的下标 if (array[j] &lt; array[min]) min = j; if (min != i)&#123; //如果当前数据不是最小元素，就交换 T tmp = array[i]; array[i] = array[min]; array[min] = tmp; &#125; &#125;&#125; 算法复杂度 数据结构 数组 最坏时间复杂度 ${\displaystyle O(n^2)}$ 最优时间复杂度 ${\displaystyle O(n^2)}$ 平均时间复杂度 ${\displaystyle O(n^2)}$ 空间复杂度 ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary 分析&emsp;&emsp;选择排序的交换操作介于 ${\displaystyle 0}$ 和 ${\displaystyle (n-1)}$ 次之间。选择排序的比较操作为 ${\displaystyle n(n-1)/2}$ 次之间。选择排序的赋值操作介于 ${\displaystyle 0}$ 和 ${\displaystyle 3(n-1)}$ 次之间。 &emsp;&emsp;比较次数 ${\displaystyle O(n^{2})}$ ，比较次数与关键字的初始状态无关，总的比较次数 ${\displaystyle N=(n-1)+(n-2)+…+1=n\times (n-1)/2}$ 。交换次数 ${\displaystyle O(n)}$ ，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换 ${\displaystyle n-1} 次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多， ${\displaystyle n}$ 值较小时，选择排序比冒泡排序快。 &emsp;&emsp;原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之希尔排序]]></title>
    <url>%2F2018%2F01%2F02%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 希尔排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 &emsp;&emsp;希尔排序是基于插入排序的以下两点性质而提出改进方法的： &emsp;&emsp;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 步骤&emsp;&emsp;原始的算法实现在最坏的情况下需要进行${\displaystyle O(n^{2})}$ 的比较和交换。V. Pratt的书对算法进行了少量修改，可以使得性能提升至${\displaystyle O(n\log ^{2}n)}$ 。这比最好的比较算法的${\displaystyle O(n\log n)}$ 要差一些。 &emsp;&emsp;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 &emsp;&emsp;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 &emsp;&emsp;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。 &emsp;&emsp;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 &emsp;&emsp;然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 &emsp;&emsp;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 &emsp;&emsp;排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 &emsp;&emsp;最后以1步长进行排序（此时就是简单的插入排序了）。 演示&emsp;&emsp;wikipedia的大数据规模演示： 代码123456789101112131415161718192021222324/* * 希尔排序 */template &lt;typename T&gt;void ShellSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; for (int gap = length &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)&#123; //gap是设置的步长 T tmp; for (int i = gap; i &lt; length; ++i)&#123; tmp = array[i]; int j = i; //后面要用到j，所以在for循环的外面初始化 while (j &gt;= gap &amp;&amp; tmp &lt; array[j - gap])&#123; array[j] = array[j - gap]; j -= gap; &#125; array[j] = tmp; &#125; &#125;&#125; 算法复杂度 数据结构 数组 最坏时间复杂度 根据步长序列的不同而不同。已知最好的： ${\displaystyle O(n\log ^{2}n)}$ 最优时间复杂度 ${\displaystyle O(n)}$ 平均时间复杂度 根据步长序列的不同而不同。 空间复杂度 ${\displaystyle O(n)}$ 分析&emsp;&emsp;步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 &emsp;&emsp;Donald Shell最初建议步长选择为 ${\displaystyle {\frac {n}{2}}}$ 并且对步长取半直到步长达到1。虽然这样取可以比 ${\displaystyle O(n^{2})}$ 类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 步长序列 最坏情况下复杂度 ${\displaystyle {n/2^{i}}}$ ${\displaystyle O(n^{2})}$ ${\displaystyle 2^{k}-1}$ ${\displaystyle O(n^{3/2})}$ ${\displaystyle 2^{i}3^{j}}$ ${\displaystyle O(n\log ^{2}n)}$ &emsp;&emsp;已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自 ${\displaystyle 9\times 4^{i}-9\times 2^{i}+1}$和 ${\displaystyle 2^{i+2}\times (2^{i+2}-3)+1}$ 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 &emsp;&emsp;另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列之一：八大排序之插入排序]]></title>
    <url>%2F2018%2F01%2F01%2FDS%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 个人博客：https://wordzzzz.github.io/ &amp;&amp; https://wordzzzz.gitee.io/ 代码地址：https://github.com/WordZzzz/Note/tree/master/DS-A 博客作者：WordZzzz，一只热爱技术的文艺青年 [toc] 插入排序前言&emsp;&emsp;建议先看排序综述，传送门：数据结构与算法系列之一：八大排序综述。 简介&emsp;&emsp;插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 ${\displaystyle O(1)}$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 步骤&emsp;&emsp;一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序。 取出下一个元素，在已经排序的元素序列中从后向前扫描。 如果该元素（已排序）大于新元素，将该元素移到下一位置。 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。 将新元素插入到该位置后。 重复步骤2~5。 演示&emsp;&emsp;wikipedia的大数据规模演示： &emsp;&emsp;wordzzzz的小数据规模演示： 代码123456789101112131415161718192021/* * 插入排序 */ template &lt;typename T&gt; void InsertSort(T *array, const int length) &#123; if (array == NULL) throw invalid_argument("Array must not be empty"); if (length &lt;= 0) return; for (int i = 1; i &lt; length; ++i)&#123; //外循环，一次插入一个数据 T tmp = array[i]; int j = i - 1; //内循环，从i-1开始 while (j &gt;= 0 &amp;&amp; array[j] &gt; tmp)&#123; array[j+1] = array[j]; --j; &#125; array[j+1] = tmp; &#125; &#125; 算法复杂度 数据结构 数组 最坏时间复杂度 ${\displaystyle O(n^{2})}$ 最优时间复杂度 ${\displaystyle O(n)}$ 平均时间复杂度 ${\displaystyle O(n^{2})}$ 空间复杂度 总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$ 分析&emsp;&emsp;如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。 &emsp;&emsp;如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 ${\displaystyle n-1}$ 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 ${\displaystyle {\frac {1}{2}}n(n-1)}$ 次。插入排序的赋值操作是比较操作的次数减去 ${\displaystyle n-1}$ 次，（因为 ${\displaystyle n-1}$ 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 ${\displaystyle O(n^{2})}$ 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 &emsp;&emsp;下一篇将介绍插入排序的升级版：希尔排序。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（综合）：树中两个结点的最低公共祖先]]></title>
    <url>%2F2017%2F12%2F18%2Foffer-69%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入两个树节点，求他们的最低公共祖先。 解题思路求树中两个节点的最低公共祖先，不能说只是一个题目，而应该说是一组题目。不同条件下的题目解法是完全不一样的，比如，是否是二叉树、二叉排序树；如果不是二叉树，是否有指向父节点的指针（是的话可以转换成求两个链表的第一个公共节点，不是的话可以转换成求两个链表的最后一个公共节点）。 下面的代码针对的是普通树，并且没有指向父节点的指针，所以我们转换成求两个链表的最后一个公共节点。代码中GetNodePath用来得到根节点pRoot开始到达节点pNode的路径，这条路径保存在path中，函数GetLastCommonNode用来得到两个路径path1和path2的最后一个公共节点。函数GetLastCommonParent先调用GetNodePath得到pRoot到达pNode1的路径path1，再得到pRoot到达pNode2的路径path2，接着调用GetLastCommonNode得到path1和path2的最后一个公共节点，即我们要找的最低公共祖先。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758bool GetNodePath(const TreeNode* pRoot, const TreeNode* pNode, list&lt;const TreeNode*&gt;&amp; path)&#123; if(pRoot == pNode) return true; path.push_back(pRoot); bool found = false; vector&lt;TreeNode*&gt;::const_iterator i = pRoot-&gt;m_vChildren.begin(); while(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.end()) &#123; found = GetNodePath(*i, pNode, path); ++i; &#125; if(!found) path.pop_back(); return found;&#125;const TreeNode* GetLastCommonNode( const list&lt;const TreeNode*&gt;&amp; path1, const list&lt;const TreeNode*&gt;&amp; path2)&#123; list&lt;const TreeNode*&gt;::const_iterator iterator1 = path1.begin(); list&lt;const TreeNode*&gt;::const_iterator iterator2 = path2.begin(); const TreeNode* pLast = nullptr; while(iterator1 != path1.end() &amp;&amp; iterator2 != path2.end()) &#123; if(*iterator1 == *iterator2) pLast = *iterator1; iterator1++; iterator2++; &#125; return pLast;&#125;const TreeNode* GetLastCommonParent(const TreeNode* pRoot, const TreeNode* pNode1, const TreeNode* pNode2)&#123; if(pRoot == nullptr || pNode1 == nullptr || pNode2 == nullptr) return nullptr; list&lt;const TreeNode*&gt; path1; GetNodePath(pRoot, pNode1, path1); list&lt;const TreeNode*&gt; path2; GetNodePath(pRoot, pNode2, path2); return GetLastCommonNode(path1, path2);&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（综合）：把字符串转换成整数]]></title>
    <url>%2F2017%2F12%2F18%2Foffer-68%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述:输入一个字符串,包括数字字母符号,可以为空 输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1输入 12+2147483647 1a33 输出 122147483647 0 解题思路题目虽然简单，但是要写出完整的代码也是需要经过全面的思考才可以。 给出一个题目，我们首先要考虑的就是边界问题。对于这个题目，边界问题有： 空指针； 空字符串””； 带有正负号； 只有正负号； 上下溢出； 错误标志输出。 代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，标志位用来表示是否为负数。需要注意的也就只有上面提到的边界问题。具体实现如下。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: enum Status &#123;kValid = 0, kInvalid&#125;; int g_nStatus = kValid; int StrToInt(string str) &#123; g_nStatus = kInvalid; long long num = 0; const char* cstr = str.c_str(); //判断是否为空指针和是否为空字符串 if(cstr != NULL &amp;&amp; *cstr != '\0')&#123; bool minus = false; //正负号区分 if(*cstr == '+') cstr++; else if(*cstr == '-')&#123; cstr++; minus = true; &#125; //如果不是只有正负号，就进入下一个函数 if(*cstr != '\0') num = StrToIntCore(cstr, minus); &#125; return (int)num; &#125; long long StrToIntCore(const char* cstr, bool minus)&#123; long long num = 0; while(*cstr != '\0')&#123; //判断是否为非法值 if(*cstr &gt;= '0' &amp;&amp; *cstr &lt;= '9')&#123; int flag = minus ? -1 : 1; num = num * 10 + flag * (*cstr - '0'); //判断是否溢出 if((!minus &amp;&amp; num &gt; 0x7fffffff) || (minus &amp;&amp; num &lt; (signed int)0x80000000))&#123; num = 0; break; &#125; cstr++; &#125; else&#123; num = 0; break; &#125; &#125; #判断是否正常结束 if(*cstr == '\0') g_nStatus = kValid; return num; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（字符串）：字符流中第一个不重复的字符]]></title>
    <url>%2F2017%2F12%2F17%2Foffer-67%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路好吧，我是第一次见这种需要写部分测试函数的题目。 题目很简单，用hash表来实现，其实hash表的键值为输入字符的ASCII码，hash的值初始化为-1，出现一次则设置为该字符在字符串中的位置，出现两次以上则设置为-2。 最后搜索的时候，根据hash表的值就可以找到第一个不重复的字符。 occurrence[i] = -1: 这个字符不存在； occurrence[i] = -2: 这个字符出现了多次； occurrence[i] &gt;= 0: 这个字符只出现一次。 需要注意的是，因为我们要求如果当前字符流没有存在出现一次的字符，返回#字符，所以我们初始化字符时应该设置为’#’而不是’\0’。 C++版代码实现123456789101112131415161718192021222324252627282930313233class Solution&#123;public: Solution() &#123; memset(occurrence, -1, sizeof(occurrence)); &#125; //Insert one char from stringstream void Insert(char ch) &#123; if(occurrence[ch] == -1) occurrence[ch] = index; else if(occurrence[ch] &gt;= 0) occurrence[ch] = -2; index++; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; char ch = '#'; int minIndex = numeric_limits&lt;int&gt;::max(); for(int i = 0; i &lt; 256; ++i)&#123; if(occurrence[i] &gt;= 0 &amp;&amp; occurrence[i] &lt;= minIndex)&#123; ch = (char)i; minIndex = occurrence[i]; &#125; &#125; return ch; &#125;private: int occurrence[256]; int index;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（字符串）：表示数值的字符串]]></title>
    <url>%2F2017%2F12%2F17%2Foffer-64%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路其实这道题也是正则表达式的匹配过程。判断一个字符串是否表示数值的正则表达式为：[+-]\?[0-9]*(.[0-9]*)\?([eE][+-]?[0-9]*)\?。更加详细的注释都在程序里了，这里就不再赘述。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是 // 整数（可以有正负号，也可以没有），而B是一个无符号整数 bool isNumeric(const char* str) &#123; if(str == nullptr) return false; bool numeric = scanInteger(&amp;str); // 如果出现'.'，接下来是数字的小数部分 if(*str == '.') &#123; ++str; // 下面一行代码用||的原因： // 1. 小数可以没有整数部分，例如.123等于0.123； // 2. 小数点后面可以没有数字，例如233.等于233.0； // 3. 当然小数点前面和后面可以有数字，例如233.666 numeric = scanUnsignedInteger(&amp;str) || numeric; &#125; // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分 if(*str == 'e' || *str == 'E') &#123; ++str; // 下面一行代码用&amp;&amp;的原因： // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1； // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4 numeric = numeric &amp;&amp; scanInteger(&amp;str); &#125; return numeric &amp;&amp; *str == '\0'; &#125; bool scanUnsignedInteger(const char** str) &#123; const char* before = *str; while(**str != '\0' &amp;&amp; **str &gt;= '0' &amp;&amp; **str &lt;= '9') ++(*str); // 当str中存在若干0-9的数字时，返回true return *str &gt; before; &#125; // 整数的格式可以用[+|-]B表示, 其中B为无符号整数 bool scanInteger(const char** str) &#123; if(**str == '+' || **str == '-') ++(*str); return scanUnsignedInteger(str); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（字符串）：替换空格]]></title>
    <url>%2F2017%2F12%2F17%2Foffer-65%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz [toc] 前言C/C++中每个字符串都以字符‘\0’作为结尾，这样我们就能很方便地找到字符串的最后尾部。但是由于这个特点，每个字符串中都有一个额外字符的开销，稍不留神就会造成字符串的越界。 为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，在下面的代码中，str1 == str2成立，因为它们指向同一地址。 12char* str1 = "hello world";char* str2 = "hello world"; 但用常量内存初始化数组，情况就不同了，在下面的代码中，str3 == str4不成立，因为这是两个字符串数组，会为它们分配两个长度为12个字节的空间，他们的初始地址是不同的，所以str3和str4的值也不相同。 12char str3[] = "hello world";char str4[] = "hello world"; 题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路时间复杂度为O(n^2)的解法最直观的做法是从头到尾扫描字符串，每一个碰到空格字符的时候做替换。由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖。 假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对含有O(n)个空格字符的字符串而言总的时间效率是O(n^2)。 时间复杂度为O(n)的解法先遍历一遍字符串，统计处空格的总数，由此计算出替换之后的字符串的总长度。然后用两个指针从字符串的后面开始复制和替换。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾，然后向前移动P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格位置。碰到第一个空格之后，把P1向前移动一格，P2之前插入字符串“%20”，同时把P2向前移动三格。具体如图所示： 由于所有的字符都只复制一次，因此时间效率为O(n)。 C++代码实现12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void replaceSpace(char *str,int length) &#123; if(str == NULL || length &lt;= 0) return; int originalLength = 0; int numberOfBlank = 0; int i = 0; while(str[i] != '\0')&#123; ++ originalLength; if(str[i] == ' ') ++ numberOfBlank; ++ i; &#125; int newLength = originalLength + numberOfBlank * 2; if(newLength &gt;= length)&#123; return; &#125; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)&#123; if(str[indexOfOriginal] == ' ')&#123; str[indexOfNew--] = '0'; str[indexOfNew--] = '2'; str[indexOfNew--] = '%'; &#125; else&#123; str[indexOfNew--] = str[indexOfOriginal]; &#125; -- indexOfOriginal; &#125; &#125;&#125;; Python代码实现手动替换123456789101112# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here res = '' for ele in s: if ele.strip(): res += ele else: res += '%20' return res 调用replace123456# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here return s.replace(" ", "%20") 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（字符串）：正则表达式匹配]]></title>
    <url>%2F2017%2F12%2F17%2Foffer-66%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配。 解题思路只有当模式串和字符串同时等于’\0’，才可以认为两个串匹配。 在匹配中，对于每个位的匹配可以分为三种情况: 1、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位是’*’ 2、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位不是’*’ 3、相应位不匹配&amp;&amp;（模式位不为’.’||字符串是’\0’） 对应1，最复杂。分为*取0，*取1，*&gt;=2三种情况。*取0对应跳过当前匹配位，继续寻找patter的下一个匹配位，str不变，pattern+2*取1对应当前匹配位算一次成功匹配，str+1，pattern+2*取&gt;=2对应一次成功匹配，继续匹配字符串的下一位是否匹配，str+1，pattern不变三者取或。即只要有一种情况能匹配成功认为字符串就是匹配成功的。对应2，相当于一次成功匹配，str+1，pattern+1对应3，匹配失败，直接返回false C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool match(const char* str, const char* pattern) &#123; if(str == nullptr || pattern == nullptr) return false; return matchCore(str, pattern); &#125; bool matchCore(const char* str, const char* pattern) &#123; if(*str == '\0' &amp;&amp; *pattern == '\0') return true; if(*str != '\0' &amp;&amp; *pattern == '\0') return false; if(*(pattern + 1) == '*') &#123; if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0')) // 进入有限状态机的下一个状态 return matchCore(str + 1, pattern + 2) // 继续留在有限状态机的当前状态 || matchCore(str + 1, pattern) // 略过一个'*' || matchCore(str, pattern + 2); else // 略过一个'*' return matchCore(str, pattern + 2); &#125; if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0')) return matchCore(str + 1, pattern + 1); return false; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：左旋转字符串]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-63%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路和上一道题一样，我们根据n将字符串分为两部分，这两部分先自己反转，然后再一同反转。 C++版代码实现1234567891011121314151617181920212223242526class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int length = str.size(); if(length &lt; 0) return NULL; if(length &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= length)&#123; int pFirstStart = 0; int pFirstEnd = n - 1; int pSecondStart = n; int pSecondEnd = length - 1; // 翻转字符串的前面n个字符 reverseWord(str, pFirstStart, pFirstEnd); // 翻转字符串的后面部分 reverseWord(str, pSecondStart, pSecondEnd); // 翻转整个字符串 reverseWord(str, pFirstStart, pSecondEnd); &#125; return str; &#125; void reverseWord(string &amp;str, int begin, int end)&#123; while(begin &lt; end) swap(str[begin++], str[end--]); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：数组中只出现一次的数字]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-62%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz [toc] 题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 解题思路我刚看到这道题的时候，一点思路都没有，看了别人的解法之后才恍然大悟。 这道题我们可以利用异或的特性–两个相同数字异或，结果为0。把数组中的数据全部想成二进制会更容易理解。 首先我们来考虑数组中只有一个出现一次的数字的情况，这种情况下，我们直接异或数组中的所有值即可得到这个数字；接下来考虑有两个出现一次的数字的情况，这种情况下，我们可以把原来的数组分成两组，每组里面各有一个只出现一次的数字，然后运用前面的解法即可得到结果。 问题的关键是如何划分成两个数组。我们呢可以根据全部值异或的结果进行思考，我们可以先把结果中最右边的1作为划分条件，然后判断数组中每个数字该位置上是不是1，如果是则为第一组，否则为第二组。这样分完之后，一组里面正好一个只出现一次的数字。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int length = data.size(); if(length &lt; 2) return; //异或操作 int resultExclusiveOR = 0; for(int i = 0; i &lt; length; ++i) resultExclusiveOR ^= data[i]; //获取倒数第一个1的位置 unsigned int indexOf1 = findFirstBitIs1(resultExclusiveOR); //分组异或 *num1 = *num2 = 0; for(int j=0; j &lt; length; ++j)&#123; if(isBit1(data[j], indexOf1)) *num1 ^= data[j]; else *num2 ^= data[j]; &#125; &#125; unsigned int findFirstBitIs1(int num)&#123; int indexBit = 0; while((num &amp; 1) == 0 &amp;&amp; indexBit &lt; 8 * sizeof(int))&#123; num = num&gt;&gt;1; ++ indexBit; &#125; return indexBit; &#125; bool isBit1(int num, unsigned int indexBit)&#123; num = num &gt;&gt; indexBit; return (num &amp; 1); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：和为S的两个数字]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-59%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述对应每个测试案例，输出两个数，小的先输出。 解题思路暴力的时间复杂度为O(n^2)。 下面我们想一下时间复杂度为O(n)的算法。我们可以定义两个指针，一个从前往后遍历（ahead），另一个从后往前遍历（behind）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字sum，如果curSum &lt; sum，那么我们就要加大输入值，所以，ahead向后移动一位，重复之前的计算；如果curSum &gt; sum，那么我们就要减小输入值，所以，behind向前移动一位，重复之前的计算；如果相等，那么这两个数字就是我们要找的数字，直接输出即可。 C++版代码实现12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; result; int length = array.size(); if(length &lt; 1) return result; int ahead = length-1; int behind = 0; int curSum; while(ahead &gt; behind)&#123; curSum = array[ahead] + array[behind]; if(curSum == sum)&#123; result.push_back(array[behind]); result.push_back(array[ahead]); break; &#125; else if(curSum &lt; sum) ++behind; else --ahead; &#125; return result; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：平衡二叉树]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-60%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路可以在之前求二叉树深度的基础上进行算法实现，但是需要多次遍历。我们也可以用后序遍历，这样我们只需要遍历一次即可，需要需要存储一下左右子树的深度。 C++版代码实现多次遍历12345678910111213141516class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; if(pRoot == NULL) return true; int left = getDepth(pRoot-&gt;left); int right = getDepth(pRoot-&gt;right); int diff = left - right; if(diff &gt; 1 || diff &lt; -1) return false; return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right); &#125; int getDepth(TreeNode* pRoot)&#123; return pRoot ? max(getDepth(pRoot-&gt;left),getDepth(pRoot-&gt;right))+1 :0; &#125;&#125;; 一次遍历12345678910111213141516171819202122class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; int depth = 0; return IsBalanced(pRoot, &amp;depth); &#125; int IsBalanced(TreeNode* pRoot, int* depth)&#123; if(pRoot == NULL)&#123; *depth = 0; return true; &#125; int left, right; if(IsBalanced(pRoot-&gt;left, &amp;left) &amp;&amp; IsBalanced(pRoot-&gt;right, &amp;right))&#123; int diff = left - right; if(diff &lt;= 1 &amp;&amp; diff &gt;= -1)&#123; *depth = 1 + (left &gt; right ? left : right); return true; &#125; &#125; return false; &#125;&#125;; Python版代码实现多次遍历123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if pRoot == None: return True left = self.getDepth(pRoot.left) right = self.getDepth(pRoot.right) diff = abs(left - right) if diff &gt; 1: return False return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right) def getDepth(self, pRoot): if not pRoot: return 0 return max(self.getDepth(pRoot.left),self.getDepth(pRoot.right))+1 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：和为S的连续正数序列]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-58%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路延续我们上一道题的思路，可以先给定两个数（phigh = 2,plow = 1），然后开始遍历求和，如果curSum大了，plow加1，如果curSum小了，phigh就加1；每次遇到curSum和sum相等了，就将当前plow和phigh之间的数据全部压入临时tmp中，最后再将tmp压入最终结果result。 C++版代码实现1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; int phigh = 2,plow = 1; while(phigh &gt; plow)&#123; int curSum = (phigh + plow) * (phigh - plow + 1) / 2; if( curSum &lt; sum) phigh++; if( curSum == sum)&#123; vector&lt;int&gt; res; for(int i = plow; i &lt;= phigh; i++) res.push_back(i); result.push_back(res); plow++; &#125; if(curSum &gt; sum) plow++; &#125; return result; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：翻转单词顺序列]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-57%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路很简单，先将每个单词反转，再将所有字符串一起反转。我们这里写个函数封装一下反转的过程，同时用追加空格字符的方式来减少判断条件。 C++版代码实现123456789101112131415161718192021222324class Solution &#123;public: string ReverseSentence(string str) &#123; auto length = str.size(); if(length == 0) return &quot;&quot;; str += &apos; &apos;; int mark = 0; for(int i = 0; i &lt; length + 1; ++i)&#123; if(str[i] == &apos; &apos;)&#123; reverseWord(str, mark, i-1); mark = i + 1; &#125; &#125; str = str.substr(0, length); reverseWord(str, 0, length-1); return str; &#125; void reverseWord(string &amp;str, int begin, int end)&#123; while(end &gt; begin) swap(str[begin++],str[end--]); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：二叉树的深度]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-56%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路：DFS:题目很简单，用递归遍历只需一行。如果传入的树指针为空指针，则直接返回0；否则，递归调用TreeDepth，遍历左右子树并返回最大值。BFS:层次遍历，需要使用队列。如果队列不为空，则在循环内不断的pop根节点、push左右子树，同时累加depth。 C++版代码实现：递归：12345678910111213141516/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; return pRoot ? max(TreeDepth(pRoot-&gt;left),TreeDepth(pRoot-&gt;right))+1 :0; &#125;&#125;; 层序遍历：123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(!pRoot) return 0; queue&lt;TreeNode*&gt; que; int depth = 0; que.push(pRoot); while(!que.empty())&#123; int size = que.size(); depth++; for(int i=0; i &lt; size; i++)&#123; TreeNode* node = que.front(); que.pop(); if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; &#125; return depth; &#125;&#125;; Python版代码实现：递归：123456789101112# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 层次遍历：1234567891011121314151617181920212223# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 a=[pRoot] depth=0 while a: b=[] for node in a: if node.left: b.append(node.left) if node.right: b.append(node.right) a=b depth=depth+1 return depth 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（知识迁移能力）：数字在排序数组中出现的次数]]></title>
    <url>%2F2017%2F12%2F16%2Foffer-61%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述统计一个数字在排序数组中出现的次数。 解题思路数组是排序的，那就没什么好说的了，直接二分查找。 假设我们给定的数字是2，二分查找可以帮我们找到一个2。然后我们左右两边顺序扫描，找到第一个2和最后一个2。因为要查找的数字在长度为n的数组中有可能出现O(n)次，所以顺序扫描的时间复杂度为O(n)。因此这种算法的效率和从头到尾直接顺序扫描整个数组统计出2的个数是一样的。 我们在这里采用更高效的方法。还是二分法找到一个2，然后我们开始判断，这个2是不是第一个2（或者最后一个2）：如果是，那么就返回序列号，如果不是，就继续二分查找。由于二分法查找第一个2和最后一个2在此处的判断条件不一样，所以得分开写。 我们不要拘泥于迭代，也可以试着写写循环嘛。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int length = data.size(); if(length == 0) return 0; int firstK = getFirstK(data, 0, length-1, k); int lastK = getLastK(data, 0, length-1, k); if(firstK != -1 &amp;&amp; lastK != -1) return lastK-firstK+1; return 0; &#125; //迭代实现 int getFirstK(vector&lt;int&gt; data, int begin, int end, int k)&#123; if(begin &gt; end) return -1; int middleIndex = (end+begin)&gt;&gt;1; int middleData = data[middleIndex]; if(middleData == k)&#123; if((middleIndex &gt; 0 &amp;&amp; data[middleIndex-1] != k) || middleIndex == 0) return middleIndex; else end = middleIndex - 1; &#125; else if(middleData &gt; k) end = middleIndex - 1; else begin = middleIndex + 1; return getFirstK(data, begin, end, k); &#125; //循环实现 int getLastK(vector&lt;int&gt; data, int begin, int end, int k)&#123; int length = data.size(); int middleIndex = (end+begin)&gt;&gt;1; int middleData = data[middleIndex]; while(begin &lt;= end)&#123; if(middleData == k)&#123; if((middleIndex &lt; length-1 &amp;&amp; data[middleIndex+1] != k) || middleIndex == length-1) return middleIndex; else begin = middleIndex + 1; &#125; else if(middleData &gt; k) end = middleIndex - 1; else begin = middleIndex + 1; middleIndex = (end+begin)&gt;&gt;1; middleData = data[middleIndex]; &#125; return -1; &#125;&#125;; Python版代码实现12345# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here return data.count(k) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（位运算）：二进制中1的个数]]></title>
    <url>%2F2017%2F12%2F15%2Foffer-53%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路：方法一：用1（循环左移）与n的每一位进行位与，来判断1的个数；注意，如果用n进行循环右移，一定要注意负数的情况，因为如果是负数，n右移之后高位补位为1，如果一开始不对n加以判断和处理，就会进入死循环。 方法二：目前我认为最优的解。n=(n-1) &amp; n;举个栗子：一个二进制数n为1100，那么n-1为1011，1011&amp;1100=1000，我们会发现，这样操作之后，相当于把n最右边的一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 方法三：python的解法给了我另一种思路，为什么不用位数作为循环终止条件呢？ C++版代码实现：方法一：1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((n &amp; flag) != 0) &#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count; &#125;&#125;; 方法二：1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; ++count; n = (n - 1) &amp; n; &#125; return count; &#125;&#125;; Python版代码实现：方法三：12345# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here return sum([(n&gt;&gt;i &amp; 1) for i in range(0,32)]) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（栈和队列）：滑动窗口的最大值]]></title>
    <url>%2F2017%2F12%2F15%2Foffer-54%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路实际上一个滑动窗口可以看成是一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列的先进先出特性。那么剩下的任务就是如何从队列中找出它的最大值了。 之前有题目是用O(1)时间得到最小值的栈，也有题目是用两个栈实现队列，如果结合起来，我们就会很容易写出来代码。总的时间复杂度为O(n)。 但是在这里，我们并不打算用上述方法，因为这相当于要写两个题的代码。我们试想一下，如果把比大小这一步放在入栈之前，情况会不会好点？ 我们可以用STL中的deque来实现，接下来我们以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。 数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。 第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。 但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。 下述代码中，index是一个两端开口的队列，用来保存有可能是滑窗最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是否小于待存入的数字。如果已有的数字小于待存入的数字，这些数字已经不可能是滑动窗口的最大值，因此它们将会依次从队列的尾部删除（调用pop_back）。同时，如果队列头部的数字已经从窗口里滑出，滑出的数字也需要从队列的头部删除（调用pop_front）。由于队列的头部和尾部都有可能删除数字，这也是需要两段开口的队列的原因。 C++版代码实现12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; maxInWindows; if(num.size() &gt;= size &amp;&amp; size &gt;= 1)&#123; deque&lt;int&gt; index; for(unsigned int i = 0; i &lt; size; ++i)&#123; while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) index.pop_back(); index.push_back(i); &#125; for(unsigned int i = size; i &lt; num.size(); ++i)&#123; maxInWindows.push_back(num[index.front()]); while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) index.pop_back(); if(!index.empty() &amp;&amp; index.front() &lt;= (int)(i-size)) index.pop_front(); index.push_back(i); &#125; maxInWindows.push_back(num[index.front()]); &#125; return maxInWindows; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（栈和队列）：用两个栈实现队列]]></title>
    <url>%2F2017%2F12%2F15%2Foffer-55%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言栈是一个非常常见的数据结构，它在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。栈的特点是后进先出，即最后被压入（push）栈的元素会第一个被弹出（pop）。通常栈是一个不考虑排序的数据结构，所以我们需要O(n)时间才能找到栈中最大或者最小的元素。如果想要在O(1)时间内得到栈的最大或者最小值，我们需要对栈进行特殊的设计，以后会讲到。 队列是另外一种很重要的数据结构。与栈不同，队列的特点是先进先出。栈和队列虽然是特点针锋相对的两个数据结构，但有意思的是它们却相互联系，比如用两个栈实现队列，当然也可以用两个队列实现栈。 题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路：栈：后进先出（LIFO）;队列：先进先出（FIFO）.入队：将元素进栈A出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈 C++版代码实现：123456789101112131415161718192021222324252627class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int tmp; if(stack2.empty()) &#123; while(!stack1.empty()) &#123; tmp = stack1.top(); stack2.push(tmp); stack1.pop(); &#125; &#125; tmp = stack2.top(); stack2.pop(); return tmp; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; Python版代码实现：1234567891011121314# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2 == []: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（数组）：数组中重复的数字]]></title>
    <url>%2F2017%2F12%2F14%2Foffer-52%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 解题思路如果先排序，再找出重复的数字是一件很容易的事情，只需要从头到尾遍历排序后的数组就可以了。排序一个长度为n的数组需要O(nlogn)的时间。 还可以利用hash表来解决这个问题，从头到尾按顺序扫描数组中的每个数，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入到哈希表中；如果已经存在，就说明找到了一个重复的数字。算法复杂度为O(n)，但是是以一个大小为O(n)的哈希表为代价的。 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）；遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则成功！若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2. 本文复现的是最后一种方法。 C++版代码实现123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; //非法输入1 if(numbers == NULL || length &lt;= 0) return false; //非法输入2 for(int i=0; i &lt; length; ++i)&#123; if(numbers[i] &lt; 0 || numbers[i] &gt; length-1) return false; &#125; //遍历查找第一个重复的数字 for(int i=0; i &lt; length; ++i)&#123; while(numbers[i] != i)&#123; if(numbers[i] == numbers[numbers[i]])&#123; *duplication = numbers[i]; return true; &#125; //不相等就交换 int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; &#125; &#125; return false; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（数组）：二维数组中的查找]]></title>
    <url>%2F2017%2F12%2F14%2Foffer-50%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 当然，大家也可以制定自己的规则，建议从左下角或者右上角开始，因为如果直接随机选取数组中的一个数开始进行比较，剩下的区域会出现重合的现象，即所谓的岔路，不好操作。比如我用的右上角，那就一直用右上角的进行判断，进行比较后剔除一行或者一列。算法时间复杂度为O(m+n)。 还有人直接对每一行用二分法进行查找，算法时间复杂度为O(mlogn)。 C++代码实现右上角123456789101112131415161718192021class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row = array.size(); int col = array[0].size(); if(!array.empty() &amp;&amp; row &gt; 0 &amp;&amp; col &gt; 0) &#123; int i = 0; int j = col - 1; while(i &lt; row &amp;&amp; j &gt;= 0) &#123; if(array[i][j] == target) return true; else if(array[i][j] &gt; target) --j; else ++i; &#125; &#125; return false; &#125;&#125;; 二分遍历12345678910111213141516171819class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; for(int i=0; i &lt; array.size(); i++)&#123; int low=0; int high=array[i].size()-1; while(low &lt;= high)&#123; int mid = (low + high) / 2; if(target &gt; array[i][mid]) low = mid + 1; else if(target &lt; array[i][mid]) high = mid - 1; else return true; &#125; &#125; return false; &#125;&#125;; Python代码实现右上角12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here row=len(array) col=len(array[0]) if row &gt; 0 and col &gt; 0: i = 0 j = col -1 while i &lt; row and j &gt;= 0: if array[i][j] == target: return True elif array[i][j] &gt; target: j = j - 1 else: i = i + 1 return False 遍历12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here n=len(array) flag='false' for i in range(n): if target in array[i]: flag='true'; break return flagwhile True: try: S=Solution() # 字符串转为list L=list(eval(raw_input())) array=L[1] target=L[0] print(S.Find(target, array)) except: break 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（数组）：构建乘积数组]]></title>
    <url>%2F2017%2F12%2F14%2Foffer-51%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] A[1] … A[i-1] A[i+1] … A[n-1]。不能使用除法。 解题思路：B[i]=A[0] A[1] … A[i-1] A[i+1] … A[n-1]1.从左到右算 B[i]=A[0] A[1] … A[i-1]2.从右到左算 B[i] =A[i+1] … A[n-1]拒绝嵌套循环。 C++版代码实现：1234567891011121314class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; B(n); int ret=1; for(int i=0; i&lt;n; ret*=A[i++]) B[i] = ret; ret=1; for(int i=n-1; i&gt;=0; ret*=A[i--]) B[i] *=ret; return B; &#125;&#125;; Python版代码实现：1234567891011121314# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here num = len(A) B = [None] * num B[0] = 1 for i in range(1, num): B[i] = B[i-1] * A[i-1] tmp = 1 for i in range(num-2, -1, -1): tmp *= A[i+1] B[i] *= tmp return B 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：把二叉树打印成多行]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-43%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz [toc] 题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路层序遍历，之前求树的深度的时候简单用过。 在线测试的测试结果需要是一个二维数组（vector]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：序列化二叉树]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-48%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz [toc] 题目描述请实现两个函数，分别用来序列化和反序列化二叉树。 解题思路这道题其实没什么好说的，在牛客网上，即使你在反序列化的时候直接输出root也能通过测试。 书上倒是写的听清楚。用到了dfs的思想，通过前序遍历来序列化或者反序列化。这块你只要自己写的格式能对应上，都是可以的。比如可以按照书中那样用$表示null并且用逗号分隔每个节点，也可以直接用下面第一种方法代码所示的0xFFFFFFFF标识null。需要注意的是，如果使用string来实现序列化之后的存储，那么在每个结点之后也要加分隔符，例如’,’。 下面贴出了三种实现方式 基于vector，好处就是你不需要在每个结点之后再加分隔符； 基于string，其他平台序列化之后的返回值类型都是string，牛客网搞特殊来了个char *，所以最后需要进行类型转换； 基于stringstream，代码更加简洁； C++版代码实现vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; buf; void dfs1(TreeNode *root)&#123; if(!root) buf.push_back(0xFFFFFFFF); else&#123; buf.push_back(root-&gt;val); dfs1(root-&gt;left); dfs1(root-&gt;right); &#125; &#125; TreeNode* dfs2(int* &amp;str)&#123; if(*str == 0xFFFFFFFF)&#123; ++str; return NULL; &#125; TreeNode* res = new TreeNode(*str); str++; res-&gt;left = dfs2(str); res-&gt;right = dfs2(str); return res; &#125; char* Serialize(TreeNode *root) &#123; buf.clear(); dfs1(root); int bufSize = buf.size(); int *res = new int[bufSize]; for(int i = 0;i &lt; bufSize; i++) res[i] = buf[i]; return (char*)res; &#125; TreeNode* Deserialize(char *str) &#123; int *p = (int*)str; return dfs2(p); &#125;&#125;; string123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: void serializeHelper(TreeNode *node, string&amp; s) &#123; if (node == NULL) &#123; s.push_back('#'); s.push_back(','); return; &#125; s += to_string(node-&gt;val); s.push_back(','); serializeHelper(node-&gt;left, s); serializeHelper(node-&gt;right, s); &#125; char* Serialize(TreeNode *root) &#123; if (root == NULL) return NULL; string s = ""; serializeHelper(root, s); char *ret = new char[s.length() + 1]; strcpy(ret, s.c_str()); return ret; &#125; TreeNode *deserializeHelper(string &amp;s) &#123; if (s.empty()) return NULL; if (s[0] == '#') &#123; s = s.substr(2); return NULL; &#125; TreeNode *ret = new TreeNode(stoi(s)); s = s.substr(s.find_first_of(',') + 1); ret-&gt;left = deserializeHelper(s); ret-&gt;right = deserializeHelper(s); return ret; &#125; TreeNode* Deserialize(char *str) &#123; if (str == NULL) return NULL; string s(str); return deserializeHelper(s); &#125;&#125;; stringstream12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: string sHelper(TreeNode *node) &#123; if (node == NULL) return "#"; return to_string(node-&gt;val) + "," + sHelper(node-&gt;left) + "," + sHelper(node-&gt;right); &#125; char* Serialize(TreeNode *root) &#123; string s = sHelper(root); char *ret = new char[s.length() + 1]; strcpy(ret, const_cast&lt;char*&gt;(s.c_str())); return ret; &#125; TreeNode *dHelper(stringstream &amp;ss) &#123; string str; getline(ss, str, ','); if (str == "#") return NULL; else &#123; TreeNode *node = new TreeNode(stoi(str)); node-&gt;left = dHelper(ss); node-&gt;right = dHelper(ss); return node; &#125; &#125; TreeNode* Deserialize(char *str) &#123; stringstream ss(str); return dHelper(ss); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：数据流中的中位数]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-47%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 解题思路解法很多，直接列出表格吧。 我们这里采用最优的最大最小堆来实现。下面来讨论一些细节问题。 首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1.为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。 此外，还要保证最大堆中所有数据小于最小堆中数据。所以，新传入的数据需要先和最大堆的最大值或者最小堆中的最小值进行比较。以总数目为偶数为例，按照我们制定的规则，新的数据会被插入到最小堆中，但是在这之前，我们需要判断这个数据和最大堆中的最大值谁更大，如果最大堆中的数据比较大，那么我们就需要把当前数据插入最大堆，然后弹出新的最大值，再插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆的数字。 下面代码中，我们基于stl中的函数push_heap、pop_heap以及vector实现堆。比较仿函数less和greater分别用来实现最大堆和最小堆。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: void Insert(int num) &#123; if(((min.size() + max.size()) &amp; 1) == 0)&#123; if(max.size() &gt; 0 &amp;&amp; num &lt; max[0])&#123; max.push_back(num); push_heap(max.begin(), max.end(), less&lt;int&gt;()); num = max[0]; pop_heap(max.begin(), max.end(), less&lt;int&gt;()); max.pop_back(); &#125; min.push_back(num); push_heap(min.begin(), min.end(), greater&lt;int&gt;()); &#125; else&#123; if(min.size() &gt; 0 &amp;&amp; num &gt; min[0])&#123; min.push_back(num); push_heap(min.begin(), min.end(), greater&lt;int&gt;()); num = min[0]; pop_heap(min.begin(), min.end(), greater&lt;int&gt;()); min.pop_back(); &#125; max.push_back(num); push_heap(max.begin(), max.end(), less&lt;int&gt;()); &#125; &#125; double GetMedian() &#123; int size = max.size() + min.size(); if(size == 0) return 0; if((size &amp; 1) == 1) return min[0]; else return (min[0] + max[0]) / 2.0; &#125;private: vector&lt;int&gt; min; vector&lt;int&gt; max;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：二叉树的下一个结点]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-45%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路如果一个结点有右子树，那么它的下一个结点就是它的右子树中的最左子结点；如果给定结点是其父结点的左子结点，那么它的下一个结点就是它的父结点；如果一个结点既没有右子树，并且它还是它父结点的右子结点，那我们就需要一直向上遍历，知道找到一个是其父结点的左子结点的结点。 对最后一种情况做下解释，比如我们为了找到下图中结点i的下一个结点，我们沿着指向父结点的指针向上遍历，先到达结点e。由于结点e是它父结点的b的右结点，我们继续遍历到b。b是其父结点a的左子结点，因此b的父结点a就是结点i的下一个结点。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if(pNode == NULL) return NULL; TreeLinkNode* pNext = NULL; //当前结点有右子树，则下一结点是右子树的最左结点 if(pNode-&gt;right != NULL)&#123; TreeLinkNode* pRight = pNode-&gt;right; while(pRight-&gt;left != NULL) pRight = pRight-&gt;left; pNext = pRight; &#125; //当前结点无右子树，则需要向上找到其父结点（可以是当前结点）可以作为左子树的时候 else if(pNode-&gt;next != NULL)&#123; TreeLinkNode* pCurrent = pNode; TreeLinkNode* pParrent = pNode-&gt;next; while(pParrent != NULL &amp;&amp; pCurrent == pParrent-&gt;right)&#123; pCurrent = pParrent; pParrent = pParrent-&gt;next; &#125; pNext = pParrent; &#125; return pNext; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：二叉搜索树的第k个结点]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-46%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路我感觉大家都很容易就能想到中序遍历，因为二叉搜索树本来就是排序的，左结点小于根结点小于右结点，这个顺序正好和中序遍历的顺序一样。参考代码如下，其中遍历右子树的时候多加了对target == NULL 的判断，意思是如果target有值了就没必要往下再遍历了。 C++版代码实现123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* KthNode(TreeNode* pRoot, int k) &#123; if(pRoot == NULL || k &lt; 1) return NULL; return KthNodeCore(pRoot, k); &#125; TreeNode* KthNodeCore(TreeNode* pRoot, int &amp;k)&#123; TreeNode* target = NULL; if(pRoot-&gt;left != NULL) target = KthNodeCore(pRoot-&gt;left, k); if(target == NULL)&#123; if(k == 1) target = pRoot; k--; &#125; if(target == NULL &amp;&amp; pRoot-&gt;right != NULL) target = KthNodeCore(pRoot-&gt;right, k); return target; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：重建二叉树]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-49%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言树是一种实际编程中经常遇到的数据结构。由于树的操作会设计大量的指针，因此与树有关的面试题都不太容易。当面试官想考查应聘者在有复杂指针操作的情况下写代码的能力，他往往会想到用与树有关的面试题。 面试的时候提到的树，大部分都是二叉树。所谓二叉树是树的一种特殊结构，在二叉树中每个结点最多只能有两个子结点。在二叉树中最重要的操作莫过于遍历，即按照某一顺序访问树中的所有结点。通常树有如下几种遍历方式： 前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。 前中后都是指的根结点在遍历中的位置。每一种遍历都有递归和循环两种不同的实现方式，每一种遍历的递归实现都比循环实现要简捷很多。我们需要对着三种遍历的六种实现方法都了如指掌。 宽度优先遍历：先访问树的第一层结点，再访问树的第二层结点，一直访问到最下面一层节点。在同一层结点中，以从左到右的顺序依次访问。 特例： 二叉搜索树。在二叉搜索树中，左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。我们可以平均在O(logn)的时间内根据数值在二叉搜索树中找到一个结点。 堆。堆分为最大堆和最小堆。在最大堆中根结点的值最大，在最小堆中结点的值最小。有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。 红黑树。红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。 在C++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以递归来实现，具体如图： C++代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; int vinlen = vin.size(); if(vinlen == 0) return NULL; vector&lt;int&gt; left_pre, right_pre, left_vin, right_vin; //创建根节点，根节点肯定是前序遍历的第一个数 TreeNode* head = new TreeNode(pre[0]); //找到中序遍历根节点所在位置,存放于变量gen中 int gen = 0; for(int i = 0; i &lt; vinlen; i++) &#123; if (vin[i] == pre[0]) &#123; gen = i; break; &#125; &#125; //对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边 //利用上述这点，对二叉树节点进行归并 for(int i = 0; i &lt; gen; i++) &#123; left_vin.push_back(vin[i]); left_pre.push_back(pre[i+1]);//前序第一个为根节点 &#125; for(int i = gen + 1; i &lt; vinlen; i++) &#123; right_vin.push_back(vin[i]); right_pre.push_back(pre[i]); &#125; //取出前序和中序遍历根节点左边和右边的子树 //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 head-&gt;left=reConstructBinaryTree(left_pre,left_vin); head-&gt;right=reConstructBinaryTree(right_pre,right_vin); return head; &#125;&#125;; Python代码实现12345678910111213141516171819# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None if len(pre) == 1: return TreeNode(pre[0]) else: flag = TreeNode(pre[0]) flag.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1],tin[:tin.index(pre[0])]) flag.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:],tin[tin.index(pre[0])+1:] ) return flag 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：对称的二叉树]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-44%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路我们可以通过比较二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。需要注意的是，我们一定要加上null值得判断，要不然如果一棵树所有结点数值都一样的时候，我们就没办法区分是否对称了。 C++版代码实现123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; return isSymmetrical(pRoot, pRoot); &#125; bool isSymmetrical(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot1 == NULL &amp;&amp; pRoot2 == NULL) return true; if(pRoot1 == NULL || pRoot2 == NULL) return false; if(pRoot1-&gt;val != pRoot2-&gt;val) return false; return isSymmetrical(pRoot1-&gt;left, pRoot2-&gt;right) &amp;&amp; isSymmetrical(pRoot1-&gt;right, pRoot2-&gt;left); &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（树）：按之字形顺序打印二叉树]]></title>
    <url>%2F2017%2F12%2F13%2Foffer-42%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路这道题和上一道《把二叉树打印成多行》的思路是一样的，只不过，我们需要考虑如何来实现奇偶行的不同顺序输出。首先，肯定不能再上一道题的基础上对偶数行进行reverse，那样效率太低，根本不实用。 如果还和上一道题一样用queue（左右结点的遍历顺序稍作更改），我们会发现，对于一个三层的二叉树（1-2-3-4-5-6-7），前两行都没问题，到了第三行，就乱了，无论你怎么更改第二个queue的遍历顺序。原因就在于，我上一行输出的最后一个结点，它的子结点要紧接着作为下一个输出才对，而queue是先进先出，所以你上一行输出的最后一个结点，它的子结点只能在同行中最后输出。 先入先出不行，我们就用先入后出的stack。对于一个三层的二叉树（1-2-3-4-5-6-7），第一个stack压入1，弹出1后第二个stack顺序压入2、3，顺序弹出3（压7、6）、2（压5、4）后第一个stack顺序压入7、6、5、4，顺序弹出4、5、6、7后结束。没毛病。 C++版代码实现1234567891011121314151617181920212223242526272829303132333435363738394041/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(pRoot==NULL) return ret; stack&lt;TreeNode*&gt; s1; stack&lt;TreeNode*&gt; s2; s1.push(pRoot); while(!s1.empty()||!s2.empty())&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; while(!s1.empty())&#123; v1.push_back(s1.top()-&gt;val); if(s1.top()-&gt;left!=NULL) s2.push(s1.top()-&gt;left); if(s1.top()-&gt;right!=NULL) s2.push(s1.top()-&gt;right); s1.pop(); &#125; if(v1.size()!=0) ret.push_back(v1); while(!s2.empty())&#123; v2.push_back(s2.top()-&gt;val); if(s2.top()-&gt;right!=NULL) s1.push(s2.top()-&gt;right); if(s2.top()-&gt;left!=NULL) s1.push(s2.top()-&gt;left); s2.pop(); &#125; if(v2.size()!=0) ret.push_back(v2); &#125; return ret; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间效率）：最小的K个数]]></title>
    <url>%2F2017%2F12%2F12%2Foffer-41%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路一：结合快排。排序后直接for循环将最小的K个数填入结果。时间复杂度O（NlogK）。 思路二：最大堆或者红黑树。我们可以先创建一个大小为K的数据容器来存储最小的k个数字，然后每次从N个整数中读取一个数。如果容器中已有的数字个数少于K，则直接把这次读入的整数放入容器中；如果容器中已经有K个数了，此时我们需要找出容器中的最大值，然后与待插入的整数进行比较，谁小就留着谁。 我们再来捋一遍，容器满了之后我们要做的三件事情：一是在k个证书中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们能在O(logK)时间内实现这三步操作。因此对于N个输入数字而言，总时间效率就是O(Nlogk)。 最大堆：根结点的值总是大于它的子树中任意结点的值。我们需要O(1)时间得到最大值，O(logK)时间来完成删除及插入操作； 红黑树：根据一定规则确保树在一定程度上是平衡的，从而保证在红黑树种查找、删除和插入操作都只需要O(logK)时间。 Python中没有现成的最大堆或者红黑树实现，本渣渣就不再这里折腾了。 C++版代码实现思路一123456789101112131415class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; res; if(input.empty() || k &gt; input.size()) return res; sort(input.begin(), input.end()); for(int i = 0; i &lt; k; ++i) res.push_back(input[i]); return res; &#125;&#125;; 最大堆123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len &lt;= 0 || k &gt; len || k &lt;= 0) return vector&lt;int&gt;(); vector&lt;int&gt; res(input.begin(), input.begin()+k); //建堆 make_heap(res.begin(), res.end()); for(int i=k; i &lt; len; i++) &#123; if(input[i] &lt; res[0]) &#123; //先pop,然后在容器中删除 pop_heap(res.begin(), res.end()); res.pop_back(); //先在容器中加入，再push res.push_back(input[i]); push_heap(res.begin(), res.end()); &#125; &#125; //使其从小到大输出 sort_heap(res.begin(), res.end()); return res; &#125;&#125;; 红黑树1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len &lt;= 0 || k &gt; len || k &lt;= 0) return vector&lt;int&gt;(); //仿函数中的greater&lt;T&gt;模板，从大到小排序 multiset&lt;int, greater&lt;int&gt; &gt; leastNums; vector&lt;int&gt;::iterator vec_it = input.begin(); for(; vec_it != input.end(); vec_it++) &#123; //将前k个元素插入集合 if(leastNums.size() &lt; k) leastNums.insert(*vec_it); else &#123; //第一个元素是最大值 multiset&lt;int, greater&lt;int&gt; &gt;::iterator greatest_it = leastNums.begin(); //如果后续元素&lt;第一个元素，删除第一个，加入当前元素 if(*vec_it &lt; *(leastNums.begin())) &#123; leastNums.erase(greatest_it); leastNums.insert(*vec_it); &#125; &#125; &#125; return vector&lt;int&gt;(leastNums.begin(), leastNums.end()); &#125;&#125;; Python版代码实现思路一1234567891011# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here if tinput is None: return n = len(tinput) if n &lt; k: return [] tinput = sorted(tinput) return tinput[:k] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间效率）：数组中出现次数超过一半的数字]]></title>
    <url>%2F2017%2F12%2F12%2Foffer-39%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路一：结合快排。数组排序后，如果符合条件的数存在，则一定是数组中间那个数。（比如：1，2，2，2，3；或2，2，2，3，4；或2，3，4，4，4等等）这种方法虽然容易理解，但由于涉及到快排sort，其时间复杂度为O(NlogN)并非最优； 思路二：书上的解法，时间复杂度为O(N)。如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。其实和第一个思路差不多，都是利用次数。在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 C++版代码实现思路一123456789101112131415161718class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) return 0; sort(numbers.begin(), numbers.end()); // 排序，取数组中间那个数 int middle = numbers[numbers.size() / 2]; int count=0; // 出现次数 for(int i=0; i &lt; numbers.size(); ++i) &#123; if(numbers[i] == middle) ++count; &#125; return (count &gt; numbers.size()/2) ? middle : 0; &#125;&#125;; 思路二12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) return 0; // 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1 int result = numbers[0]; int times = 1; // 次数 for(int i=1; i &lt; numbers.size(); ++i) &#123; if(times == 0) &#123; // 更新result的值为当前元素，并置次数为1 result = numbers[i]; times = 1; &#125; else if(numbers[i] == result) &#123; ++times; // 相同则加1 &#125; else &#123; --times; // 不同则减1 &#125; &#125; // 判断result是否符合条件，即出现次数大于数组长度的一半 times = 0; for(int i=0; i &lt; numbers.size(); ++i) &#123; if(numbers[i] == result) ++times; &#125; return (times &gt; numbers.size()/2) ? result : 0; &#125;&#125;; Python版代码实现思路一12345678910import collectionsclass Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here tmp = collections.Counter(numbers) x = len(numbers)/2 for k, v in tmp.items(): if v &gt; x: return k return 0 思路二1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 # 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1 result = numbers[0] times = 1 for i in range(len(numbers)): if times == 0: # 更新result的值为当前元素，并置次数为1 result = numbers[i] times = 1 elif numbers[i] == result: times += 1 #相同则加1 else: times -= 1 #不同则减1 # 判断result是否符合条件，即出现次数大于数组长度的一半 times = 0 for i in range(len(numbers)): if numbers[i] == result: times += 1 if times &gt; len(numbers) /2: return result else: return 0 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间效率）：整数中1出现的次数（从1到n整数中1出现的次数）]]></title>
    <url>%2F2017%2F12%2F12%2Foffer-40%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 解题思路两种方法，一种是从1到n遍历，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断。我们对每个数字都要做除法和求余运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 第二种方法是数学之美上面提出的方法，设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。 根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i 当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1 当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a/10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a/10*100）+(b+1)，这些点百位对应为1 当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30） 综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1 之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1) C++版代码实现方法一123456789101112131415161718class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int count=0; for(int i=0; i &lt;= n; ++i) &#123; int temp = i; while(temp) &#123; if(temp % 10 == 1) ++count; temp /= 10; &#125; &#125; return count; &#125;&#125;; 方法二123456789101112131415class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; long long i = 1; for(i = 1; i &lt;= n; i *= 10) &#123; //i表示当前分析的是哪一个数位 int a = n / i, b = n % i; count = count + (a + 8) / 10 * i + (a % 10 == 1) * (b + 1); &#125; return count; &#125;&#125;; Python版代码实现方法一123456789101112# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here count = 0 for i in range(0,n+1): temp = i while temp: if temp % 10 == 1: count += 1 temp /= 10 return count 方法二12345678910# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here count = 0 i = 1 while i &lt;= n: count += (n // i + 8) // 10 * i + (n // i % 10 == 1) * (n % i + 1) i *= 10 return count 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间效率）：把数组排成最小的数]]></title>
    <url>%2F2017%2F12%2F12%2Foffer-37%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。 排序规则如下： 若ab &gt; ba 则 a 大于 b， 若ab &lt; ba 则 a 小于 b， 若ab = ba 则 a 等于 b； 根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。 C++版代码实现123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; int len = numbers.size(); if(len == 0) return ""; sort(numbers.begin(), numbers.end(),cmp); string res; for(int i=0; i &lt; len; ++i) res += to_string(numbers[i]); return res; &#125; static bool cmp(int a, int b)&#123; string A = to_string(a) + to_string(b); string B = to_string(b) + to_string(a); return A &lt; B; &#125;&#125;; Python版代码实现123456789# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if not numbers: return "" compare = lambda a, b:cmp(str(a) + str(b), str(b) + str(a)) cur = sorted(numbers, cmp = compare) return "".join(str(s) for s in cur) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间效率）：连续子数组的最大和]]></title>
    <url>%2F2017%2F12%2F12%2Foffer-38%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 解题思路和leetcode里面的股票题目很像。看到这个题目，如果我们枚举出数组的所有子数组并求出他们的和。一个长度为n的数组，总共有n(n+1)/2个子数组。计算出所有的子数组的和，最快也需要O(n^2)的时间。运用数组分析或者动态规划则可以实现时间复杂度为O(n)，但是二者在本题的实现上是一样的。 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 动态规划：如果用函数f(i)表示第i个数字结尾的子数组的最大和，那么我们需要求出man[f(i)]，其中0&lt;=i&lt;=n。我们可以用如下递归公式求f(i)： 当以第i-个数字结尾的子数组中的所有数字的和小于0时，如果把这个负数与第i个数累加，得到的结果比第i个数字本身还要小，所以这种情况下第i个数字结尾的字数子就是第i个数字本身。否则，累加。 C++版代码实现1234567891011121314151617181920class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) return 0; //初始值最好不要设置为0，防止全是负数的情况出现 int nCurSum = array[0]; int nGreatestSum = array[0]; //从1开始遍历 for(int i=1; i &lt; array.size(); ++i)&#123; if(nCurSum &lt;= 0) nCurSum = array[i]; else nCurSum += array[i]; if(nCurSum &gt; nGreatestSum) nGreatestSum = nCurSum; &#125; return nGreatestSum; &#125;&#125;; Python版代码实现123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 #初始值最好不要设置为0，防止全是负数的情况出现 nCurSum = nGreatestSum = array[0] #从1开始遍历 for i in range(1,len(array)): if nCurSum &lt;= 0: nCurSum = array[i] else: nCurSum += array[i] if nCurSum &gt; nGreatestSum: nGreatestSum = nCurSum return nGreatestSum 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间空间效率的平衡）：第一个只出现一次的字符]]></title>
    <url>%2F2017%2F12%2F11%2Foffer-34%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 解题思路我们首先想到的可能就是遍历数组，对每一个字符串再遍历判断是否唯一，这样的时间复杂度为O(n^2)。这显然不是我们想要的。 然后我们可能会想到，为什么不用hash表呢？首先遍历数组建立hash表，key为字符串，value为该字符串出现的次数。然后再遍历hash，找到里面value为1的key就可以了。 C++中，我们可以用数组实现，此时，数组长度设定为256，对应字符串的ASCII码；也可以用map实现。Python中，我们可以用字典实现，但是很耗空间。 C++版代码实现数组123456789101112131415class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; if(str.size() == 0) return -1; char ch[256] = &#123;0&#125;; for(int i=0; i &lt; str.size(); ++i) ch[str[i]]++; for(int i=0; i &lt; str.size(); ++i)&#123; if(ch[str[i]] == 1) return i; &#125; return 0; &#125;&#125;; map123456789101112131415class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; if(str.size() == 0) return -1; map&lt;char, char&gt; mp; for(int i=0; i &lt; str.size(); ++i) mp[str[i]]++; for(int i=0; i &lt; str.size(); ++i)&#123; if(mp[str[i]] == 1) return i; &#125; return 0; &#125;&#125;; Python版代码实现12345678910111213141516# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if len(s) == 0: return -1 cur = &#123;&#125; for i in range(len(s)): if s[i] not in cur.keys(): cur[s[i]] = 1 else: cur[s[i]] += 1 for i in range(len(s)): if cur[s[i]] == 1: return i return 0 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（面试思路）：二叉树的镜像]]></title>
    <url>%2F2017%2F12%2F11%2Foffer-32%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 123456789101112源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路还是BFS和DFS的套路，要么递归实现要么利用队列进行层序遍历。 C++版代码实现递归12345678910111213141516171819/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(pRoot)&#123; swap(pRoot-&gt;left, pRoot-&gt;right); Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125; &#125;&#125;; 层序遍历12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(!pRoot) return; TreeNode* node; queue&lt;TreeNode*&gt; que; que.push(pRoot); while(!que.empty())&#123; node = que.front(); que.pop(); swap(node-&gt;left, node-&gt;right); if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; &#125;&#125;; Python版代码实现递归1234567891011121314# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if root != None: root.left,root.right = root.right,root.left self.Mirror(root.left) self.Mirror(root.right) 层序遍历123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return a=[root] while a: b=[] for node in a: node.left,node.right = node.right,node.left if node.left: b.append(node.left) if node.right: b.append(node.right) a=b 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>面试思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间空间效率的平衡）：两个链表的第一个公共结点]]></title>
    <url>%2F2017%2F12%2F11%2Foffer-35%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入两个链表，找出它们的第一个公共结点。 解题思路我们一定要理解题目：输入两个链表，找出它们的第一个公共结点。从链表结点的定义可以看出，这两个链表是单向链表。如果两个单向链表有公共的结点，那么这两个链表从某一个结点开始，他妈嗯的next都指向同一个结点。但是，我们都知道，每个单向链表的结点只有一个next，因此，因此，因此，敲重点了，从第一个公共结点开始，之后他们所有的结点必定重合，也就是最终肯定是Y型而不是X型。 理解了题目，接下来的一切都好说了。 方法一： 我们可以把两个链表拼接起来，一个pHead1在前，一个pHead2在前，这样，生成了两个相同长度的链表，那么我们只要一同遍历这两个表，就一定能找到公共结点。时间复杂度O(m+n)，空间复杂度O(m+n)。 方法二： 我们也可以先让把长的链表的头砍掉，让两个链表长度相同，这样，同时遍历也能找到公共结点。此时，时间复杂度O(m+n)，空间复杂度为O(MAX(m,n))。 C++版代码实现简单粗暴1234567891011121314151617181920/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; ListNode *p1 = pHead1; ListNode *p2 = pHead2; while(p1!=p2)&#123; p1 = (p1==NULL ? pHead2 : p1-&gt;next); p2 = (p2==NULL ? pHead1 : p2-&gt;next); &#125; return p1; &#125;&#125;; 节省空间12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; unsigned int len1 = getLength(pHead1); unsigned int len2 = getLength(pHead2); int nLengthDif = len1-len2; ListNode* pHeadLong = pHead1; ListNode* pHeadShort = pHead2; if(len1 &lt; len2)&#123; pHeadLong = pHead2; pHeadShort = pHead1; nLengthDif = len2-len1; &#125; for(int i = 0; i &lt; nLengthDif; ++i)&#123; pHeadLong = pHeadLong-&gt;next; &#125; while(pHeadLong != NULL &amp;&amp; pHeadShort != NULL &amp;&amp; pHeadShort != pHeadLong)&#123; pHeadLong = pHeadLong-&gt;next; pHeadShort = pHeadShort-&gt;next; &#125; return pHeadLong; &#125; unsigned int getLength( ListNode* pHead)&#123; unsigned int len = 0; ListNode* pNode = pHead; while(pNode != NULL)&#123; ++ len; pNode = pNode-&gt;next; &#125; return len; &#125;&#125;; Python版代码实现简单粗暴1234567891011121314# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here p1 = pHead1 p2 = pHead2 while p1!=p2: p1 = p1.next if p1!=None else pHead2 p2 = p2.next if p2!=None else pHead1 return p1 节省空间12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here def GetListLength(pHead): length = 0 pNode = pHead while pNode != None: length += 1 pNode = pNode.next return length length1 = GetListLength(pHead1) length2 = GetListLength(pHead2) lengthDif = abs(length1 - length2) pListHeadLong = pHead1 pListHeadShort = pHead2 if length1 &lt; length2: pListHeadLong = pHead2 pListHeadShort = pHead1 for i in range(lengthDif): pListHeadLong = pListHeadLong.next while (pListHeadLong != None) and (pListHeadShort != None) and (pListHeadLong != pListHeadShort): pListHeadLong = pListHeadLong.next pListHeadShort = pListHeadShort.next return pListHeadLong 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间空间效率的平衡）：丑数]]></title>
    <url>%2F2017%2F12%2F11%2Foffer-33%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路同样的，我们首先想到的可能就是遍历判断，但是每个数都要计算一次是不是ugly，很是麻烦。于是我们想，能不能只对ugly进行计算呢，显然是可以的。 我们用一个数组来从小到大存放ugly，那现在的问题就是排序问题了，我们如何来保障这里面的数组是排好序的呢？ 我们把当前数组里面最大的ugly记为M，那么，下一个ugly肯定是前面的数与2或者3或者5的乘积中的最小值。然后我们拿这个最小值和M进行比较，如果小于M，就说明已经存在于数组中，如果大于M，则说明需要添加进数组。需要注意的是，我们每次判断之后，我们只需要第一个比M大的值，其他的以后会重新计算。程序中通过t2、t3、t5分别记录上次计算用到的ugly的相应序号。 比如现在res中存放的是[1,2,3]，此时，t2、t3都为1，t5为0，min(res[1] 2, min(res[1] 3, res[1] * 5)) 结果为4，res变为[1,2,3,4]，判断后t2变成2，以此类推。 因为7之前的数（7除外）都是ugly，所以程序一开始的判断可以和i直接写index &lt; 7。 C++版代码实现1234567891011121314151617181920class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt; 7) return index; vector&lt;int&gt; res(index); res[0] = 1; int t2=0, t3=0, t5=0; for(int i=1; i &lt; index; ++i)&#123; res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5)); if(res[i] == res[t2] * 2) t2++; if(res[i] == res[t3] * 3) t3++; if(res[i] == res[t5] * 5) t5++; &#125; return res[index - 1]; &#125;&#125;; Python版代码实现1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt; 7: return index; res = [1] t2 = t3 = t5 = 0 for i in range(1,index): res.append(min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5))) if res[i] == res[t2] * 2: t2 += 1 if res[i] == res[t3] * 3: t3 += 1 if res[i] == res[t5] * 5: t5 += 1 return res[-1] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（时间空间效率的平衡）：数组中的逆序对]]></title>
    <url>%2F2017%2F12%2F11%2Foffer-36%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例输入 11,2,3,4,5,6,7,0 输出 17 解题思路看到这个题目，首先想到的可能是顺序遍历整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿它和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。 把长度为4的数组分解成两个长度为2的子数组； 把长度为2的数组分解成两个成都为1的子数组； 把长度为1的子数组 合并、排序并统计逆序对 ； 把长度为2的子数组合并、排序，并统计逆序对； 在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。 接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。 我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。 过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; if(data.size() == 0) return 0; vector&lt;int&gt; copy; for(int i=0; i &lt; data.size(); ++i) copy.push_back(data[i]); return InversePairsCore(copy, data, 0, data.size() - 1)%1000000007; &#125; long InversePairsCore(vector&lt;int&gt; &amp;data, vector&lt;int&gt; &amp;copy, int begin, int end)&#123; if(begin == end)&#123; copy[begin] = data[end]; return 0; &#125; int length = (end-begin)/2; long left = InversePairsCore(copy, data, begin, begin + length); long right = InversePairsCore(copy, data, begin + length + 1, end); int i = begin + length; int j = end; int indexcopy = end; long count = 0; while(i &gt;= begin &amp;&amp; j &gt;= begin+length+1)&#123; if(data[i] &gt; data[j])&#123; copy[indexcopy--] = data[i--]; count = count + j - begin - length; &#125; else copy[indexcopy--] = data[j--]; &#125; for(;i&gt;= begin; --i) copy[indexcopy--] = data[i]; for(;j&gt;=begin+length+1; --j) copy[indexcopy--] = data[j]; return left + right + count; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（链表）：删除链表中重复的结点]]></title>
    <url>%2F2017%2F12%2F10%2Foffer-31%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 解题思路删除重复结点，只需要记录当前结点前的最晚访问过的不重复结点pPre、当前结点pCur、指向当前结点后面的结点pNext的三个指针即可。如果当前节点和它后面的几个结点数值相同，那么这些结点都要被剔除，然后更新pPre和pCur；如果不相同，则直接更新pPre和pCur。 需要考虑的是，如果第一个结点是重复结点我们该怎么办？这里我们分别处理一下就好，如果第一个结点是重复结点，那么久把头指针也更新一下。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if(pHead == NULL) return NULL; ListNode* pPre = NULL; //指向当前结点前最晚访问过的不重复结点 ListNode* pCur = pHead; //指向当前处理的结点 ListNode* pNext = NULL; //指向当前结点后面的结点 while(pCur != NULL)&#123; //如果当前结点与下一结点值相同，则进一步处理 if(pCur-&gt;next != NULL &amp;&amp; pCur-&gt;next-&gt;val == pCur-&gt;val)&#123; pNext = pCur-&gt;next; //找到pNext，它指向最后一个与pCur的val相同的结点，那pCur到pNext之间的结点都是要删除的 while(pNext-&gt;next != NULL &amp;&amp; pNext-&gt;next-&gt;val == pCur-&gt;val) pNext = pNext-&gt;next; //如果pCur指向链表中第一个元素，pCur -&gt; ... -&gt; pNext -&gt;... , 要删除pCur到pNext, 将指向链表第一个元素的指针pHead指向pNext-&gt;next。 if(pCur == pHead) pHead = pNext-&gt;next; //如果pCur不指向链表中第一个元素，pPre -&gt; pCur -&gt;...-&gt;pNext -&gt;... ，要删除pCur到pNext，即pPre-&gt;next = pNext-&gt;next else pPre-&gt;next = pNext-&gt;next; //当前处理的p要向链表尾部移动 pCur = pNext-&gt;next; &#125; //如果当前结点与下一结点值不同，更新pPre和pCur。 else&#123; pPre = pCur; pCur = pCur-&gt;next; &#125; &#125; return pHead; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（链表）：从尾到头打印链表]]></title>
    <url>%2F2017%2F12%2F10%2Foffer-29%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言链表应该是面试被提及最频繁的数据结构。链表的创建、插入节点、删除结点等操作都只需要20行左右的代码就能实现，其代码量比较适合面试。 在创建链表时，无需知道链表的长度，当插入一个结点时，我们只需要为新结点分配内存，然后调整指针的指向来确保新节点被链接到链表当中。内存分配不是在创建链表时一次性完成，而是没添加一个结点分配一次内存。由于没有闲置的内存，链表的空间效率比数组好。 题目描述输入一个链表，从尾到头打印链表每个节点的值。 解题思路直接修改输入数据如果可以修改原来链表的结构，那么把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。 但是，打印通常是一个只读操作，我们不希望打印时修改内容，所以就得想别的办法。 循环后进先出，我们可以用栈实现这种顺序。没经过一个结点的时候，把该节点放到一个栈里面，当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。 递归递归在本质上就是一个栈结构，于是很自然地又想到了用递归来实现。每访问到一个结点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。 C++代码实现循环123456789101112131415161718192021222324252627/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; result; stack&lt;int&gt; nodes; ListNode* pNode = head; while(pNode != NULL)&#123; nodes.push(pNode-&gt;val); pNode = pNode-&gt;next; &#125; while(!nodes.empty())&#123; result.push_back(nodes.top()); nodes.pop(); &#125; return result; &#125;&#125;; 递归123456789101112131415161718192021222324252627/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; value; if(head != NULL) &#123; value.insert(value.begin(),head-&gt;val); if(head-&gt;next != NULL) &#123; vector&lt;int&gt; tempVec = printListFromTailToHead(head-&gt;next); if(tempVec.size()&gt;0) value.insert(value.begin(),tempVec.begin(),tempVec.end()); &#125; &#125; return value; &#125;&#125;; Python代码实现python的实现依旧是那么简单，一直往列表头放数据就好。 12345678910111213141516# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here l = [] head = listNode while head: l.insert(0, head.val) head = head.next return l 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（链表）：链表中环的入口结点]]></title>
    <url>%2F2017%2F12%2F10%2Foffer-30%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述一个链表中包含环，请找出该链表的环的入口结点。 解题思路我们可以用两个指针来解决此类问题。如果链表中的环有n个结点，指针P1先在链表上向前移动n步，然后两个指针以相同的速度向前移动。当第二个指针指向环的入口结点时，第一个指针已经环绕着环走了一圈又回到了入口结点。如下图所示： 那我们接下来要考虑的就是如何获取这个环的结点个数n了。我们可以用快慢指针来实现，如果两个指针相遇，表明链表存在环。两个指针相遇的结点一定是在环中。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* MeetingNode(ListNode* pHead)&#123; if(pHead == NULL) return NULL; ListNode* pSlow = pHead-&gt;next; if(pSlow == NULL) return NULL; ListNode* pFast = pSlow-&gt;next; while(pFast != NULL &amp;&amp; pSlow != NULL)&#123; if(pFast == pSlow) return pFast; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next; if(pFast-&gt;next != NULL) pFast = pFast-&gt;next; &#125; return NULL; &#125; ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; ListNode* meetingNode = MeetingNode(pHead); if(meetingNode == NULL) return NULL; // 得到环中结点的数目 int nodesInLoop = 1; ListNode* pNode1 = meetingNode; while(pNode1-&gt;next != meetingNode)&#123; pNode1 = pNode1-&gt;next; ++nodesInLoop; &#125; // 先移动pNode1，次数为环中结点的数目 pNode1 = pHead; for(int i=0; i &lt; nodesInLoop; ++i) pNode1 = pNode1-&gt;next; // 再移动pNode1和pNode2 ListNode* pNode2 = pHead; while(pNode1 != pNode2)&#123; pNode1 = pNode1-&gt;next; pNode2 = pNode2-&gt;next; &#125; return pNode1; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（举例让抽象具体化）：二叉搜索树的后序遍历序列]]></title>
    <url>%2F2017%2F12%2F09%2Foffer-27%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言：当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。 题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路深度优先遍历中的先序遍历、中序遍历、后序遍历，都是针对在遍历中根结点的位置来命名的，先序遍历，第一个元素是根结点，后序遍历，最后一个元素是根结点。 二叉搜索树中，在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，他们都比根节点的值小；第二部分是右子树结点的值，他们都比根结点的值大。 递归循环都可以实现。 C++版代码实现递归123456789101112131415161718192021222324252627282930class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; return bst(sequence,0,sequence.size()-1); &#125; bool bst(vector&lt;int&gt; sequence,int begin,int end)&#123; if(sequence.empty()||begin&gt;end) return false; //获取根节点，后序遍历最后一个元素就是根节点 int root = sequence[end]; //在二叉树搜索树中左子树的结点小于根节点 int i = begin; for(; i &lt; end; ++i) if(sequence[i] &gt; root) break; //在二叉搜索树中右子树的节点大于根节点 for(int j = i; j &lt; end; ++j) if(sequence[j] &lt; root) return false; //判断左子树是不是二叉搜索树 bool left = true; if(i &gt; begin) left = bst(sequence, begin, i-1); //判断右子树是不是二叉搜索树 bool right=true; if(i &lt; end - 1) right = bst(sequence, i, end-1); return left &amp;&amp; right; &#125;&#125;; 循环12345678910111213141516171819class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; int length = sequence.size(); if(length == 0) return false; int i = 0; while(--length) &#123; while(sequence[i++] &lt; sequence[length]); while(sequence[i++] &gt; sequence[length]); if(i &lt; length) return false; i = 0; &#125; return true; &#125;&#125;; Python版代码实现递归12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False if len(sequence) == 1: return True length=len(sequence) # 获取根节点，后序遍历最后一个元素就是根节点 root=sequence[-1] # 在二叉树搜索树中左子树的结点小于根节点 i=0 while sequence[i] &lt; root: i=i+1 # 在二叉搜索树中右子树的节点大于根节点 k=i for j in range(i, length-1): if sequence[j] &lt; root: return False left_s = sequence[:k] right_s = sequence[k:length-1] # 判断左子树是不是二叉搜索树 leftIs = True if len(left_s) &gt; 0: leftIs = self.VerifySquenceOfBST(left_s) # 判断右子树是不是二叉搜索树 rightIs = True if len(right_s) &gt; 0: rightIs = self.VerifySquenceOfBST(right_s) return leftIs and rightIs 循环1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False if len(sequence)==1: return True i = 0 length=len(sequence) while length: length -= 1 while sequence[i] &lt; sequence[length]: i += 1 while sequence[i] &gt; sequence[length]: i += 1 if i &lt; length: return False i = 0 return True 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（举例让抽象具体化）：从上往下打印二叉树]]></title>
    <url>%2F2017%2F12%2F09%2Foffer-25%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言：当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。 题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路再熟悉不过的层序遍历，BFS即可实现。用队列来进行层序遍历，同时用一个vector容器来存储每一层的值。 举例如下： C++版代码实现123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; result; queue&lt;TreeNode*&gt; que; TreeNode* fr; if(root == NULL) return result; que.push(root); while(!que.empty())&#123; fr = que.front(); result.push_back(fr-&gt;val); if(fr-&gt;left != NULL) que.push(fr-&gt;left); if(fr-&gt;right != NULL) que.push(fr-&gt;right); que.pop(); &#125; return result; &#125;&#125;; Python版代码实现1234567891011121314151617181920212223# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here result=[] if not root: return [] que=[] que.append(root) while len(que): t=que.pop(0) result.append(t.val) if t.left: que.append(t.left) if t.right: que.append(t.right) return result 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（举例让抽象具体化）：包含min函数的栈]]></title>
    <url>%2F2017%2F12%2F09%2Foffer-24%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言：当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。 题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 解题思路我们很自然的可以想到，可以利用两个栈来实现该操作：一个栈sData用来存放数据，另一个栈sMin用来辅助更新最小值状态。 栈内压入3、4、2、1之后接连两次弹出栈顶数字之后再压入0时，数据栈、辅助栈和最小值状态举例如图所示： C++版代码实现123456789101112131415161718192021222324class Solution &#123;public: void push(int value) &#123; sData.push(value); if(sMin.empty()) sMin.push(value); if(sMin.top() &gt; value) sMin.push(value); &#125; void pop() &#123; if(sData.top() == sMin.top()) sMin.pop(); sData.pop(); &#125; int top() &#123; return sData.top(); &#125; int min() &#123; return sMin.top(); &#125;private: stack&lt;int&gt; sData; stack&lt;int&gt; sMin;&#125;; Python版代码实现1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def __init__(self): self.sData = [] self.sMin = [] def push(self, node): # write code here self.sData.append(node) if len(self.sMin) == 0: self.sMin.append(node) if self.sMin[-1] &gt; node: self.sMin.append(node) def pop(self): # write code here if self.sData[-1] == self.sMin[-1]: self.sMin.pop() self.sData.pop() def top(self): # write code here return self.sData[-1] def min(self): # write code here return self.sMin[-1] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（举例让抽象具体化）：栈的压入、弹出序列]]></title>
    <url>%2F2017%2F12%2F09%2Foffer-28%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言：当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。 题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 下面给出例子中的示意图： C++版代码实现12345678910111213141516class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if(pushV.size() == 0) return false; vector&lt;int&gt; stackData; for(int i = 0, j = 0; i &lt; pushV.size();)&#123; stackData.push_back(pushV[i++]); while(j &lt; popV.size() &amp;&amp; stackData.back() == popV[j])&#123; stackData.pop_back(); j++; &#125; &#125; return stackData.empty(); &#125;&#125;; Python版代码实现123456789101112131415# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here if len(pushV) == 0: return False stackData = [] for i in pushV: stackData.append(i) while len(stackData) and stackData[-1] == popV[0]: stackData.pop() popV.pop(0) if len(stackData): return False return True 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（举例让抽象具体化）：二叉树中和为某一值的路径]]></title>
    <url>%2F2017%2F12%2F09%2Foffer-26%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言：当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。 题目描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 解题思路还是深度优先搜索，这次我们用前序遍历，就是先对root做一些该有的处理，再遍历左右子树。这里我们用到两个全局变量，result来存放最终结果，tmp用来存放临时结果。 每次遍历，我们先把root的值压入tmp，然后判断现有root是否同时满足： 与给定数值相减为0； 左子树为空； 右子树为空。 如果满足条件，就将tmp压入result中，否则，依次遍历左右子树。需要注意的是，遍历左右子树的时候，全局变量tmp是不清空的，直到到了根结点才请空tmp。 C++版代码实现递归12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; if(root == NULL) return result; tmp.push_back(root-&gt;val); if((expectNumber - root-&gt;val) == 0 &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) result.push_back(tmp); FindPath(root-&gt;left, expectNumber-root-&gt;val); FindPath(root-&gt;right, expectNumber-root-&gt;val); tmp.pop_back(); return result; &#125;&#125;; Python版代码实现递归1234567891011121314151617181920# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] if root and not root.left and not root.right and root.val == expectNumber: return [[root.val]] res = [] left = self.FindPath(root.left, expectNumber-root.val) right = self.FindPath(root.right, expectNumber-root.val) for i in left+right: res.append([root.val]+i) return res 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（回溯法）：机器人的运动范围]]></title>
    <url>%2F2017%2F12%2F08%2Foffer-22%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 C++版代码实现123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; bool* visited = new bool[rows * cols]; for(int i = 0; i &lt; rows * cols; i++) visited[i] = false; int count = movingCountCore(threshold, rows, cols, 0, 0, visited); delete[] visited; return count; &#125; int movingCountCore(int threshold, int rows, int cols, int row, int col, bool* visited)&#123; int count = 0; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold &amp;&amp; !visited[row * cols + col])&#123; visited[row * cols + col] = true; count = 1 + movingCountCore(threshold, rows, cols, row+1, col, visited) + movingCountCore(threshold, rows, cols, row-1, col, visited) + movingCountCore(threshold, rows, cols, row, col+1, visited) + movingCountCore(threshold, rows, cols, row, col-1, visited); &#125; return count; &#125; int getDigitSum(int number)&#123; int sum = 0; while(number)&#123; sum += number % 10; number /= 10; &#125; return sum; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（回溯法）：矩阵中的路径]]></title>
    <url>%2F2017%2F12%2F08%2Foffer-23%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这个题其实让我想到了图的一些操作。这是一个可以用回溯法解决的典型题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置（此时str[pathLength] == ‘\0’）。 C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if(matrix == NULL || rows &lt; 1 || cols &lt; 1 || str == NULL) return false; bool * visited = new bool[rows*cols]; memset(visited, 0, rows * cols); int pathLength = 0; for(int row = 0; row &lt; rows; ++row)&#123; for(int col = 0; col &lt; cols; ++col)&#123; if(hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited)) return true; &#125; &#125; delete[] visited; return false; &#125; bool hasPathCore(char*matrix, int rows, int cols, int row, int col, char* str, int&amp; pathLength, bool* visited)&#123; if(str[pathLength] == '\0') return true; bool hasPath = false; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; cols &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] == str[pathLength] &amp;&amp; !visited[row * cols + col])&#123; ++pathLength; visited[row * cols + col] = true; hasPath = hasPathCore(matrix, rows, cols, row-1, col, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row+1, col, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col-1, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col+1, str, pathLength, visited); if(!hasPath)&#123; --pathLength; visited[row * cols + col] = false; &#125; &#125; return hasPath; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（分解让复杂问题简单）：二叉搜索树与双向链表]]></title>
    <url>%2F2017%2F12%2F07%2Foffer-18%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。 题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路哇偶，中序遍历啊！中序遍历，递归和循环都可以撒~ 二叉搜索树是一种排序的数据结构，每个结点都有两个指向子结点的指针。在双向链表中，每个结点也有两个指针，他们分别指向前一个结点和后一个结点。在二叉搜索树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点指针。 中序遍历在二叉搜索树中的特点是按照从小到大的顺序遍历二叉树的每一个结点。下图中，我们可以把树分成三个部分：值为10的结点、根结点为6的左子树、根结点为14的右子树。根绝排序链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 按照中序遍历的顺序，当我们遍历转换到根结点时，它的左子树已经转换成一个排序的链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个借点，接着我们就去遍历转换右子树，并把根结点和右子树中最小的结点链接起来。 下面个分别用C/C++和Python来实现，其中递归1是书中的解法，递归2是更加容易理解的解法，原理都是一样的，只不过递归1中涉及到指针的指针，容易把自己搞蒙。 C++版代码实现递归112345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode *pLastNodeInList = NULL; ConvertNode(pRootOfTree, &amp;pLastNodeInList); //需要返回头结点，所以需要遍历到头结点（最左子叶） TreeNode *pHeadOfList = pLastNodeInList; while(pHeadOfList != NULL &amp;&amp; pHeadOfList-&gt;left != NULL) pHeadOfList = pHeadOfList-&gt;left; return pHeadOfList; &#125; void ConvertNode(TreeNode* pNode, TreeNode** pLastNodeInList)&#123; if(pNode == NULL) return; TreeNode* pCurrent = pNode; //递归左子树 if(pCurrent-&gt;left != NULL) ConvertNode(pCurrent-&gt;left, pLastNodeInList); //处理指针 pCurrent-&gt;left = *pLastNodeInList; if(*pLastNodeInList != NULL) (*pLastNodeInList)-&gt;right = pCurrent; *pLastNodeInList = pCurrent; //递归右子树 if(pCurrent-&gt;right != NULL) ConvertNode(pCurrent-&gt;right, pLastNodeInList); &#125;&#125;; 递归2123456789101112131415161718192021222324252627282930313233343536373839/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(pRootOfTree == NULL) return NULL; if(pRootOfTree-&gt;left == NULL &amp;&amp; pRootOfTree-&gt;right == NULL) return pRootOfTree; //遍历左子树 TreeNode* pLeft = Convert(pRootOfTree-&gt;left); TreeNode* pCurrent = pLeft; //定位至左子树最右的一个结点 while(pCurrent != NULL &amp;&amp; pCurrent-&gt;right != NULL) pCurrent = pCurrent-&gt;right; //如果左子树不为空，则将当前pRootOfTree加到左子树链表 if(pLeft != NULL)&#123; pCurrent-&gt;right = pRootOfTree; pRootOfTree-&gt;left = pCurrent; &#125; //遍历右子树 TreeNode* pRight = Convert(pRootOfTree-&gt;right); //如果右子树不为空，则将当前pRootOfTree加到右子树链表 if(pRight != NULL)&#123; pRight-&gt;left = pRootOfTree; pRootOfTree-&gt;right= pRight; &#125; return pLeft != NULL?pLeft:pRootOfTree; &#125;&#125;; 循环123456789101112131415161718192021222324252627282930313233343536373839/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; stack&lt;TreeNode*&gt; s; TreeNode* pHeadOfList = NULL; TreeNode* pLastNodeInList = NULL; TreeNode* pCurrent = pRootOfTree; while(pCurrent != NULL || !s.empty())&#123; while(pCurrent != NULL)&#123; s.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; if(!s.empty())&#123; pCurrent = s.top(); s.pop(); if(pLastNodeInList != NULL)&#123; pLastNodeInList-&gt;right = pCurrent; pCurrent-&gt;left = pLastNodeInList; &#125; //如果为空，则说明是最左边子结点，未来的头结点 else pHeadOfList = pCurrent; pLastNodeInList = pCurrent; pCurrent = pCurrent-&gt;right; &#125; &#125; return pHeadOfList; &#125;&#125;; Python版代码实现递归12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return None if not pRootOfTree.left and not pRootOfTree.right: return pRootOfTree #遍历左子树 pLeft = self.Convert(pRootOfTree.left) pCurrent = pLeft #定位至左子树最右的一个结点 while pCurrent and pCurrent.right: pCurrent = pCurrent.right #如果左子树不为空，则将当前pRootOfTree加到左子树链表 if pLeft: pCurrent.right = pRootOfTree pRootOfTree.left = pCurrent #遍历右子树 pRight = self.Convert(pRootOfTree.right) #如果右子树不为空，则将当前pRootOfTree加到右子树链表 if pRight: pRight.left = pRootOfTree pRootOfTree.right = pRight return pLeft if pLeft else pRootOfTree 循环123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Convert(self, pRootOfTree): # write code here s = [] pCurrent = pRootOfTree pHeadOfList = None pLastNodeInList = None while pCurrent or s: while pCurrent: s.append(pCurrent) pCurrent = pCurrent.left if s: pCurrent = s.pop() if pLastNodeInList: pLastNodeInList.right = pCurrent pCurrent.left = pLastNodeInList else: pHeadOfList = pCurrent pLastNodeInList = pCurrent pCurrent = pCurrent.right return pHeadOfList 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（分解让复杂问题简单）：字符串的排列]]></title>
    <url>%2F2017%2F12%2F07%2Foffer-20%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。 题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路全排列，我们很快就想到递归。 首先，我们把一个字符串看成两部分组成：第一部分为它的第一个字符，第二部分为后面的所有字符。首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面的所有字符的排列。这个时候我们仍然把后面所有的字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。 典型的递归思想，下面分别用C/C++和python实现，python还是那么的简单暴力。 C++版代码实现1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; result; vector&lt;string&gt; Permutation(string str) &#123; if(str.length() == 0) return result; Permutation1(str, 0); sort(result.begin(), result.end()); return result; &#125; void Permutation1(string str, int begin)&#123; if(begin == str.length())&#123; result.push_back(str); return; &#125; for(int i=begin; str[i] != '\0'; ++i)&#123; //如果有重复的，交换没什么卵用，所以直接跳过，其实这段话不加也行 if(i != begin &amp;&amp; str[begin] == str[i]) continue; //交换 swap(str[begin], str[i]); //递归 Permutation1(str, begin+1); //复位 swap(str[begin], str[i]); &#125; &#125;&#125;; Python版代码实现123456789101112# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Convert(self, pRootOfTree): # write code here if not ss: return [] return sorted(list(set(map(''.join, itertools.permutations(ss))))) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（画图让抽象形象化）：顺时针打印矩阵]]></title>
    <url>%2F2017%2F12%2F07%2Foffer-21%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路这个题完全没有涉及复杂的数据结构或者高级的算法，看起来是一个很简单的问题。但实际上解决这个问题，会在代码中包含多个循环，并且还需要判断多个边界条件。 顺时针打印就是按圈数循环打印，一圈包含两行两列（完整圆），在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况。 首先是while循环的终止条件：left &lt;= right &amp;&amp; top &lt;= bottom。相信这个条件大家很容易就能理解。 接下来是后两个for循环的终止条件，因为到了最后一个圆的时候，这个圆可能不是一个完整的圆了，所以需要加入判断，以防止打印重复的行或者列。 C++版代码实现123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int row = matrix.size();//行数 int col = matrix[0].size();//列数 vector&lt;int&gt; result; if(row == 0 &amp;&amp; col == 0) return result; int left = 0, right = col - 1, top = 0, bottom = row - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; //left&gt;&gt;right for(int i = left; i &lt;= right; ++i) result.push_back(matrix[top][i]); //top&gt;&gt;bottom for(int i = top+1; i &lt;= bottom; ++i) result.push_back(matrix[i][right]); //right&gt;&gt;left if(top != bottom) for(int i = right-1; i &gt;= left; --i) result.push_back(matrix[bottom][i]); //bottom&gt;&gt;top if(left != right) for(int i = bottom-1; i &gt; top; --i) result.push_back(matrix[i][left]); left++,top++,right--,bottom--; &#125; return result; &#125;&#125;; Python版代码实现递归1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here row = len(matrix) col = len(matrix[0]) result = [] if row == 0 and col == 0: return result left = 0; right = col-1; top = 0; bottom = row-1; while left &lt;= right and top &lt;= bottom: for i in xrange(left, right+1): result.append(matrix[top][i]) for i in xrange(top+1, bottom+1): result.append(matrix[i][right]) if top is not bottom: for i in xrange(right-1, left-1, -1): result.append(matrix[bottom][i]) if left is not right: for i in xrange(bottom-1, top, -1): result.append(matrix[i][left]) left += 1;top += 1;right -= 1;bottom -= 1; return result 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>画图让抽象形象化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（分解让复杂问题简单）：复杂链表的复制]]></title>
    <url>%2F2017%2F12%2F07%2Foffer-19%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。 题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们可以将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。 大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。 我们这里采用三步走战略，也是剑指offer上推崇的方法： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。 有图思路更清晰： C++版代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: //第一步，复制复杂指针的label和next void CloneNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; while(pNode != NULL)&#123; RandomListNode* pCloned = new RandomListNode(0); pCloned-&gt;label = pNode-&gt;label; pCloned-&gt;next = pNode-&gt;next; pCloned-&gt;random = NULL; pNode-&gt;next = pCloned; pNode = pCloned-&gt;next; &#125; &#125; //第二步，处理复杂指针的random void ConnectSiblingNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; while(pNode != NULL)&#123; RandomListNode* pCloned = pNode-&gt;next; if(pNode-&gt;random != NULL) pCloned-&gt;random = pNode-&gt;random-&gt;next; pNode = pCloned-&gt;next; &#125; &#125; //第三步，拆分复杂指针 RandomListNode* ReconnectNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; RandomListNode* pCloneHead = NULL; RandomListNode* pCloneNode = NULL; if(pNode != NULL)&#123; pCloneHead = pCloneNode = pNode-&gt;next; pNode-&gt;next = pCloneNode-&gt;next; pNode = pNode-&gt;next; &#125; while(pNode != NULL)&#123; pCloneNode-&gt;next = pNode-&gt;next; pCloneNode = pCloneNode-&gt;next; pNode-&gt;next = pCloneNode-&gt;next; pNode = pNode-&gt;next; &#125; return pCloneHead; &#125; RandomListNode* Clone(RandomListNode* pHead) &#123; CloneNodes(pHead); ConnectSiblingNodes(pHead); return ReconnectNodes(pHead); &#125;&#125;; Python版代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: #RandomListNode def CloneNodes(self, pHead): pNode = pHead while pNode is not None: pCloned = RandomListNode(0) pCloned.label = pNode.label pCloned.next = pNode.next pCloned.random = None pNode.next = pCloned pNode = pCloned.next def ConnectSiblingNodes(self, pHead): pNode = pHead while pNode is not None: pCloned = pNode.next if pNode.random is not None: pCloned.random = pNode.random.next pNode = pCloned.next def ReconnectNodes(self, pHead): pNode = pHead pCloneHead = None if pNode is not None: pCloneHead = pCloneNode = pNode.next pNode.next = pCloneNode.next pNode = pNode.next while pNode is not None: pCloneNode.next = pNode.next pCloneNode = pCloneNode.next pNode.next = pCloneNode.next pNode = pNode.next return pCloneHead def Clone(self, pHead): # write code here self.CloneNodes(pHead) self.ConnectSiblingNodes(pHead) return self.ReconnectNodes(pHead) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（发散思维能力）：不用加减乘除做加法]]></title>
    <url>%2F2017%2F12%2F06%2Foffer-16%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路：首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果 C++版代码实现：1234567class Solution &#123;public: int Add(int num1, int num2) &#123; return num2 ? Add(num1^num2, (num1&amp;num2)&lt;&lt;1) : num1; &#125;&#125;; Python版代码实现：python可以直接用内置函数实现。 12345# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here return sum([num1,num2]) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>发散思维能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（发散思维能力）：求1+2+3+...+n]]></title>
    <url>%2F2017%2F12%2F06%2Foffer-17%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路：不能使用乘除法就意味着不能使用公式，循环和条件判断也不能用，所以只能用递归，递归的停止条件用逻辑与来终止（短路特性），即当n为0时，不再递归直接返回结果。 在网上还找了一种解题思路，就是利用计算二维数组的元素数量来实现的，妙，实在是妙。 C++版代码实现：###递归： 12345678class Solution &#123;public: int Sum_Solution(int n) &#123; int ans = n; ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans; &#125;&#125;; ###二维数组： 1234567class Solution &#123;public: int Sum_Solution(int n) &#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;; Python版代码实现：递归：12345678910111213# -*- coding:utf-8 -*-class Solution: def __init__(self): self.sum = 0 def Sum_Solution(self, n): # write code here def qiusum(n): self.sum += n n -= 1 return n&gt;0 and self.Sum_Solution(n) qiusum(n) return self.sum reduce：1234567# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here def f(x,y): return x+y return reduce(f,range(n+1)) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>发散思维能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（递归和循环）：跳台阶]]></title>
    <url>%2F2017%2F12%2F05%2Foffer-15%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：对于n级台阶，第一步有2种跳法：跳1级、跳2级；跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)。其中：f(1) = 1, f(2) = 2。 实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。 注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。 C++版代码实现：递归：1234567891011class Solution &#123;public: int jumpFloor(int number) &#123; if(number &lt;= 0) return 0; else if(number &lt; 3) return number; else return jumpFloor(number-1)+jumpFloor(number-2); &#125;&#125;; 循环：12345678910111213141516class Solution &#123;public: int jumpFloor(int number) &#123; if(number &lt;= 0) return 0; else if(number &lt; 3) return number; int first = 1, second = 2, third = 0; for (int i = 3; i &lt;= number; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; Python 代码实现：递归：12345678910# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 0: return 0 elif number &lt; 3: return number else: return self.jumpFloor(number-1) + self.jumpFloor(number-2) 循环：12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 0: return 0 elif number &lt; 3: return number first = 1 second = 2 third = 0 for i in range(3,number+1): third = first + second first = second second = third return third 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（递归和循环）：矩形覆盖]]></title>
    <url>%2F2017%2F12%2F05%2Foffer-14%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 解题思路：和跳台阶的解题思路是一样的。 对于2 n的矩形，第一步有2种覆盖方法：横着放一个2 1的矩形、竖着放两个2 1的矩形；横着放一个2 1的矩形，剩下2 n-1的矩形，则剩下覆盖方法是f(n-1)竖着放两个2 1的矩形，剩下2 * n-2的矩形，则剩下覆盖方法是f(n-2)所以f(n)=f(n-1)+f(n-2)。其中：f(1) = 1, f(2) = 2。 实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。 注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。 C++版代码实现：递归：1234567891011class Solution &#123;public: int rectCover(int number) &#123; if(number &lt;= 0) return 0; else if(number &lt; 3) return number; else return rectCover(number-1)+rectCover(number-2); &#125;&#125;; 循环：12345678910111213141516class Solution &#123;public: int rectCover(int number) &#123; if(number &lt;= 0) return 0; else if(number &lt; 3) return number; int first = 1, second = 2, third = 0; for (int i = 3; i &lt;= number; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; Python 代码实现：递归：12345678910# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 0: return 0 elif number &lt; 3: return number else: return self.rectCover(number-1) + self.rectCover(number-2) 循环：12345678910111213141516# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 0: return 0 elif number &lt; 3: return number first = 1 second = 2 third = 0 for i in range(3,number+1): third = first + second first = second second = third return third 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（递归和循环）：斐波那契数列]]></title>
    <url>%2F2017%2F12%2F05%2Foffer-13%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言如果我们需要重复地多次计算相同的问题，通常可以选择用递归或者循环两种不同的方法。递归式在一个函数的内部调用这个函数自身。而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。 通常递归的代码会比较简洁。在面试的时候，如果面试官没有特别的要求，应聘者可以尽量多采用递归。 递归虽然有简介的优点，但它同时也有显著的缺点，那就是时间和空间的消耗：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里面压入数据和弹出数据都需要时间，这就不难理解上述的例子中递归实现的效率不如循环了。 除了效率，递归还有可能引起更严重的问题：调用栈溢出。当递归调用的层数太多时，就会超出栈的容量，从而导致调用栈溢出。 题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 解题思路斐波那契数列的定义如下： !$f(n) = \begin{cases} 0, &amp; \text{n = 0} \\ 1, &amp; \text{n = 1} \\ {f(n-1)+f(n-2)}, &amp; \text{n &gt; 1} \end{cases} $ 实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。 注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。这次C++的递归调用也超时了，所以啊，面试手写优先使用递归，在线编程优先使用循环呐。 C++版代码实现：递归：12345678910class Solution &#123;public: int Fibonacci(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; return Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125;; 循环：12345678910111213141516class Solution &#123;public: int Fibonacci(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; int first = 0, second = 1, third = 0; for (int i = 2; i &lt;= n; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; Python 代码实现：递归：123456789# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 0: return 0 if n == 1: return 1 return self.Fibonacci(n-1) + self.Fibonacci(n-2) 循环：12345678910111213141516# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 0: return 0 if n == 1: return 1 first = 0 second = 1 third = 0 for i in range(2,n+1): third = first + second first = second second = third return third 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（递归和循环）：变态跳台阶]]></title>
    <url>%2F2017%2F12%2F05%2Foffer-12%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/nowcoder/blob/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)因为f(n-1)=f(n-2)+f(n-3)+…+f(1)所以f(n)=2*f(n-1) 实现f(n)=2*f(n-1)的方法有很多种，递归、循环都可以。 注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。 C++版代码实现：递归：123456789101112class Solution &#123;public: int jumpFloorII(int number) &#123; if(number &lt;= 0)&#123; return -1; &#125;else if(number == 1)&#123; return 1; &#125;else&#123; return 2 * jumpFloorII(number -1); &#125; &#125;&#125;; 循环：1234567891011class Solution &#123;public: int jumpFloorII(int number) &#123; if(number == 0) return number; int total=1; for(int i=1; i&lt;number; i++) total *= 2; return total; &#125;&#125;; 移位：123456class Solution &#123;public: int jumpFloorII(int number) &#123; return 1&lt;&lt;--number; &#125;&#125;; Python 代码实现：递归：12345678910# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= -1: return -1 elif number == 1: return 1 else: return 2*self.jumpFloorII(number-1) 循环：12345678910# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number == 0: return number total = 1 for i in range(number-1): total *= 2 return total 移位：12345# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here return 1&lt;&lt;(number-1); 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码完整性）：在O(1)时间删除链表结点]]></title>
    <url>%2F2017%2F12%2F04%2Foffer-11%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言同样的，这道题牛客网上也没有。 题目描述给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表结点与函数的定义如下： 123456struct ListNode&#123; int m_nValue; ListNode* m_pNext;&#125;void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted); 解题思路 方法一：顺序遍历（时间复杂度O(n)） 从单向链表中删除一个结点，最常规的做法就是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。之所以需要从头开始查找，是因为我们需要得到将被删除的节点的前面一个结点。在单向链表中，结点中没有指向前一个结点的指针，所以只好从链表的头结点开始顺序查找。 方法二：复制结点（时间复杂度O(1)） 当然，我们并不是非得得到前一个结点才能来删除该结点。上图C中，我们要删除结点i，先把i的下一个结点j的内容复制到i，然后把i的指针指向结点j的下一个结点。此时再删除节点j，其效果刚好是把结点i给删除了。 但是，这种思路，需要考虑删除尾结点的问题，这个时候只能顺序遍历。同时，还要注意如果链表中只有一个结点的情况，记得删除之后把头结点设置为NULL。 C++版代码实现顺序遍历12345678910111213141516void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted)&#123; if(!pListHead || !pToBeDeleted) return; ListNode* pNode = *pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = nullptr; delete pToBeDeleted; pToBeDeleted = nullptr;&#125; 复制结点123456789101112131415161718192021222324252627282930313233343536void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted)&#123; if(!pListHead || !pToBeDeleted) return; // 要删除的结点不是尾结点 if(pToBeDeleted-&gt;m_pNext != nullptr) &#123; ListNode* pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = nullptr; &#125; // 链表只有一个结点，删除头结点（也是尾结点） else if(*pListHead == pToBeDeleted) &#123; delete pToBeDeleted; pToBeDeleted = nullptr; *pListHead = nullptr; &#125; // 链表中有多个结点，删除尾结点 else &#123; ListNode* pNode = *pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = nullptr; delete pToBeDeleted; pToBeDeleted = nullptr; &#125;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码完整性）：数值的整数次方]]></title>
    <url>%2F2017%2F12%2F04%2Foffer-9%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言代码的规范性：书写清晰，布局清晰，命名合理。代码的完整性：功能测试，边界测试，负面测试。 题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路方法一：公式求解 我们知道当指数为负数的时候，可以先对指针求绝对值，然后算出次方的结果之后再取倒数。如果要自己实现，那么就需要考虑各种错误处理和边界问题。比如，既然有求倒数，对0求倒数怎么办，当底数是0且指数是负数的时候，如果不做特殊处理，就会出现对0求倒数而导致程序运行出错。 一个细节值得我们注意：在判断底数是不是等于0时，不能直接写base == 0，这是因为在计算机内表示小数时都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围内。如果两个数差值很小，就可以认为它们相等。这就是我们定义函数equal的原因。 方法二：迭代 !$a^n = \begin{cases} a^{n/2}*a^{n/2}, &amp; \text{n为偶数} \\ a^{(n-1)/2}*a^{(n-1)/2}*a, &amp; \text{n为奇数} \end{cases} $ 这个公式很容易就用递归来实现。 C++版代码实现：调用pow：1234567891011121314class Solution &#123;public: double Power(double base, int exponent) &#123; double result; if(exponent &gt;= 0)&#123; result = pow(base, exponent); &#125; else&#123; result = pow(base, -exponent); result = 1 / result; &#125; return result; &#125;&#125;; 不调用pow：123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool g_InvalidInput = false; double Power(double base, int exponent) &#123; g_InvalidInput = false; if(equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123; g_InvalidInput = true; return 0.0; &#125; unsigned int absExponent = (unsigned int)(exponent); if(exponent &lt; 0) absExponent = (unsigned int)(-exponent); double result = PowerWithUnsignedExponent(base, absExponent); if(exponent &lt; 0) result = 1.0 / result; return result; &#125; double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123; double result = 1.0; for (int i = 1; i &lt;= exponent; ++i) result *= base; return result; &#125; bool equal(double num1, double num2)&#123; if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001)) return true; else return false; &#125;&#125;; 递归：123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool g_InvalidInput = false; double Power(double base, int exponent) &#123; g_InvalidInput = false; if(equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123; g_InvalidInput = true; return 0.0; &#125; unsigned int absExponent = (unsigned int)(exponent); if(exponent &lt; 0) absExponent = (unsigned int)(-exponent); double result = PowerWithUnsignedExponent(base, absExponent); if(exponent &lt; 0) result = 1.0 / result; return result; &#125; double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123; if(exponent == 0) return 1; if(exponent == 1) return base; double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1); result *= result; if(exponent &amp; 0x1 == 1) result *= base; return result; &#125; bool equal(double num1, double num2)&#123; if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001)) return true; else return false; &#125;&#125;; Python 代码实现：调用pow：123456789101112# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if exponent &gt;= 0: result = pow(base, exponent) else: result = pow(base, -exponent) result = 1 / result return result 不调用pow1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here flag = 0 if base == 0: return False if exponent == 0: return 1 if exponent &lt; 0: flag = 1 result = 1 for i in range(abs(exponent)): result *= base if flag == 1: result = 1 / result return result 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码完整性）：调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F2017%2F12%2F04%2Foffer-10%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言书上这道题没要求相对位置不变，所以这道题我们以牛客网为准，毕竟有测试平台。 题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路方法一： 类似冒泡算法，前偶后奇就交换。时间复杂度O(n^2)。 方法二： 空间换时间，再创建一个数组，或者双向队列。时间复杂度O(n)，空间复杂度O(n)。 方法三： 双向队列，一次循环插入。 C++版代码实现：冒泡123456789101112131415class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; for (int i = 0; i &lt; array.size(); i++) &#123; for (int j = array.size() - 1; j &gt; i; j--) &#123; if (array[j] % 2 == 1 &amp;&amp; array[j - 1] % 2 == 0) //前偶后奇交换 &#123; swap(array[j], array[j-1]); &#125; &#125; &#125; &#125;&#125;; 新建数组123456789101112131415161718class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; vector&lt;int&gt; result; int num = array.size(); for(int i=0; i &lt; num; i++) &#123; if(array[i] % 2 == 1) result.push_back(array[i]); &#125; for(int i=0; i &lt; num; i++) &#123; if(array[i] % 2 == 0) result.push_back(array[i]); &#125; array = result; &#125;&#125;; 双向队列123456789101112131415class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; deque&lt;int&gt; result; int num = array.size(); for(int i=0; i &lt; num; i++) &#123; if(array[num-i-1] % 2 == 1) result.push_front(array[num-i-1]); if(array[i] % 2 == 0) result.push_back(array[i]); &#125; array.assign(result.begin(),result.end()); &#125;&#125;; Python 代码实现：冒泡：123456789# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here for i in range(0, len(array)): for j in range(len(array)-1, i, -1): if array[j-1] % 2 == 0 and array[j] % 2 == 1: array[j], array[j-1] = array[j-1], array[j] return array 新建列表123456789101112# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here result = [] for i in range(len(array)): if array[i] % 2 != 0: result.append(array[i]) for i in range(len(array)): if array[i] % 2 == 0: result.append(array[i]) return result 双向队列12345678910111213# -*- coding:utf-8 -*-from collections import dequeclass Solution: def reOrderArray(self, array): # write code here odd = deque() l = len(array) for i in range(l): if array[l-i-1] % 2 != 0: odd.appendleft(array[l-i-1]) if array[i] % 2 == 0: odd.append(array[i]) return list(odd) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码完整性）：打印1到最大的n位数]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-8%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言这道题牛客网上没有，但是剑指offer上有，看完之后觉得挺有用的，所以我还是整理一下吧。 题目描述输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 解题思路没有规定n的范围，所以我们需要考虑大数的问题。 方法一：字符串模拟 用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是‘0’到‘9’之间的某一个字符，用来表示数字中的一位。因为数字最大是n位，所以我们需要一个长度为n+1的字符串（字符串结尾符号‘\0’，这个我记得之前强调过了）。当实际数字不够n位的时候在字符串前半部分补0，打印的时候不打印前半部分的0就好。同时我们用进位标志位作为循环终止条件。 方法二：递归 如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到所有的十进制数，只是我们在打印的时候，数字排在前面的0我们不打印出来罢了。 C++版代码实现：字符串模拟：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ====================方法一====================void Print1ToMaxOfNDigits_1(int n)&#123; if (n &lt;= 0) return; char *number = new char[n + 1]; memset(number, '0', n); number[n] = '\0'; while (!Increment(number)) &#123; PrintNumber(number); &#125; delete[]number;&#125;// 字符串number表示一个数字，在 number上增加1// 如果做加法溢出，则返回true；否则为falsebool Increment(char* number)&#123; bool isOverflow = false; int nTakeOver = 0; int nLength = strlen(number); for (int i = nLength - 1; i &gt;= 0; i--) &#123; int nSum = number[i] - '0' + nTakeOver; if (i == nLength - 1) nSum++; if (nSum &gt;= 10) &#123; if (i == 0) isOverflow = true; else &#123; nSum -= 10; nTakeOver = 1; number[i] = '0' + nSum; &#125; &#125; else &#123; number[i] = '0' + nSum; break; &#125; &#125; return isOverflow;&#125;// ====================公共函数====================// 字符串number表示一个数字，数字有若干个0开头// 打印出这个数字，并忽略开头的0void PrintNumber(char* number)&#123; bool isBeginning0 = true; int nLength = strlen(number); for (int i = 0; i &lt; nLength; ++i) &#123; if (isBeginning0 &amp;&amp; number[i] != '0') isBeginning0 = false; if (!isBeginning0) &#123; printf("%c", number[i]); &#125; &#125; printf("\t");&#125; 递归：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ====================方法二====================void Print1ToMaxOfNDigits_2(int n)&#123; if (n &lt;= 0) return; char* number = new char[n + 1]; number[n] = '\0'; for (int i = 0; i &lt; 10; ++i) &#123; number[0] = i + '0'; Print1ToMaxOfNDigitsRecursively(number, n, 0); &#125; delete[] number;&#125;void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)&#123; if (index == length - 1) &#123; PrintNumber(number); return; &#125; for (int i = 0; i &lt; 10; ++i) &#123; number[index + 1] = i + '0'; Print1ToMaxOfNDigitsRecursively(number, length, index + 1); &#125;&#125;// ====================公共函数====================// 字符串number表示一个数字，数字有若干个0开头// 打印出这个数字，并忽略开头的0void PrintNumber(char* number)&#123; bool isBeginning0 = true; int nLength = strlen(number); for (int i = 0; i &lt; nLength; ++i) &#123; if (isBeginning0 &amp;&amp; number[i] != '0') isBeginning0 = false; if (!isBeginning0) &#123; printf("%c", number[i]); &#125; &#125; printf("\t");&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码的鲁棒性）：链表中倒数第k个结点]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-6%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言所谓的鲁棒性是指程序能够判断输入是否符合规范要求，并对不合要求的输入予以合理的处理。 提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种变成习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。比如试图打开文件时发现文件不存在，我们可以提示用户检查文件名和路径等等，这样当异常发生时，软件的行为也尽在我们的掌握之中，而不至于出现不可预见的事情。 比如下面这道题，“链表中倒数第K个结点”，这里隐含着一个条件就是链表中结点的个数大于k。我们想，如果链表中的结点的数目不是大于k个，那么代码会出什么问题？这样的思考方式能够帮助我们发现潜在的问题并提前解决问题。 题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不变；从第K步开始，第二个指针也是从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个指针到达链表的伪结点时，第二个指针正好是倒数第k个结点。 C++版代码实现鲁棒性低123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* pAhead = pListHead; ListNode* pBehind = NULL; for(unsigned int i = 0; i &lt; k - 1; ++i)&#123; pAhead = pAhead-&gt;next; &#125; pBehind = pListHead; while(pAhead-&gt;next != NULL)&#123; pAhead = pAhead-&gt;next; pBehind = pBehind-&gt;next; &#125; return pBehind; &#125;&#125;; 鲁棒性高1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if(pListHead == NULL || k == 0) return NULL; ListNode* pAhead = pListHead; ListNode* pBehind = NULL; for(unsigned int i = 0; i &lt; k - 1; ++i)&#123; if(pAhead-&gt;next != NULL) pAhead = pAhead-&gt;next; else return NULL; &#125; pBehind = pListHead; while(pAhead-&gt;next != NULL)&#123; pAhead = pAhead-&gt;next; pBehind = pBehind-&gt;next; &#125; return pBehind; &#125;&#125;; Python 代码实现鲁棒性差12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here pAhead = head pBehind = None for i in xrange(0, k-1): pAhead = pAhead.next return None pBehind = head while pAhead.next != None: pAhead = pAhead.next pBehind = pBehind.next return pBehind 鲁棒性高123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here if not head or k == 0: return None pAhead = head pBehind = None for i in xrange(0, k-1): if pAhead.next != None: pAhead = pAhead.next else: return None pBehind = head while pAhead.next != None: pAhead = pAhead.next pBehind = pBehind.next return pBehind 更快12345678910111213141516# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = None class Solution: def FindKthToTail(self, head, k): # write code here l=[] while head != None: l.append(head) head = head.next if k &gt; len(l) or k &lt; 1: return return l[-k] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码的鲁棒性）：合并两个排序的链表]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-5%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言在面试过程中，最容易犯两种错误：一是在写代码之前没有对合并的过程想清楚，最终合并出来的链表要么中间断开了要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会崩溃。 题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路递归： 新创建一个指针就可以，比较两个链表的值，然后做相应递归更新。 循环： 需要创建两个指针，一个指向合并链表的表头，另一个用于更新，不断指向合并链表的表尾。最后返回指向表头的指针即可。 需要注意的是，我为了简化代码，新建的是指向带有头结点的链表（链表有带头结点和不带头结点点两种）。如果全部初始化为NULL（python是None），那么我在循环之前，就得加个判断来给合并链表的第一个结点赋值。 C++版代码实现递归12345678910111213141516171819202122232425262728293031/*/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; //边界判断 if(pHead1 == NULL) return pHead2; else if(pHead2 == NULL) return pHead1; //创建头指针 ListNode* pMergeHead = NULL; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pMergeHead = pHead1; pMergeHead-&gt;next = Merge(pHead1-&gt;next, pHead2); &#125; else&#123; pMergeHead = pHead2; pMergeHead-&gt;next = Merge(pHead1, pHead2-&gt;next); &#125; return pMergeHead; &#125;&#125;; 循环123456789101112131415161718192021222324252627282930313233343536373839/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; //边界判断 if(pHead1 == NULL) return pHead2; else if(pHead2 == NULL) return pHead1; //创建头尾指针 ListNode* pMergeTail = new ListNode(0); ListNode* pMergeHead = new ListNode(0); //尾指针赋值 pMergeTail = pMergeHead; //循环开始 while(pHead1 &amp;&amp; pHead2)&#123; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pMergeTail-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else&#123; pMergeTail-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; pMergeTail = pMergeTail-&gt;next; &#125; //剩下的链表部分直接添加 pMergeTail-&gt;next = pHead1 ? pHead1 : pHead2; return pMergeHead-&gt;next; &#125;&#125;; Python 代码实现递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 pMergeHead = ListNode(0) if pHead1.val &lt; pHead2.val: pMergeHead = pHead1 pMergeHead.next = self.Merge(pHead1.next, pHead2) else: pMergeHead = pHead2 pMergeHead.next = self.Merge(pHead1, pHead2.next) return pMergeHead 循环123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 pMergeTail = pMergeHead = ListNode(0) while pHead1 and pHead2: if pHead1.val &lt; pHead2.val: pMergeTail.next = pHead1 pHead1 = pHead1.next else: pMergeTail.next = pHead2 pHead2 = pHead2.next pMergeTail = pMergeTail.next pMergeTail.next = pHead1 or pHead2 return pMergeHead.next 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码的鲁棒性）：反转链表]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述输入一个链表，反转链表后，输出链表的所有元素。 解题思路题目比较简单，主要是需要考虑在调整某一结点的m_pNext之前，先把它的下一个节点保存下来，以免断链子了。同时还要满足下面的测试用例。 测试用例： 输入的链表头指针是NULL。 输入的链表只有一个结点。 输入的链表有多个结点。 C++版代码实现123456789101112131415161718192021222324252627282930/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* pReversedHead = nullptr; ListNode* pNode = pHead; ListNode* pPrev = nullptr; while(pNode != nullptr) &#123; ListNode* pNext = pNode-&gt;next; if(pNext == nullptr) pReversedHead = pNode; pNode-&gt;next = pPrev; pPrev = pNode; pNode = pNext; &#125; return pReversedHead;&#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（代码的鲁棒性）：树的子结构]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-7%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言之前在leetcode刷题的时候，感觉做的最多的就是树这块了。 题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路第一步在树A中查找与根结点的值一样的结点，这实际上就是树的遍历。所以，递归和循环都可以。 第二步是判断树A中以R为根结点的子树是不是和树B有相同的结构。同样的，递归和循环都可以。 C++版代码实现DFS1234567891011121314151617181920212223242526/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if(pRoot1 == NULL || pRoot2 == NULL) return false; return dfs(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2); &#125;private: bool dfs(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot2 == NULL) return true; if(pRoot1 == NULL) return false; return pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; dfs(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; dfs(pRoot1-&gt;right, pRoot2-&gt;right); &#125;&#125;; Python 代码实现DFS123456789101112131415161718# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.dfs(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def dfs(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1: return False return pRoot1.val == pRoot2.val and self.dfs(pRoot1.left, pRoot2.left) and self.dfs(pRoot1.right, pRoot2.right) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（抽象建模能力）：圆圈中最后剩下的数]]></title>
    <url>%2F2017%2F12%2F03%2Foffer-3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路如果只求最后一个报数胜利者的话，我们可以用数学归纳法解决该问题，为了讨 论方便，先把问题稍微改变一下，并不影响原意： 问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。 我们知道第一个人(编号一定是(m-1)%n) 出列之后，剩下的n-1个人组成了一个新 的约瑟夫环（以编号为k=(m-1)%n的人开始）: k k+1 k+2 … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。现在我们把他们的编号做一下转换：k+1 –&gt; 0k+2 –&gt; 1…n-1 –&gt; n-k-20 –&gt; n-k-11 –&gt; n-k…k-2 –&gt; n-2k-1 –&gt; n-1变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解： 例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情 况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k+1)%n。然后把k=(m-1)%n带入，就是下面的递推公式了。令f[n]表示n个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。递推公式f[1]=0;f[n]=(f[n-1]+m)%n; (n&gt;1)有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 C++版代码实现123456789101112class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if(n &lt; 1 || m &lt; 1) return -1; int last = 0; for(int i = 2; i &lt;= n; ++i) last = (last + m) % i; return last; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（抽象建模能力）：扑克牌顺子]]></title>
    <url>%2F2017%2F12%2F02%2Foffer-2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 解题思路一次for循环就可以搞定，满足如下条件才可以认为是顺子： 输入数据个数为5； 输入数据都在0-13之间； 没有相同的数字； 最大值与最小值的差值不大于5； 不用对输入数据做排序，直接设置一个flag，该flag的每一位分别用来记录1-13是否出现，出现过一次置1，出现两次则中止程序。 C++版代码实现123456789101112131415161718192021222324252627class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if(numbers.size() &lt; 5) return false; int max = -1; int min = 14; int flag = 0; for(int i = 0; i &lt; numbers.size(); ++i)&#123; int number = numbers[i]; if(number &lt; 0 || number &gt; 13) return false; if(number == 0) continue; if(((flag &gt;&gt; number) &amp; 1) == 1) return false; flag |= 1 &lt;&lt; number; if(number &lt; min) min = number; if(number &gt; max) max = number; if(max - min &gt;= 5) return false; &#125; return true; &#125;&#125;; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>抽象建模能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记（查找和排序）：旋转数组的最小数字]]></title>
    <url>%2F2017%2F12%2F02%2Foffer-1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言查找和排序是面试时考查算法的重点，重点掌握二分查找、归并排序和快速排序。 查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。必须要信手拈来。 哈希表表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的优点是我们利用它能够在O(1)时间查找某一元素，是效率最高的查找方式，但是需要二外的空间来实现哈希表。与二叉排序树查找算法对应的数据结构是二叉搜索树，后面会涉及到。如果要在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。 排序比查找要复杂一些，我们需要比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，必须要烂熟于胸，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较他们的优缺点。同时，快排经常要求重写。 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路直接查找算法复杂度O(n)。 再次排序再次排序后输出第一个数字，算法复杂度O(n*logn)。 分段二分查找算法复杂度O(logn)。 我们用两个指针分别指向数组的第一个元素和最后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最后一个元素的（不完全对，有特例）。 接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。 同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。 第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。 特殊情况： 如果把排序数组的0个元素搬到最后面，这仍然是租住的一个需安装，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。 下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。 C++代码实现再次排序123456789class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; sort(rotateArray.begin(),rotateArray.end()); return rotateArray[0]; &#125;&#125;; 分段二分法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); if(size == 0)&#123; return 0; &#125; int left = 0; int right = size - 1; int mid = 0; // rotateArray[left] &gt;= rotateArray[right] 确保旋转 while(rotateArray[left] &gt;= rotateArray[right])&#123; // 分界点 if(right - left == 1)&#123; mid = right; break; &#125; mid = left + (right - left) / 2; // rotateArray[left] rotateArray[right] rotateArray[mid]三者相等 // 无法确定中间元素是属于前面还是后面的递增子数组 // 只能顺序查找 if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])&#123; return MinOrder(rotateArray,left,right); &#125; // 中间元素位于前面的递增子数组 // 此时最小元素位于中间元素的后面 if(rotateArray[mid] &gt;= rotateArray[left])&#123; left = mid; &#125; // 中间元素位于后面的递增子数组 // 此时最小元素位于中间元素的前面 else&#123; right = mid; &#125; &#125; return rotateArray[mid]; &#125;private: // 顺序寻找最小值 int MinOrder(vector&lt;int&gt; &amp;num,int left,int right)&#123; int result = num[left]; for(int i = left + 1;i &lt; right;++i)&#123; if(num[i] &lt; result)&#123; result = num[i]; &#125; &#125; return result; &#125;&#125;; Python代码实现123456789101112# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 pre = -7e20 for num in rotateArray: if num &lt; pre : return num pre = num return rotateArray[0] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>查找和排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》刷题笔记系列综述]]></title>
    <url>%2F2017%2F12%2F01%2Foffer-0%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/CodingInterviewChinese2 文章地址：https://github.com/WordZzzz/Note/tree/master/AtOffer 刷题平台：https://www.nowcoder.com/ 题&emsp;&emsp;库：剑指offer 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;WordZzzz原计划按照牛客网上面的《剑指offer》的通过率高低来把66道编程题刷一遍，但是后来发现，相对于牛客网上大神的解答，WordZzzz更倾向于原书作者的详解。所以，从今天开始，本博主打算按照《剑指offer》纪念版上的题目顺序来进行后续的总结，以作者何大大思路为主，以牛客网上各路大声的代码为辅，对每一道题的解法进行详细的记录，方便自己日后查看，也为订阅本专栏的各位可爱的亲人们提供一些参考。 《剑指offer》何大大的源码（含测试代码）传送门：https://github.com/zhedahht/CodingInterviewChinese2 当然我自己也fork了一下：https://github.com/WordZzzz/CodingInterviewChinese2 再来个码云的传送门吧：https://gitee.com/WordZzzz/CodingInterviewChinese2 至于《剑指offer》纪念版的电子版当然我也有，网上最清晰的资源，需要的请私信我。有条件的还是建议购买正版书籍，支持何大大，支持正版！ &emsp;&emsp;另外，下面这道开胃菜牛客上没有，所以先贴出来了。 赋值运算符函数&emsp;&emsp;如下为类型CMyString的生命，请为该类型添加赋值运算符函数。 12345678910class CMyString&#123;public: CMyString(char* pData = NULL); CMyString(char* CMyString&amp; str); ~CMyString(void); private: char* m_pData;&#125;; 12345678910class CMyString&#123;public: CMyString(char* pData = NULL); CMyString(char* CMyString&amp; str); ~CMyString(void); private: char* m_pData;&#125;; 考察细节 是否会把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。假设有3个CMyString的对象：str1、str2和str3，在程序中语句str1=str2=str3是不能通过编译的。 是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数，吧参数声明为引用可以避免这样的消耗，能提高代码的效率。同时，我们在赋值运算符函数中不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。 是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的空间，程序将出现内存泄漏。 是否判断传入的参数和但钱的实例是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放自身的内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。 经典的解法1234567891011CMyString&amp; CMyString::operator = (const CMyString &amp;str)&#123; if(this == &amp;str) return *this; delete []m_pData; m_pData = NULL; m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); return *this;&#125; &emsp;&emsp;这是一般教材上提供的参考代码。明眼人可能会发现，上述代码在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，m_pData将是一个空指针，这昂非常容易导致程序的崩溃。 考虑异常安全性的解法&emsp;&emsp;要想在赋值运算符函数中实现异常安全性，一般有两种方法。一个简单的办法是我们先用new分配新内存再用delete释放已有的内容；一个更好的方法是创建临时实例，再交换临时实例和原来的实例。参考代码如下： 12345678910111213CMyString&amp; CMyString::operator = (const CMyString &amp;str)&#123; if(this != &amp;str) &#123; CMyString strTemp(str); cahr* pTemp = strTemp.m_pData; strTemp.m_pData = m_pData; m_pData = pTemp; &#125; return *this;&#125; &emsp;&emsp;程序比较简单，值得注意的是，strTemp是一个局部变量，程序运行到if的外面的时候，也就出了该变量的作用域，就会自动调用其析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之AdaBoost算法（1）算法概述]]></title>
    <url>%2F2017%2F11%2F06%2Fml-18%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch07 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;终于，分类问题要收尾了。 &emsp;&emsp;当做重要决定时，大家肯定是到处取经，集四海八荒之智后，再做出自己的决定。机器学习也是如此，元算法（meta-algorithm）应运而生。元算法是对其他算法进行组合的一种方式。接下来我们将集中关注一个称作AdaBoost的最流行的元算法，该算法可以说是最好的监督学习的方法（巨人说的），所以它也是机器学习工具箱中最强有力的工具之一。 &emsp;&emsp;本系列博客，首先讨论不同分类器的集成方法，然后主要关注boosting方法及其代表分类器AdaBoost；接下来，我们会建立一个单层决策树（decision stump）分类器（实际上，它是一个单节点的决策树）；最后，AdaBoost算法将应用在上述单层决策树分类器之上，并在之前的病马数据集上应用AdaBoost分类器，以此来了解该算法是入个迅速超越其他分类器的。 &emsp;&emsp;本节，我们先来介绍一些概念性的东西。 基于数据集多重抽样的分类器&emsp;&emsp;我们自然可以将前面学习的五种不同的分类方法组合起来，而这种组合结果则被称为集成方法（ensemble method）或者元算法（meta-algorithm）。只用集成方法时会有多种形式：可以是多种不同的算法的集成，可以是同一算法在不同设置下的集成，也可以是数据集不同部分分配给不同分类器的集成。接下来，我们将介绍基于同一种分类器多个不同实例的两种计算方法：bagging和boosting。 bagging&emsp;&emsp;自举汇聚法（bootstrap aggregating），也称为bagging方法，实在从原始数据集选择S次之后得到S个新数据集的一种技术。新旧数据集大小相等，每个数据集都是通过在原始数据集中随机选择一个样本来进行替换而得到的（放回的随机抽样），也就是可以多次选择同一个样本。这一性质就允许新数据集中可以有重复的值，而原始数据集的某些值在新集合中则不再出现。 &emsp;&emsp;S个数据集建好之后，将某个学习算法分别作用于每个数据集就得到了S个分类器。当我们要对新数据进行分类时，就可以应用这S个分类器进行分类了（当然，还是多数表决的原则）。 &emsp;&emsp;当然，还有一些更先进的bagging方法，比如随机森林（random forest），在此就不多做介绍了，我们主要的精力，还是放在与bagging类似的集成分类器方法boosting。 boosting&emsp;&emsp;boosting是一种与bagging很类似的技术。不论是在boosting还是bagging当中，所使用的多个分类器的类型都是一致的。但是boosting算法中，不同的分类器是通过串行训练而得到的，每个新分类器都根据已训练出的分类器的性能来进行训练。boosting通过集中关注已有分类器错分的那些数据来获得新的分类器。 &emsp;&emsp;由于boosting分类的结果是基于所有分类器的加权求和的结果，因此boosting与bagging不太一样。bagging中分类器的权重是相等的，而boosting中分类器的权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。 &emsp;&emsp;基本要点就这些了，下面介绍boosting中一个最流行的版本AdaBoost。 AdaBoost的一般流程： 收集数据：可以使用任意方法。 准备数据：依赖于所使用的弱分类器类型，本章使用的是单层决策树，这种分类器可以处理任何数据类型。当然也可以使用任意分类器作为弱分类器，前面介绍的五种分类器都可以充当弱分类器。作为弱分类器，简单分类器的效果更好。 分析数据：可以使用任意方法。 训练算法：AdaBoost的大部分时间都用在训练上，分类器将多次在同一数据集上训练弱分类器。 测试算法：计算分类的错误率； 使用算法：同SVM一样，AdaBoost预测两个类别中的一个。如果想把它应用到多个类别的场合，那么就要像多类SVM中的做法一样对AdaBoost进行修改。 基于错误提升分类器的性能&emsp;&emsp;能否使用弱分类器和多个实例来构建一个强分类器，这是一个非常有趣的理论问题。这里的“弱”意味着分类器的性能比随机猜测要略好，但是也不会好太多。也就是说，在二分类情况下弱分类器的错误率会高于50%，而“强“分类器的错误率将会低很多。AdaBoost算法就是基于上述理论的。 &emsp;&emsp;AdaBoost是adaptive boosting（自适应boosting）的缩写，其运行过程如下：训练数据中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始，这些权重都初始化成相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后再同一数据集上再次训练弱分类器。在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值alpha，这些alpha值是基于每个弱分类器的错误率进行计算的。其中，错误率ε的定义为： $$\epsilon = \frac{未正确分类的样本数目}{所有样本数目}$$ &emsp;&emsp;而alpha的计算公式如下： $$\alpha = \frac{1}{2} ln (\frac{1-\epsilon}{\epsilon})$$ &emsp;&emsp;AdaBoost算法的流程如图所示。 &emsp;&emsp;左边是数据集，中间直方图的不同宽度表示每个样例上的不同权重。在经过一个分类器之后，加权的预测结果会通过三角形中的alpha值进行加权。每个三角形中输出的甲醛结果在圆形中求和，从而得到最终的输出结果。 &emsp;&emsp;计算出alpha的值之后，可以对权重向量D进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高。D的计算方法如下。&emsp;&emsp;如果某个样本被正确分类，那么该样本的权重更改为： $$D_i^{(t+1)} = \frac{D_i^{(t)}e^{-\alpha}}{Sum(D)})$$ &emsp;&emsp;如果某个样本被错误分类，那么该样本的权重更改为： $$D_i^{(t+1)} = \frac{D_i^{(t)}e^{\alpha}}{Sum(D)})$$ &emsp;&emsp;计算出来D之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练和调整权重的过程，直到训练错误率为0或者弱分类器的数目达到用户的指定值为止。 &emsp;&emsp;下一篇博文我们来实现AdaBoost。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>AdaBoost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之AdaBoost算法（2）算法实现]]></title>
    <url>%2F2017%2F11%2F06%2Fml-19%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch07 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 基于单层决策树构建弱分类器&emsp;&emsp;单层决策树（decision stump，也称决策树桩）是一种简单的决策树。前面我们已经介绍了决策树的工作原理，接下来将构建一个单层决策树，而它仅基于单个特征来做决策。 &emsp;&emsp;首先，需要通过一个简单数据集来确保在算法实现上一切就绪。建立adaboost.py文件并加入如下代码： 12345678910111213141516171819202122232425262728#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-10-10 16:04:14# @Author : WordZzzz (wordzzzz@foxmail.com)# @Link : http://blog.csdn.net/u011475210# @Version : $Id$from numpy import *def loadSimpData(): """ Function： 创建数据集 Input： NULL Output： datMat：数据集 classLabels：类别标签 """ #创建数据集 datMat = matrix([[1. , 2.1], [2. , 1.1], [1.3, 1. ], [1. , 1. ], [2. , 1. ]]) #创建类别标签 classLabels = [1.0, 1.0, -1.0, -1.0, 1.0] #返回数据集和标签 return datMat, classLabels &emsp;&emsp;查看建立的数据集： 12345678910&gt;&gt;&gt; import adaboost&gt;&gt;&gt; datMat, classLabels = adaboost.loadSimpData()&gt;&gt;&gt; datMatmatrix([[ 1. , 2.1], [ 2. , 1.1], [ 1.3, 1. ], [ 1. , 1. ], [ 2. , 1. ]])&gt;&gt;&gt; classLabels[1.0, 1.0, -1.0, -1.0, 1.0] &emsp;&emsp;可视化结果： &emsp;&emsp;接下来，构建单层决策树，伪代码如下： 1234567将最小错误率minEroor设为无穷大对数据集中的每一个特征（第一层循环）： 对每个步长（第二层循环）： 对每个不等号（第三层循环）： 建立一颗单层决策树并利用加权数据集对它进行测试 如果错误率低于minError，则将当前单层决策树设为最佳单层决策树返回最佳单层决策树 &emsp;&emsp;单层决策树生成函数代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def stumpClassify(dataMatrix, dimen, threshVal, threshIneq): """ Function： 通过阈值比较对数据进行分类 Input： dataMatrix：数据集 dimen：数据集列数 threshVal：阈值 threshIneq：比较方式：lt，gt Output： retArray：分类结果 """ #新建一个数组用于存放分类结果，初始化都为1 retArray = ones((shape(dataMatrix)[0],1)) #lt：小于，gt；大于；根据阈值进行分类，并将分类结果存储到retArray if threshIneq == 'lt': retArray[dataMatrix[:, dimen] &lt;= threshVal] = -1.0 else: retArray[dataMatrix[:, dimen] &gt; threshVal] = -1.0 #返回分类结果 return retArraydef buildStump(dataArr, classLabels, D): """ Function： 找到最低错误率的单层决策树 Input： dataArr：数据集 classLabels：数据标签 D：权重向量 Output： bestStump：分类结果 minError：最小错误率 bestClasEst：最佳单层决策树 """ #初始化数据集和数据标签 dataMatrix = mat(dataArr); labelMat = mat(classLabels).T #获取行列值 m,n = shape(dataMatrix) #初始化步数，用于在特征的所有可能值上进行遍历 numSteps = 10.0 #初始化字典，用于存储给定权重向量D时所得到的最佳单层决策树的相关信息 bestStump = &#123;&#125; #初始化类别估计值 bestClasEst = mat(zeros((m,1))) #将最小错误率设无穷大，之后用于寻找可能的最小错误率 minError = inf #遍历数据集中每一个特征 for i in range(n): #获取数据集的最大最小值 rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max() #根据步数求得步长 stepSize = (rangeMax - rangeMin) / numSteps #遍历每个步长 for j in range(-1, int(numSteps) + 1): #遍历每个不等号 for inequal in ['lt', 'gt']: #设定阈值 threshVal = (rangeMin + float(j) * stepSize) #通过阈值比较对数据进行分类 predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal) #初始化错误计数向量 errArr = mat(ones((m,1))) #如果预测结果和标签相同，则相应位置0 errArr[predictedVals == labelMat] = 0 #计算权值误差，这就是AdaBoost和分类器交互的地方 weightedError = D.T * errArr #打印输出所有的值 #print("split: dim %d, thresh %.2f, thresh ineqal: %s, the weighted error is %.3f" % (i, threshVal, inequal, weightedError)) #如果错误率低于minError，则将当前单层决策树设为最佳单层决策树，更新各项值 if weightedError &lt; minError: minError = weightedError bestClasEst = predictedVals.copy() bestStump['dim'] = i bestStump['thresh'] = threshVal bestStump['ineq'] = inequal #返回最佳单层决策树，最小错误率，类别估计值 return bestStump, minError, bestClasEst &emsp;&emsp;测试： 12345678&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; D = mat(ones((5,1))/5)&gt;&gt;&gt; adaboost.buildStump(datMat, classLabels, D)(&#123;'dim': 0, 'thresh': 1.3, 'ineq': 'lt'&#125;, matrix([[ 0.2]]), array([[-1.], [ 1.], [-1.], [-1.], [ 1.]])) &emsp;&emsp;上述单层决策树的生成函数是决策树的一个简化版本。它就是所谓的弱学习器，即弱分类算法。其中，weightError是AdaBoost和分类器交互的地方，大家可以留意一下。 完整AdaBoost算法的实现&emsp;&emsp;完成AdaBoost算法的伪代码如下： 1234567对每次迭代： 利用buildStump()函数找到最佳的单层决策树 将最佳单层决策树加入到单层决策树数组 计算alpha 计算新的权重向量D 更新累计类别估计值 如果错误率等于0.0，则退出循环 &emsp;&emsp;代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def adaBoostTrainDS(dataArr, classLabels, numIt = 40): """ Function： 找到最低错误率的单层决策树 Input： dataArr：数据集 classLabels：数据标签 numIt：迭代次数 Output： weakClassArr：单层决策树列表 aggClassEst：类别估计值 """ #初始化列表，用来存放单层决策树的信息 weakClassArr = [] #获取数据集行数 m = shape(dataArr)[0] #初始化向量D每个值均为1/m，D包含每个数据点的权重 D = mat(ones((m,1))/m) #初始化列向量，记录每个数据点的类别估计累计值 aggClassEst = mat(zeros((m,1))) #开始迭代 for i in range(numIt): #利用buildStump()函数找到最佳的单层决策树 bestStump, error, classEst = buildStump(dataArr, classLabels, D) #print("D: ", D.T) #根据公式计算alpha的值，max(error, 1e-16)用来确保在没有错误时不会发生除零溢出 alpha = float(0.5 * log((1.0 - error) / max(error, 1e-16))) #保存alpha的值 bestStump['alpha'] = alpha #填入数据到列表 weakClassArr.append(bestStump) #print("classEst: ", classEst.T) #为下一次迭代计算D expon = multiply(-1 * alpha * mat(classLabels).T, classEst) D = multiply(D, exp(expon)) D = D / D.sum() #累加类别估计值 aggClassEst += alpha * classEst #print("aggClassEst: ", aggClassEst.T) #计算错误率，aggClassEst本身是浮点数，需要通过sign来得到二分类结果 aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T, ones((m,1))) errorRate = aggErrors.sum() / m print("total error: ", errorRate) #如果总错误率为0则跳出循环 if errorRate == 0.0: break #返回单层决策树列表和累计错误率 return weakClassArr #return weakClassArr, aggClassEst &emsp;&emsp;测试如下： 123456789101112131415161718&gt;&gt;&gt; from imp import reload&gt;&gt;&gt; reload(adaboost)&lt;module 'adaboost' from 'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'&gt;&gt;&gt;&gt; classifierArr = adaboost.adaBoostTrainDS(datMat, classLabels, 9)D: [[ 0.2 0.2 0.2 0.2 0.2]]classEst: [[-1. 1. -1. -1. 1.]]aggClassEst: [[-0.69314718 0.69314718 -0.69314718 -0.69314718 0.69314718]]total error: 0.2D: [[ 0.5 0.125 0.125 0.125 0.125]]classEst: [[ 1. 1. -1. -1. -1.]]aggClassEst: [[ 0.27980789 1.66610226 -1.66610226 -1.66610226 -0.27980789]]total error: 0.2D: [[ 0.28571429 0.07142857 0.07142857 0.07142857 0.5 ]]classEst: [[ 1. 1. 1. 1. 1.]]aggClassEst: [[ 1.17568763 2.56198199 -0.77022252 -0.77022252 0.61607184]]total error: 0.0&gt;&gt;&gt; classifierArr[&#123;'dim': 0, 'thresh': 1.3, 'ineq': 'lt', 'alpha': 0.6931471805599453&#125;, &#123;'dim': 1, 'thresh': 1.0, 'ineq': 'lt', 'alpha': 0.9729550745276565&#125;, &#123;'dim': 0, 'thresh': 0.90000000000000002, 'ineq': 'lt', 'alpha': 0.8958797346140273&#125;] &emsp;&emsp;我们观察中间的运行结果，可以发现，第一轮迭代中，D中的所有值都相等，于是，只有第一个数据点被错分了。第二轮迭代中，D向量给第一个数据点0.5的权重。这就可以通过变量aggClassEst的符号来了解总的类别。第二次迭代之后，我们就会发现第一个数据点已经正确分类了，但最后一个数据点错分了。D向量中的最后一个元素变成0.5，而D向量中的其他值都变得非常小。最后，第三次迭代后aggClassEst所有值的符号和真实类别标签都完全吻合，那么训练错误率为0，程序就此退出。 基于AdaBoost的分类&emsp;&emsp;一旦拥有了多个弱分类器以及其对应的alpha值，进行测试就变得相当容易了。现在，我们就将之前的代码应用到具体的实例上去。每个分类器的结果以其对应的alpha值作为权重。所有这些弱分类器的结果加权求和就得到了最后的结果。 &emsp;&emsp;代码实现： 12345678910111213141516171819202122232425def adaClassify(datToClass, classifierArr): """ Function： AdaBoost分类函数 Input： datToClass：待分类样例 classifierArr：多个弱分类器组成的数组 Output： sign(aggClassEst)：分类结果 """ #初始化数据集 dataMatrix = mat(datToClass) #获得待分类样例个数 m = shape(dataMatrix)[0] #构建一个初始化为0的列向量，记录每个数据点的类别估计累计值 aggClassEst = mat(zeros((m,1))) #遍历每个弱分类器 for i in range(len(classifierArr)): #基于stumpClassify得到类别估计值 classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq']) #累加类别估计值 aggClassEst += classifierArr[i]['alpha']*classEst #打印aggClassEst，以便我们了解其变化情况 #print(aggClassEst) #返回分类结果，aggClassEst大于0则返回+1，否则返回-1 return sign(aggClassEst) &emsp;&emsp;测试结果： 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; from imp import reload&gt;&gt;&gt; reload(adaboost)&lt;module 'adaboost' from 'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'&gt;&gt;&gt;&gt; datMat, classLabels = adaboost.loadSimpData()&gt;&gt;&gt; classifierArr = adaboost.adaBoostTrainDS(datMat, classLabels, 30)D: [[ 0.2 0.2 0.2 0.2 0.2]]classEst: [[-1. 1. -1. -1. 1.]]aggClassEst: [[-0.69314718 0.69314718 -0.69314718 -0.69314718 0.69314718]]total error: 0.2D: [[ 0.5 0.125 0.125 0.125 0.125]]classEst: [[ 1. 1. -1. -1. -1.]]aggClassEst: [[ 0.27980789 1.66610226 -1.66610226 -1.66610226 -0.27980789]]total error: 0.2D: [[ 0.28571429 0.07142857 0.07142857 0.07142857 0.5 ]]classEst: [[ 1. 1. 1. 1. 1.]]aggClassEst: [[ 1.17568763 2.56198199 -0.77022252 -0.77022252 0.61607184]]total error: 0.0&gt;&gt;&gt; classifierArr[&#123;'dim': 0, 'thresh': 1.3, 'ineq': 'lt', 'alpha': 0.6931471805599453&#125;, &#123;'dim': 1, 'thresh': 1.0, 'ineq': 'lt', 'alpha': 0.9729550745276565&#125;, &#123;'dim': 0, 'thresh': 0.90000000000000002, 'ineq': 'lt', 'alpha': 0.8958797346140273&#125;]&gt;&gt;&gt; adaboost.adaClassify([0,0], classifierArr)[[-0.69314718]][[-1.66610226]][[-2.56198199]]matrix([[-1.]])&gt;&gt;&gt; adaboost.adaClassify([[5,5],[0,0]], classifierArr)[[ 0.69314718] [-0.69314718]][[ 1.66610226] [-1.66610226]][[ 2.56198199] [-2.56198199]]matrix([[ 1.], [-1.]]) &emsp;&emsp;我们可以看到，随着迭代的进行，分类结果越来越强。下面我们换个数据集。 在一个难数据集上应用AdaBoost&emsp;&emsp;这次我们在之前给出的马疝病数据集上应用AdaBoost分类器，之前用的是Logistic回归。 &emsp;&emsp;示例：在一个难数据集上的AdaBoost应用 收集数据：提供的文本文件。 准备数据：确保类别标签是+1和-1而非1和0。 分析数据：手工检查数据。 训练算法：在数据上，利用adaBoostTrainDS()函数训练出一系列的分类器。 测试算法：我们拥有两个数据集。在不采用随机抽样的方法下，我们就会对AdaBoost和Logistic回归的结果进行完全对等的比较。 使用算法：观察该例子上的错误率。不过，这可以构建一个web网站，让驯马师输入马的症状然后预测马是否会死去。 &emsp;&emsp;加入我们最熟悉的代码，唯一的区别就是这次是自动识别特征数目的。 12345678910111213141516171819202122232425262728293031def loadDataSet(fileName): """ Function： 自适应数据加载函数 Input： fileName：文件名称 Output： dataMat：数据集 labelMat：类别标签 """ #自动获取特征个数，这是和之前不一样的地方 numFeat = len(open(fileName).readline().split('\t')) #初始化数据集和标签列表 dataMat = []; labelMat = [] #打开文件 fr = open(fileName) #遍历每一行 for line in fr.readlines(): #初始化列表，用来存储每一行的数据 lineArr = [] #切分文本 curLine = line.strip().split('\t') #遍历每一个特征，某人最后一列为标签 for i in range(numFeat-1): #将切分的文本全部加入行列表中 lineArr.append(float(curLine[i])) #将每个行列表加入到数据集中 dataMat.append(lineArr) #将每个标签加入标签列表中 labelMat.append(float(curLine[-1])) #返回数据集和标签列表 return dataMat, labelMat &emsp;&emsp;分类结果： 12345678910111213141516171819202122232425&gt;&gt;&gt; from imp import reload&gt;&gt;&gt; reload(adaboost)&lt;module 'adaboost' from 'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'&gt;&gt;&gt;&gt; datArr, labelArr = adaboost.loadDataSet('horseColicTraining2.txt')&gt;&gt;&gt; classifierArr = adaboost.adaBoostTrainDS(datArr, labelArr, 10)total error: 0.284280936455total error: 0.284280936455total error: 0.247491638796total error: 0.247491638796total error: 0.254180602007total error: 0.240802675585total error: 0.240802675585total error: 0.220735785953total error: 0.247491638796total error: 0.230769230769&gt;&gt;&gt; testArr, testLabelArr = adaboost.loadDataSet('horseColicTest2.txt')&gt;&gt;&gt; prediction10 = adaboost.adaClassify(testArr, classifierArr)&gt;&gt;&gt; errArr = mat(ones((67,1)))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'mat' is not defined&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; errArr = mat(ones((67,1)))&gt;&gt;&gt; errArr[prediction10 != mat(testLabelArr).T].sum()16.0 &emsp;&emsp;书上给了个表，我们直接来看表格数据： Number of Classifiers Training Error Test Error 1 0.28 0.27 10 0.23 0.24 50 0.19 0.21 100 0.19 0.22 500 0.16 0.25 1000 0.14 0.31 10000 0.11 0.33 &emsp;&emsp;我们发现，测试错误率在到达一个最小值之后又开始上升了。这类现象就是过拟合（overfitting）。有文献称，对于表现好的数据集，AdaBoost的测试错误率就会达到一个稳定值，并不会随着分类器的增多而上升。但是别忘了，我们这个数据集可是有百分之三十的缺失值哦。 &emsp;&emsp;很多人认为，AdaBoost和SVM是监督机器学习中最强大的两种方法。实际上，这两者之间拥有不少相似之处。我们可以把弱分类器想象成SVM中的一个核函数，也可以按照最大化某个最小间隔的方式重写AdaBoost算法。而他们的不同之处在于所定义的间隔计算方式有所不同。因此导致的结果也不同。特别是在高位空间下，这两者之间的差异就会更加明显。 &emsp;&emsp;至此，分类算法部分全部介绍完了，之后的回归、无监督学习等等，有机会了再更吧。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>AdaBoost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之支持向量机（1）算法概述]]></title>
    <url>%2F2017%2F11%2F05%2Fml-14%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch06 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;这两周把之前落下的公式推导恶补了一下，导致博客更新不及时。本系列博客涉及到的公式推导目前来看就两部分，一部分是logistic回归（最大熵问题也算在这里面了），一部分就是SVM（重头戏）。这两部分的公式我是都自己推导完了，但是还没整理成博客内容进行发布。我的博客都是先在小书匠上面做笔记，整理之后再发布的，但是由于公式推导部分之前全是手稿，码到小书匠上需要花费一定时间，加之最近项目催得紧，所以公式推导部分更新可能会滞后相当长的一段时间。但是，《机器学习实战》这本书的内容还是打算按照原计划进度更新下去。 &emsp;&emsp;有人说，支持向量机（ Support Vector Machines， SVM ）是最好的现成分类器，这里所谓的“现成”指的是分类器不加修改即可直接使用。同时，这就意味着在数据上应用基本形式 SVM 分类器就可以得到低错误率的结果。 SVM 能够对训练集之外的数据点做出很好的分类决策。 &emsp;&emsp;本篇博文主要讲述SVM的基本概念。 基于最大间隔分隔数据支持向量机： 优点：泛化错误率低，计算开销不大，结果易解释。 缺点：对参数调节和核函数的选择敏感，原始分类器不加修饰仅适用于处理二分类问题。 试用数据类型：数值型和标称型数据。 &emsp;&emsp;在介绍SVM之前，先解释几个概念。来看看下面这堆数据，我们能否画出一条直线将圆形点和方形点分开？ &emsp;&emsp;有点复杂？没关系，我们先来看看下图A中的两组数据，它们之间已经分隔得足够开，因此很容易就可以在图中画出一条直线将两组数据点分开。在这种情况下，这种数据被称为线性可分（ linearly separable ）数据。稍后当直线不能将数据点分开时，我们会对上述假设做一些修改。 &emsp;&emsp;上述将数据集分隔开来的直线称为分隔超平面（ separating hyperplane ）。上面的数据是二维的，所以此时分隔超平面就萎缩成一条直线了。如果数据时1024维的，那么就需要一个1023维的某某对象来对数据进行分隔。这个1023维的某某对象被称为超平面（ hyperplane ），也就是分类的决策边界。分布在超平面一侧的所有数据都属于某个类别，而分布在另一侧的所有数据则属于另一个类别。 &emsp;&emsp;我们再来看框B到框D中的三条直线，它们都能将数据分隔开，但是其中哪一个更好呢？是否应该最小化数据点到分隔超平面的平均距离来求最佳直线？如果是那样，是不是就意味着框B和框C就真的比框D中的直线好呢？有木有感觉有点寻找最佳拟合直线的感觉？是的，上述做法确实有点像直线拟合，但并非最佳方案。我们希望找到离分隔超平面最近的点，确保它们离分割面的距离尽可能远。这里点到分割面的距离被称为间隔（ margin ）。我们希望这个距离尽可能地大，这样鲁棒性比较好。 &emsp;&emsp;支持向量（ support vector ）就是离分隔超平面最近的那些点。接下来要试着最大化支持向量到分隔面的距离，需要找到此问题的优化求解方法。 寻找最大间隔&emsp;&emsp;分隔超平面的形式可以携程$ w^Tx + b $。要计算点A到分隔超平面的距离，就必须给出点到分隔面的法线或垂线的长度，该值为$ |w^Tx + b| / \begin{Vmatrix} w \end{Vmatrix} $。这里的常数b类似于Logistic回归中的截距$w_0$。这里的向量w和常数b一起描述了所给数据的分隔线或超平面。接下来我们讨论分类器。 分类器求解的优化问题&emsp;&emsp;理解分类器工作原理将有助于理解基于优化问题的分类器求解过程。输入数据给分类器会输出一个类别标签，这相当于一个类似于Sigmoid的函数在作用。下面将使用类似单位阶跃函数对$ w^Tx + b $作用得到$ f(w^Tx + b) $，其中当u &lt; 0时f(u)输出-1，反之输出+1。Logistic那里的类别标签是0或1。 &emsp;&emsp;这里的类别标签之所以采用-1或+1，是因为它们仅仅相差一个符号，方便数学上的处理。我们可以通过一个统一公式来表示间隔或者数据点到分隔超平面的距离，而不必担心数据到底属于哪一类。间隔通过$ label · (w^Tx + b) $来计算，这时就能体现出-1和+1类的好处了。如果数据点处于正方向（+1类），并且离分隔超平面很远的位置时，$ w^Tx + b $会是一个很大的正数，同时$ label · (w^Tx + b) $也会是一个很大的正数；同理，当数据点处于负方向（-1类）并且离分隔超平面很远的位置时，$ label · (w^Tx + b) $仍然是一个很大的正数。 &emsp;&emsp;现在的目标就是要找出分类器定义中的w和b。那么，我们就需要找到具有最小间隔的数据点（支持向量），然后对该间隔最大化。可以写作： $$ arg max_{w,b}{min_n(label · (w^Tx + b)) · \frac{1}{\begin{Vmatrix} w \end{Vmatrix}}}$$ &emsp;&emsp;直接求解上述问题相当困难呐，对乘积进行优化是一种很鸡肋的事情啊，因此我们要做的是固定其中一个因子而最大化其他因子。如果令所有支持向量的$ label · (w^Tx + b) $都为1，那么就可以通过求$ \begin{Vmatrix} w \end{Vmatrix}^{-1} $的最大值来得到最终解。但是，只有那些离分隔超平面最近的点得到的值才为1，而离超平面越远的数据点，其$ label · (w^Tx + b) $的值就越大。 &emsp;&emsp;上述问题是一个带约束条件的最优化问题，这里的约束条件就是$ label · (w^Tx + b) \geq 1.0 $。对于这类优化问题，有一个非常著名的求解方法，即拉格朗日乘子法。这里的约束条件都是基于数据点的，因此我们可以将超平面写成数据点的形式。于是，优化目标函数最后可以写成： $$ max\alpha[\sum^m{i=1}\alpha - \frac{1}{2} \sum^m_{i,j=1}label^{(i)}·label^{(j)}· \alpha_i·\alphaj \left\langle x{(i)},x_{(j)} \right\rangle ] $$ &emsp;&emsp;其约束条件为： $$ \alpha \geq 0, \sum^m_{i-1}\alpha_i·label^{(i)} = 0 $$ &emsp;&emsp;一切都是那么完美，但是这里有个假设：数据必须100%线性可分。数据如果不干净了，我们就需要引入所谓的松弛变量（ slack variable ），来允许有些数据点可以处于分隔面的错误一侧。这样我们的优化目标就能保持仍然不变，但是约束条件更改为： $$ C \geq \alpha \geq 0, \sum^m_{i-1}\alpha_i·label^{(i)} = 0 $$ &emsp;&emsp;这里的常数C常用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0”这两个目标的权重。我们可以通过调节C来得到不同的结果。一旦求出了所有的alpha，那么分隔超平面就可以通过这些alpha来表达。这一结论非常直接，SVM中的主要工作就是求解这些alpha，从而求出w，然后利用$ w^Tx + b $来分类。 SVM应用的一般框架&emsp;&emsp;在kNN中，我们定义了构建机器学习应用的一般步骤，但是这些步骤会随着机器学习任务或算法的不同而有所改变，因此有必要在此探讨如何在本章中实现他们。 Logistic回归的一般过程： 收集数据：采用任意方法收集数据。 准备数据：需要数值型数据 分析数据：有助于可视化分隔超平面。 训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优。 测试算法：十分简单的计算过程就可以实现。 使用算法：几乎所有分类问题都可以使用SVM，值得一提的是，SVM本身是一个二分类分类器，对多类问题应用SVM需要对代码做一些修改。 &emsp;&emsp;到目前为止，我们已经了解了SVM相关的概念，我们当然希望能够通过编程，在数据集上将这些理论付诸实践。下一节将介绍一个简单而又强大的实现算法—序列最小优化（ Sequential MInimal Optimization，SMO ）算法。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之支持向量机（3）完整版SMO]]></title>
    <url>%2F2017%2F11%2F05%2Fml-16%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch06 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;在小规模数据集上，上一篇文章中的简化版SMO是没有问题的，但是在更大的数据集上，运行速度就会变慢。 &emsp;&emsp;完整版SMO和简化版SMO，实现alpha的更改个代数运算的优化环节一模一样。在优化过程中，唯一的不同就是选择alpha的方式。完整版的SMO算法应用了一些能够提速的启发方法。 &emsp;&emsp;Platt SMO算法通过一个外循环来选择第一个alpha，并且其选择过程会在两种方式之间进行切换：一种是在所有数据集上进行单遍扫描，另一种则是在非边界alpha（不等于边界0或C的alpha值）中实现单遍扫描。对整个数据集的扫描很容易，前面已经实现了，而实现非边界alpha值的扫描时，需要建立这些alpha值得列表，然后再对这个表进行遍历。同时，该步骤会跳过那些已知的不会改变的alpha值。 &emsp;&emsp;在选择第一个alpha值之后，算法会通过一个内循环来选择第二个alpha。在优化过程中，会通过最大化步长的方式来获得第二个alpha值。在简化版SMO算法中，我们会在选择j之后计算错误率Ej。但在这里，我们会建立一个全局的缓存用于保存误差值，并从中选择使得步长或者Ei-Ej最大的alpha值。 支持函数&emsp;&emsp;和简化版一样，完整版也需要一些支持函数。 首要的事情就是建立一个数据结构来保存所有的重要值，而这个过程可以通过一个对象来完成； 对于给定的alpha值，第一个辅助函数calcEk()能够计算E值并返回（因为调用频繁，所以必须要单独拎出来）； selectJ()用于选择第二个alpha或者说内循环的alpha值，选择合适的值以保证在每次优化中采用最大步长； updateEk()用于计算误差值并将其存入缓存中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100'''#######********************************Non-Kernel VErsions below'''#######********************************class optStruct: """ Function： 存放运算中重要的值 Input： dataMatIn：数据集 classLabels：类别标签 C：常数C toler：容错率 Output： X：数据集 labelMat：类别标签 C：常数C tol：容错率 m：数据集行数 b：常数项 alphas：alphas矩阵 eCache：误差缓存 """ def __init__(self, dataMatIn, classLabels, C, toler): self.X = dataMatIn self.labelMat = classLabels self.C = C self.tol = toler self.m = shape(dataMatIn)[0] self.alphas = mat(zeros((self.m, 1))) self.b = 0 self.eCache = mat(zeros((self.m, 2)))def calcEk(oS, k): """ Function： 计算误差值E Input： oS：数据结构 k：下标 Output： Ek：计算的E值 """ #计算fXk，整个对应输出公式f(x)=w`x + b fXk = float(multiply(oS.alphas, oS.labelMat).T * (oS.X * oS.X[k,:].T)) + oS.b #计算E值 Ek = fXk - float(oS.labelMat[k]) #返回计算的误差值E return Ekdef selectJ(i, oS, Ei): """ Function： 选择第二个alpha的值 Input： i：第一个alpha的下标 oS：数据结构 Ei：计算出的第一个alpha的误差值 Output： j：第二个alpha的下标 Ej：计算出的第二个alpha的误差值 """ #初始化参数值 maxK = -1; maxDeltaE = 0; Ej = 0 #构建误差缓存 oS.eCache[i] = [1, Ei] #构建一个非零列表，返回值是第一个非零E所对应的alpha值，而不是E本身 validEcacheList = nonzero(oS.eCache[:, 0].A)[0] #如果列表长度大于1，说明不是第一次循环 if (len(validEcacheList)) &gt; 1: #遍历列表中所有元素 for k in validEcacheList: #如果是第一个alpha的下标，就跳出本次循环 if k == i: continue #计算k下标对应的误差值 Ek = calcEk(oS, k) #取两个alpha误差值的差值的绝对值 deltaE = abs(Ei - Ek) #最大值更新 if (deltaE &gt; maxDeltaE): maxK = k; maxDeltaE = deltaE; Ej = Ek #返回最大差值的下标maxK和误差值Ej return maxK, Ej #如果是第一次循环，则随机选择alpha，然后计算误差 else: j = selectJrand(i, oS.m) Ej = calcEk(oS, j) #返回下标j和其对应的误差Ej return j, Ejdef updateEk(oS, k): """ Function： 更新误差缓存 Input： oS：数据结构 j：alpha的下标 Output： 无 """ #计算下表为k的参数的误差 Ek = calcEk(oS, k) #将误差放入缓存 oS.eCache[k] = [1, Ek] 优化例程&emsp;&emsp;接下来简单介绍一下用于寻找决策边界的优化例程。 &emsp;&emsp;大部分代码和之前的smoSimple()是一样的，区别在于： 使用了自己的数据结构，该结构在oS中传递； 使用selectJ()而不是selectJrand()来选择第二个alpha的值； 在alpha值改变时更新Ecache。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def innerL(i, oS): """ Function： 完整SMO算法中的优化例程 Input： oS：数据结构 i：alpha的下标 Output： 无 """ #计算误差 Ei = calcEk(oS, i) #如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化 if ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)): #启发式选择第二个alpha值 j, Ej = selectJ(i, oS, Ei) #利用copy存储刚才的计算值，便于后期比较 alphaIold = oS.alphas[i].copy(); alpahJold = oS.alphas[j].copy(); #保证alpha在0和C之间 if (oS.labelMat[i] != oS.labelMat[j]): L = max(0, oS.alphas[j] - oS. alphas[i]) H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i]) else: L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C) H = min(oS.C, oS.alphas[j] + oS.alphas[i]) #如果界限值相同，则不做处理直接跳出本次循环 if L == H: print("L==H"); return 0 #最优修改量，求两个向量的内积（核函数） eta = 2.0 * oS.X[i, :]*oS.X[j, :].T - oS.X[i, :]*oS.X[i, :].T - oS.X[j, :]*oS.X[j, :].T #如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理 if eta &gt;= 0: print("eta&gt;=0"); return 0 #计算新的alphas[j]的值 oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta #对新的alphas[j]进行阈值处理 oS.alphas[j] = clipAlpha(oS.alphas[j], H, L) #更新误差缓存 updateEk(oS, j) #如果新旧值差很小，则不做处理跳出本次循环 if (abs(oS.alphas[j] - alpahJold) &lt; 0.00001): print("j not moving enough"); return 0 #对i进行修改，修改量相同，但是方向相反 oS.alphas[i] += oS.labelMat[j] * oS.labelMat[i] * (alpahJold - oS.alphas[j]) #更新误差缓存 updateEk(oS, i) #更新常数项 b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[i, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[i, :]*oS.X[j, :].T b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[j, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[j, :]*oS.X[j, :].T #谁在0到C之间，就听谁的，否则就取平均值 if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1 elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[i]): oS.b = b2 else: oS.b = (b1 + b2) / 2.0 #成功返回1 return 1 #失败返回0 else: return 0 外循环代码&emsp;&emsp;外循环代码的输入和函数smoSimple()完全一样。整个代码的主体是while循环，终止条件：当迭代次数超过指定的最大值，或者遍历整个集合都未对任意alpha对进行修改时，就退出循环。while循环内部与smoSimple()中有所不同，一开始的for循环在数据集上遍历任意可能的alpha。通过innerL()来选择第二个alpha，并在可能时对其进行优化处理。如果有任意一对alpha值发生改变，就会返回1.第二个for循环遍历所有的非边界alpha值，也就是不在边界0或C上的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def smoP(dataMatIn, classLabels, C, toler, maxIter): """ Function： 完整SMO算法 Input： dataMatIn：数据集 classLabels：类别标签 C：常数C toler：容错率 maxIter：最大的循环次数 Output： b：常数项 alphas：数据向量 """ #新建数据结构对象 oS = optStruct(mat(dataMatIn), mat(classLabels).transpose(), C, toler) #初始化迭代次数 iter = 0 #初始化标志位 entireSet = True; alphaPairsChanged = 0 #终止条件：迭代次数超限、遍历整个集合都未对alpha进行修改 while (iter &lt; maxIter) and ((alphaPairsChanged &gt; 0) or (entireSet)): alphaPairsChanged = 0 #根据标志位选择不同的遍历方式 if entireSet: #遍历任意可能的alpha值 for i in range(oS.m): #选择第二个alpha值，并在可能时对其进行优化处理 alphaPairsChanged += innerL(i, oS) print("fullSet, iter: %d i: %d, pairs changed %d" % (iter, i, alphaPairsChanged)) #迭代次数累加 iter += 1 else: #得出所有的非边界alpha值 nonBoundIs = nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0] #遍历所有的非边界alpha值 for i in nonBoundIs: #选择第二个alpha值，并在可能时对其进行优化处理 alphaPairsChanged += innerL(i, oS) print("non-bound, iter: %d i: %d, pairs changed %d" % (iter, i, alphaPairsChanged)) #迭代次数累加 iter += 1 #在非边界循环和完整遍历之间进行切换 if entireSet: entireSet = False elif (alphaPairsChanged == 0): entireSet =True print("iteration number: %d" % iter) #返回常数项和数据向量 return oS.b, oS.alphas &emsp;&emsp;测试代码，大家有兴趣的话可以多次运行计算一下运行时间的平均值，看看和简化版相比快了多少。 12345678910111213141516&gt;&gt;&gt; reload(svmMLiA)&lt;module 'svmMLiA' from 'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'&gt;&gt;&gt;&gt; dataArr, labelArr = svmMLiA.loadDataSet('testSet.txt')&gt;&gt;&gt; b, alphas = svmMLiA.smoP(dataArr, labelArr, 0.6, 0.001, 40)L==HfullSet, iter: 0 i: 0, pairs changed 0L==HfullSet, iter: 0 i: 1, pairs changed 0fullSet, iter: 0 i: 2, pairs changed 1L==H···j not moving enoughfullSet, iter: 2 i: 97, pairs changed 0fullSet, iter: 2 i: 98, pairs changed 0fullSet, iter: 2 i: 99, pairs changed 0iteration number: 3 &emsp;&emsp;像之前一样，打印b和alpha，得出的数据用来画图。 1234567891011121314151617181920&gt;&gt;&gt; bmatrix([[-2.89901748]])&gt;&gt;&gt; alphas[alphas &gt; 0]matrix([[ 0.06961952, 0.0169055 , 0.0169055 , 0.0272699 , 0.04522972, 0.0272699 , 0.0243898 , 0.06140181, 0.06140181]])&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; shape(alphas[alphas &gt; 0])(1, 9)&gt;&gt;&gt; for i in range(100):... if alphas[i] &gt; 0.0: print(dataArr[i], labelArr[i])... [3.542485, 1.977398] -1.0[2.114999, -0.004466] -1.0[8.127113, 1.274372] 1.0[4.658191, 3.507396] -1.0[8.197181, 1.545132] 1.0[7.40786, -0.121961] 1.0[6.960661, -0.245353] 1.0[6.080573, 0.418886] 1.0[3.107511, 0.758367] -1.0 &emsp;&emsp;常数C一方面要保障所有样例的间隔不小于1.0，另一方面又要使得分类间隔要尽可能大，并且要在这两方面之间平衡。如果C很大，那么分类器就会将力图通过分隔超平面对多有的样例都正确分类。这种优化结果如下图，很明显，支持向量变多了。如果数据集非线性可分，就会发现支持向量会在超平面附近聚集成团。 分类测试好了，终于可以拿我们计算出来的alpha值进行分类了。首先必须基于alpha值得到超平面，这也包括了w的计算。 123456789101112131415161718192021def calcWs(alphas, dataArr, classLabels): """ Function： 计算W Input： alphas：数据向量 dataArr：数据集 classLabels：类别标签 Output： w：w*x+b中的w """ #初始化参数 X = mat(dataArr); labelMat = mat(classLabels).transpose() #获取数据行列值 m,n = shape(X) #初始化w w = zeros((n,1)) #遍历alpha，更新w for i in range(m): w += multiply(alphas[i]*labelMat[i],X[i,:].T) #返回w值 return w &emsp;&emsp;上述代码中最重要的就是for循环，实现多个数的乘积。虽然for循环遍历了数据集中的所有数据，但是最终起作用的只有支持向量。 1234567891011121314151617181920&gt;&gt;&gt; reload(svmMLiA)&lt;module 'svmMLiA' from 'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'&gt;&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; ws = svmMLiA.calcWs(alphas, dataArr, labelArr)&gt;&gt;&gt; wsarray([[ 0.65307162], [-0.17196128]])&gt;&gt;&gt; datMat = mat(dataArr)&gt;&gt;&gt; datMat[0]* mat(ws)+bmatrix([[-0.92555695]])&gt;&gt;&gt; labelArr[0]-1.0&gt;&gt;&gt; datMat[1]* mat(ws)+bmatrix([[-1.36706674]])&gt;&gt;&gt; labelArr[1]-1.0&gt;&gt;&gt; datMat[2]* mat(ws)+bmatrix([[ 2.30436336]])&gt;&gt;&gt; labelArr[2]1.0 &emsp;&emsp;上面的测试中，计算值大于0属于1类，小于0属于-1类。 &emsp;&emsp;至此，线性分类器介绍完了，如果数据集非线性可分，那么我们就需要引入核函数的概念了，下一篇将进行介绍。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之支持向量机（2）简化版SMO]]></title>
    <url>%2F2017%2F11%2F05%2Fml-15%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch06 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;SVM有很多实现，但我们只关注其中最流行的一种实现，即序列最小优化（ Sequential MInimal Optimization，SMO ）算法。 &emsp;&emsp;下面我们就开始讨论SMO算法，本篇博文先给出一个简化的版本，以便我们能够正确理解它的工作流程。 Platt的SMO算法&emsp;&emsp;1996年，伟大的John Platt发布了一个称为SMO的强大算法，用于训练SVM。Platt的SMO算法是将大优化问题分解为多个小优化问题来求解的。这些小优化问题往往很容易求解，并且对它们进行顺序来求解的结果与将他们作为整体来求解的结果是完全一致的，但是求解时间却大大缩短。 &emsp;&emsp;SMO算法的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面。 &emsp;&emsp;SMO的工作原理是：每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的“合适”就是指两个alpha必须要符合一定的条件，条件之一就是这两个alpha必须要在间隔边界之外，另一个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。 应用简化版SMO算法处理小规模数据集&emsp;&emsp;Platt SMO算法中的外循环确定要优化的最佳alpha对。而简化版会跳过这一部分，首先在数据集上遍历每一个alpha，然后在剩下的alpha集合中随机选择另一个alpha来构成alpha对。这里有一点相当重要，就是我们要同时改变两个alpha，因为我们需要满足一个约束条件： 123$$\sum \alpha_i · label^&#123;(i)&#125; = 0$$ &emsp;&emsp;由于改变一个alpha可能会导致该约束条件失效，因为需要同时改变两个alpha，一增一减，改变的量相同。 &emsp;&emsp;在实现简化版SMO之前，我们需要先构造几个辅助函数。打开文本编辑器，将下面的代码加入svmMLiA.py中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-09-21 21:02:51# @Author : WordZzzz (wordzzzz@foxmail.com)# @Link : http://blog.csdn.net/u011475210from numpy import *from time import sleepdef loadDataSet(fileName): """ Function： 加载数据集 Input： fileName：数据集 Output： dataMat：数据矩阵 labelMat：类别标签矩阵 """ #初始化数据列表 dataMat = [] #初始化标签列表 labelMat = [] #打开文件 fr = open(fileName) #遍历每一行数据，读取数据和标签 for line in fr.readlines(): #strip删除头尾空白字符，然后再进行分割 lineArr = line.strip().split('\t') #填充数据集 dataMat.append([float(lineArr[0]), float(lineArr[1])]) #填充类别标签 labelMat.append(float(lineArr[2])) #返回数据集和标签列表 return dataMat, labelMatdef selectJrand(i, m): """ Function： 随机选择 Input： i：alpha下标 m：alpha数目 Output： j：随机选择的alpha下标 """ #初始化下标j j = i #随机化产生j，直到不等于i while (j == i): j = int(random.uniform(0,m)) #返回j的值 return jdef clipAlpha(aj, H, L): """ Function： 设定alpha阈值 Input： aj：alpha的值 H：alpha的最大值 L：alpha的最小值 Output： aj：处理后的alpha的值 """ #如果输入alpha的值大于最大值，则令aj=H if aj &gt; H: aj = H #如果输入alpha的值小于最小值，则令aj=L if L &gt; aj: aj = L #返回处理后的alpha的值 return aj &emsp;&emsp;首先是我们熟悉的老哥loadDataSet()，用来打开文件并对其进行解析，从而得到每行的类别标签和整个数据矩阵；然后是selectJrand()，用来随机选择第二个alpha的下标（只要和第一个alpha下标不一样就行）；最后一个是clipAlpha()函数，用于设定阈值，限制alpha的值。 123456&gt;&gt;&gt; reload(svmMLiA)&lt;module 'svmMLiA' from 'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'&gt;&gt;&gt;&gt; dataArr, labelArr = svmMLiA.loadDataSet('testSet.txt')&gt;&gt;&gt; labelArr[-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]&gt;&gt;&gt; &emsp;&emsp;简化版SMO伪代码： 12345678创建一个alpha向量并将其初始化为0向量当迭代次数小于最大迭代次数时（外循环）： 对数据集中的每个数据向量（内循环）： 如果该数据向量可以被优化： 随机选择另外一个数据向量 同时优化这两个向量 如果两个向量都不能被优化，退出内循环 如果所有向量都没被优化，则增加迭代数目，继续下一次循环 &emsp;&emsp;下述代码是SMO算法中的一个有效版本，如果看不懂，可以先找SVM的公式推导看看。打开文本编辑器，将下面的代码加入svmMLiA.py中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def smoSimple(dataMatIn, classLabels, C, toler, maxIter): """ Function： 简化版SMO算法 Input： dataMatIn：数据集 classLabels：类别标签 C：常数C toler：容错率 maxIter：最大的循环次数 Output： b：常数项 alphas：数据向量 """ #将输入的数据集和类别标签转换为NumPy矩阵 dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose() #初始化常数项b，初始化行列数m、n b = 0; m,n = shape(dataMatrix) #初始化alphas数据向量为0向量 alphas = mat(zeros((m,1))) #初始化iter变量，存储的是在没有任何alpha改变的情况下遍历数据集的次数 iter = 0 #外循环，当迭代次数小于maxIter时执行 while (iter &lt; maxIter): #alpha改变标志位每次都要初始化为0 alphaPairsChanged = 0 #内循环，遍历所有数据集 for i in range(m): #multiply将alphas和labelMat进行矩阵相乘，求出法向量w(m,1),w`(1,m) #dataMatrix * dataMatrix[i,:].T，求出输入向量x(m,1) #整个对应输出公式f(x)=w`x + b fXi = float(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[i,:].T)) + b #计算误差 Ei = fXi - float(labelMat[i]) #如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化 if ((labelMat[i]*Ei &lt; -toler) and (alphas[i] &lt; C)) or ((labelMat[i] * Ei &gt; toler) and (alphas[i] &gt; 0)): #随机化选择另一个数据向量 j = selectJrand(i, m) #对此向量进行同样的计算 fXj = float(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[j,:].T)) + b #计算误差 Ej = fXj - float(labelMat[j]) #利用copy存储刚才的计算值，便于后期比较 alphaIold = alphas[i].copy(); alpahJold = alphas[j].copy() #保证alpha在0和C之间 if (labelMat[i] != labelMat[j]): L = max(0, alphas[j] - alphas[i]) H = min(C, C + alphas[j] - alphas[i]) else: L = max(0, alphas[j] + alphas[i] - C) H = min(C, alphas[j] + alphas[i]) #如果界限值相同，则不做处理直接跳出本次循环 if L == H: print("L == H"); continue #最优修改量，求两个向量的内积（核函数） eta = 2.0 * dataMatrix[i,:] * dataMatrix[j,:].T - dataMatrix[i,:] * dataMatrix[i,:].T - dataMatrix[j,:] * dataMatrix[j,:].T #如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理 if eta &gt;= 0: print("eta &gt;= 0"); continue #计算新的alphas[j]的值 alphas[j] -= labelMat[j] * (Ei - Ej) / eta #对新的alphas[j]进行阈值处理 alphas[j] = clipAlpha(alphas[j], H, L) #如果新旧值差很小，则不做处理跳出本次循环 if (abs(alphas[j] - alpahJold) &lt; 0.00001): print("j not moving enough"); continue #对i进行修改，修改量相同，但是方向相反 alphas[i] += labelMat[j] * labelMat[i] * (alpahJold - alphas[j]) #新的常数项 b1 = b - Ei - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i,:] * dataMatrix[i,:].T - labelMat[i] * (alphas[j] - alpahJold) * dataMatrix[i,:] * dataMatrix[j,:].T b2 = b - Ej - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i,:] * dataMatrix[j,:].T - labelMat[j] * (alphas[j] - alpahJold) * dataMatrix[j,:] * dataMatrix[j,:].T #谁在0到C之间，就听谁的，否则就取平均值 if (0 &lt; alphas[i]) and (C &gt; alphas[i]): b = b1 elif (0 &lt; alphas[j]) and (C &gt; alphas[j]): b = b2 else: b = (b1 + b2) / 2.0 #标志位加1 alphaPairsChanged += 1 #输出迭代次数，alphas的标号以及标志位的值 print("iter: %d i: %d, pairs changed %d" % (iter, i, alphaPairsChanged)) #如果标志位没变，即没有进行优化，那么迭代值加1 if (alphaPairsChanged == 0): iter += 1 #否则迭代值为0 else: iter = 0 #打印迭代次数 print("iteration number: %d" % iter) #返回常数项和alphas的数据向量 return b, alphas &emsp;&emsp;运行结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; reload(svmMLiA)&lt;module 'svmMLiA' from 'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'&gt;&gt;&gt;&gt; b, alphas = svmMLiA.smoSimple(dataArr, labelArr, 0.6, 0.001, 40)iter: 0 i: 0, pairs changed 1j not moving enoughj not moving enoughiter: 0 i: 5, pairs changed 2j not moving enoughj not moving enoughiter: 0 i: 17, pairs changed 3j not moving enoughj not moving enoughj not moving enoughj not moving enoughj not moving enoughj not moving enoughj not moving enoughiter: 0 i: 54, pairs changed 4j not moving enoughj not moving enoughL == Hj not moving enoughL == Hj not moving enoughiteration number: 0j not moving enoughiter: 0 i: 5, pairs changed 1······iteration number: 0j not moving enoughj not moving enoughj not moving enoughiteration number: 1j not moving enoughj not moving enoughj not moving enough······j not moving enoughj not moving enoughj not moving enoughiteration number: 39j not moving enoughj not moving enoughj not moving enoughiteration number: 40 &emsp;&emsp;上述过程可能需要几分钟才会收敛，一旦运行结束，我们就可以对结果进行查看： 123456789101112131415&gt;&gt;&gt; bmatrix([[-3.87260031]])&gt;&gt;&gt; alphas[alphas &gt; 0]matrix([[ 0.10195497, 0.25933768, 0.0240785 , 0.33721415]])&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; shape(alphas[alphas &gt; 0])(1, 4)&gt;&gt;&gt; for i in range(100):... if alphas[i] &gt; 0.0: print(dataArr[i], labelArr[i])... [4.658191, 3.507396] -1.0[3.457096, -0.082216] -1.0[5.286862, -2.358286] 1.0[6.080573, 0.418886] 1.0&gt;&gt;&gt; &emsp;&emsp;由于SMO算法的随机性，每次运行之后得到的结果不尽相同。alphas[alphas &gt; 0]命令是数组过滤的一个实例，得到仅仅包含大于0的值的矩阵，而且它只对NumPy类型有用，却并不适用于Python中的正则表。 &emsp;&emsp;我们在数据集上把这些支持向量画出来： &emsp;&emsp;希望通过本篇博文，大家对SMO的工作流程有了一定得了解，至于完成版的SMO，WordZzzz将会在下一篇博文介绍给大家。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之支持向量机（4）核函数及其实现]]></title>
    <url>%2F2017%2F11%2F05%2Fml-17%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch06 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;前面三篇讲的都是SVM线性分类器，如果数据集非线性可分（如下图所示），那就需要做些修改了。 &emsp;&emsp;显而易见，在该数据中存在某种可以识别的模式。接下来，我们就需要使用一种称为核函数（kernel）的工具将数据转换成易于分类器理解的形式。在本篇博文中，我们先对核函数进行简单的了解，然后重点研究径向基函数（radial basis function，最流行的核函数）及其实现，最后在我们之前的手写数字识别问题上进行实践。 核函数简介&emsp;&emsp;再看本文章开头的图片，我们似乎可以用一个圆来吧数据划分开来，但是对于线性分类器来说，这好像很难实现。我们或许可以对数据进行某种形式的转换，从而得到某些新的变量来表示数据。在这个例子中，我们将数据从一个特征空间转换到另一个特征空间，在新空间下，我们可以很容易利用已有的工具对数据进行处理。这个过程，学过数学的都知道，即从一个特征空间到另一个特征空间的映射。通常情况下，核函数实现的是低维到高维的映射，以后其他算法涉及到的PCA等，则是高维到低微的映射。经过空间转换之后，我们可以在高维空间解决线性问题，这也就等价于在低维空间中解决非线性问题。 &emsp;&emsp;SVM优化中一个特别好的地方就是，所有的运算都可以写成内积（inner product，也叫点积）的形式。向量的内积指的是两个向量相乘，之后得到单个标量或者数值。我们可以把内积运算替换成核函数，而不必做简化处理。将内积替换成核函数的方式被称为核技巧（kernel trick）或者核“变电”（kernel substation）。 &emsp;&emsp;当然，核函数并不仅仅应用于SVM中，很多其他的机器学习算法也都用到核函数。接下来，我们就来介绍一个流行的核函数，那就是径向基函数。 径向基函数&emsp;&emsp;径向基函数是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。这个距离可以使从向量或者其他向量开始计算的距离。我们用到的径向基函数的高斯版本公式为： $$k(x,y) = exp(\frac{ {-\begin{Vmatrix} x-y \end{Vmatrix} }^2}{2 \sigma^2})$$ &emsp;&emsp;其中，σ是用户定义的用于确定到达率（reach）或者说是函数值跌落到0的速度参数。 &emsp;&emsp;上述高斯核函数将数据从其特征空间映射到跟高维的空间，具体来说这里是映射到一个无穷维的空间。在该数据集上，使用高斯核函数得到一个很好的结果，当然，该函数也可以用于许多其他的数据集，并且也能够得到低错误率的结果。 核函数实现&emsp;&emsp;如果在svmMLiA.py文件中添加一个函数并稍作修改，那么我们就能在已有代码中使用核函数了（所有与核函数实现相关的函数，函数名末尾都是K）。其中主要区分代码在innerLK()和calcEk()中，我已经重点标记出。 &emsp;&emsp;新添加的核转换函数，主要用于填充结构体和后续的计算： 12345678910111213141516171819202122232425262728def kernelTrans(X, A, kTup): """ Function： 核转换函数 Input： X：数据集 A：某一行数据 kTup：核函数信息 Output： K：计算出的核向量 """ #获取数据集行列数 m, n = shape(X) #初始化列向量 K = mat(zeros((m, 1))) #根据键值选择相应核函数 #lin表示的是线性核函数 if kTup[0] == 'lin': K = X * A.T #rbf表示径向基核函数 elif kTup[0] == 'rbf': for j in range(m): deltaRow = X[j,:] - A K[j] = deltaRow * deltaRow.T #对矩阵元素展开计算，而不像在MATLAB中一样计算矩阵的逆 K = exp(K/(-1*kTup[1]**2)) #如果无法识别，就报错 else: raise NameError('Houston We Have a Problem -- That Kernel is not recognized') #返回计算出的核向量 return K &emsp;&emsp;其他函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223class optStructK: """ Function： 存放运算中重要的值 Input： dataMatIn：数据集 classLabels：类别标签 C：常数C toler：容错率 kTup：速度参数 Output： X：数据集 labelMat：类别标签 C：常数C tol：容错率 m：数据集行数 b：常数项 alphas：alphas矩阵 eCache：误差缓存 K：核函数矩阵 """ def __init__(self, dataMatIn, classLabels, C, toler, kTup): self.X = dataMatIn self.labelMat = classLabels self.C = C self.tol = toler self.m = shape(dataMatIn)[0] self.alphas = mat(zeros((self.m, 1))) self.b = 0 self.eCache = mat(zeros((self.m, 2))) """ 主要区分 """ self.K = mat(zeros((self.m, self.m))) for i in range(self.m): self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup) """ 主要区分 """def calcEkK(oS, k): """ Function： 计算误差值E Input： oS：数据结构 k：下标 Output： Ek：计算的E值 """ """ 主要区分 """ #计算fXk，整个对应输出公式f(x)=w`x + b #fXk = float(multiply(oS.alphas, oS.labelMat).T * (oS.X * oS.X[k,:].T)) + oS.b fXk = float(multiply(oS.alphas, oS.labelMat).T*oS.K[:, k] + oS.b) """ 主要区分 """ #计算E值 Ek = fXk - float(oS.labelMat[k]) #返回计算的误差值E return Ekdef selectJK(i, oS, Ei): """ Function： 选择第二个alpha的值 Input： i：第一个alpha的下标 oS：数据结构 Ei：计算出的第一个alpha的误差值 Output： j：第二个alpha的下标 Ej：计算出的第二个alpha的误差值 """ #初始化参数值 maxK = -1; maxDeltaE = 0; Ej = 0 #构建误差缓存 oS.eCache[i] = [1, Ei] #构建一个非零列表，返回值是第一个非零E所对应的alpha值，而不是E本身 validEcacheList = nonzero(oS.eCache[:, 0].A)[0] #如果列表长度大于1，说明不是第一次循环 if (len(validEcacheList)) &gt; 1: #遍历列表中所有元素 for k in validEcacheList: #如果是第一个alpha的下标，就跳出本次循环 if k == i: continue #计算k下标对应的误差值 Ek = calcEkK(oS, k) #取两个alpha误差值的差值的绝对值 deltaE = abs(Ei - Ek) #最大值更新 if (deltaE &gt; maxDeltaE): maxK = k; maxDeltaE = deltaE; Ej = Ek #返回最大差值的下标maxK和误差值Ej return maxK, Ej #如果是第一次循环，则随机选择alpha，然后计算误差 else: j = selectJrand(i, oS.m) Ej = calcEkK(oS, j) #返回下标j和其对应的误差Ej return j, Ejdef updateEkK(oS, k): """ Function： 更新误差缓存 Input： oS：数据结构 j：alpha的下标 Output： 无 """ #计算下表为k的参数的误差 Ek = calcEkK(oS, k) #将误差放入缓存 oS.eCache[k] = [1, Ek]def innerLK(i, oS): """ Function： 完整SMO算法中的优化例程 Input： oS：数据结构 i：alpha的下标 Output： 无 """ #计算误差 Ei = calcEkK(oS, i) #如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化 if ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)): #启发式选择第二个alpha值 j, Ej = selectJK(i, oS, Ei) #利用copy存储刚才的计算值，便于后期比较 alphaIold = oS.alphas[i].copy(); alpahJold = oS.alphas[j].copy(); #保证alpha在0和C之间 if (oS.labelMat[i] != oS.labelMat[j]): L = max(0, oS.alphas[j] - oS. alphas[i]) H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i]) else: L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C) H = min(oS.C, oS.alphas[j] + oS.alphas[i]) #如果界限值相同，则不做处理直接跳出本次循环 if L == H: print("L==H"); return 0 """ 主要区分 """ #最优修改量，求两个向量的内积（核函数） #eta = 2.0 * oS.X[i, :]*oS.X[j, :].T - oS.X[i, :]*oS.X[i, :].T - oS.X[j, :]*oS.X[j, :].T eta = 2.0 * oS.K[i, j] - oS.K[i, i] - oS.K[j, j] """ 主要区分 """ #如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理 if eta &gt;= 0: print("eta&gt;=0"); return 0 #计算新的alphas[j]的值 oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta #对新的alphas[j]进行阈值处理 oS.alphas[j] = clipAlpha(oS.alphas[j], H, L) #更新误差缓存 updateEkK(oS, j) #如果新旧值差很小，则不做处理跳出本次循环 if (abs(oS.alphas[j] - alpahJold) &lt; 0.00001): print("j not moving enough"); return 0 #对i进行修改，修改量相同，但是方向相反 oS.alphas[i] += oS.labelMat[j] * oS.labelMat[i] * (alpahJold - oS.alphas[j]) #更新误差缓存 updateEkK(oS, i) """ 主要区分 """ #更新常数项 #b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[i, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[i, :]*oS.X[j, :].T #b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[j, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[j, :]*oS.X[j, :].T b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, i] - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.K[i, j] b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, j] - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.K[j, j] """ 主要区分 """ #谁在0到C之间，就听谁的，否则就取平均值 if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1 elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[i]): oS.b = b2 else: oS.b = (b1 + b2) / 2.0 #成功返回1 return 1 #失败返回0 else: return 0def smoPK(dataMatIn, classLabels, C, toler, maxIter, kTup = ('lin', 0)): """ Function： 完整SMO算法 Input： dataMatIn：数据集 classLabels：类别标签 C：常数C toler：容错率 maxIter：最大的循环次数 kTup：速度参数 Output： b：常数项 alphas：数据向量 """ #新建数据结构对象 oS = optStructK(mat(dataMatIn), mat(classLabels).transpose(), C, toler, kTup) #初始化迭代次数 iter = 0 #初始化标志位 entireSet = True; alphaPairsChanged = 0 #终止条件：迭代次数超限、遍历整个集合都未对alpha进行修改 while (iter &lt; maxIter) and ((alphaPairsChanged &gt; 0) or (entireSet)): alphaPairsChanged = 0 #根据标志位选择不同的遍历方式 if entireSet: #遍历任意可能的alpha值 for i in range(oS.m): #选择第二个alpha值，并在可能时对其进行优化处理 alphaPairsChanged += innerLK(i, oS) print("fullSet, iter: %d i: %d, pairs changed %d" % (iter, i, alphaPairsChanged)) #迭代次数累加 iter += 1 else: #得出所有的非边界alpha值 nonBoundIs = nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0] #遍历所有的非边界alpha值 for i in nonBoundIs: #选择第二个alpha值，并在可能时对其进行优化处理 alphaPairsChanged += innerLK(i, oS) print("non-bound, iter: %d i: %d, pairs changed %d" % (iter, i, alphaPairsChanged)) #迭代次数累加 iter += 1 #在非边界循环和完整遍历之间进行切换 if entireSet: entireSet = False elif (alphaPairsChanged == 0): entireSet =True print("iteration number: %d" % iter) #返回常数项和数据向量 return oS.b, oS.alphas &emsp;&emsp;接下来我们写测试函数。整个代码中最重要的是for循环开始的那两行，他们给出了如何利用核函数进行分类。首先利用结构初始化方法中使用过的kernelTrans()函数，得到转换后的数据。然后，再用其与前面的alpha及类别标签值求积。特别需要注意观察的是，我们是如何做到只需要支持向量数据就可以进行分类的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def testRbf(k1 = 1.3): """ Function： 利用核函数进行分类的径向基测试函数 Input： k1：径向基函数的速度参数 Output： 输出打印信息 """ #导入数据集 dataArr, labelArr = loadDataSet('testSetRBF.txt') #调用Platt SMO算法 b, alphas = smoPK(dataArr, labelArr, 200, 0.00001, 10000, ('rbf', k1)) #初始化数据矩阵和标签向量 datMat = mat(dataArr); labelMat = mat(labelArr).transpose() #记录支持向量序号 svInd = nonzero(alphas.A &gt; 0)[0] #读取支持向量 sVs = datMat[svInd] #读取支持向量对应标签 labelSV = labelMat[svInd] #输出打印信息 print("there are %d Support Vectors" % shape(sVs)[0]) #获取数据集行列值 m, n = shape(datMat) #初始化误差计数 errorCount = 0 #遍历每一行，利用核函数对训练集进行分类 for i in range(m): #利用核函数转换数据 kernelEval = kernelTrans(sVs, datMat[i,:], ('rbf', k1)) #仅用支持向量预测分类 predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b #预测分类结果与标签不符则错误计数加一 if sign(predict) != sign(labelArr[i]): errorCount += 1 #打印输出分类错误率 print("the training error rate is: %f" % (float(errorCount)/m)) #导入测试数据集 dataArr, labelArr = loadDataSet('testSetRBF2.txt') #初始化误差计数 errorCount = 0 #初始化数据矩阵和标签向量 datMat = mat(dataArr); labelMat = mat(labelArr).transpose() #获取数据集行列值 m, n = shape(datMat) #遍历每一行，利用核函数对测试集进行分类 for i in range(m): #利用核函数转换数据 kernelEval = kernelTrans(sVs, datMat[i,:], ('rbf', k1)) #仅用支持向量预测分类 predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b #预测分类结果与标签不符则错误计数加一 if sign(predict) != sign(labelArr[i]): errorCount += 1 #打印输出分类错误率 print("the test error rate is: %f" % (float(errorCount)/m)) &emsp;&emsp;上述代码分别在训练集和测试集上进行性能测试，打印输出如下： 1234567891011121314151617&gt;&gt;&gt; reload(svmMLiA)&lt;module 'svmMLiA' from 'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'&gt;&gt;&gt;&gt; svmMLiA.testRbf()L==HfullSet, iter: 0 i: 0, pairs changed 0fullSet, iter: 0 i: 1, pairs changed 1fullSet, iter: 0 i: 2, pairs changed 2fullSet, iter: 0 i: 3, pairs changed 3···fullSet, iter: 6 i: 96, pairs changed 0fullSet, iter: 6 i: 97, pairs changed 0fullSet, iter: 6 i: 98, pairs changed 0fullSet, iter: 6 i: 99, pairs changed 0iteration number: 7there are 27 Support Vectorsthe training error rate is: 0.030000the test error rate is: 0.040000 &emsp;&emsp;当然，大家也可以尝试更换不同的k1参数以观察测试错误率、训练错误率、支持向量个数随k1的变化情况。下面个两张图是书上的举例。 &emsp;&emsp;我们会发现，支持向量的数目存在一个最优值。SVM的优点在于它能对数据进行高效分类。如果支持向量太少，就可能会得到一个很差的决策边界；如果支持向量太多，也就是相当于每次都利用整个数据集进行分类，这种分类方法成为kNN（多么熟悉）。 手写识别问题回顾&emsp;&emsp;SVM对kNN的优点在于，SVM只需要保留支持向量就可以获得可比的效果，占用内存大大减小。下面，我们就用SVM来对手写数字进行分类识别（不加修改的SVM只能用于二分类问题，在这里，我们规定，如果是数字9，则为-1，否则为+1）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111def img2vector(filename): """ Function： 32*32图像转换为1*1024向量 Input： filename：文件名称字符串 Output： returnVect：转换之后的1*1024向量 """ #初始化要返回的1*1024向量 returnVect = zeros((1, 1024)) #打开文件 fr = open(filename) #读取文件信息 for i in range(32): #循环读取文件的前32行 lineStr = fr.readline() for j in range(32): #将每行的头32个字符存储到要返回的向量中 returnVect[0, 32*i+j] = int(lineStr[j]) #返回要输出的1*1024向量 return returnVectdef loadImages(dirName): """ Function： 加载图片 Input： dirName：文件路径 Output： trainingMat：训练数据集 hwLabels：数据标签 """ from os import listdir #初始化数据标签 hwLabels = [] #读取文件列表 trainingFileList = listdir(dirName) #读取文件个数 m = len(trainingFileList) #初始化训练数据集 trainingMat = zeros((m,1024)) #填充数据集 for i in range(m): #遍历所有文件 fileNameStr = trainingFileList[i] #提取文件名称 fileStr = fileNameStr.split('.')[0] #提取数字标识 classNumStr = int(fileStr.split('_')[0]) #数字9记为-1类 if classNumStr == 9: hwLabels.append(-1) #其他数字记为+1类 else: hwLabels.append(1) #提取图像向量，填充数据集 trainingMat[i,:] = img2vector('%s/%s' % (dirName, fileNameStr)) #返回数据集和数据标签 return trainingMat, hwLabelsdef testDigits(kTup = ('rbf',10)): """ Function： 手写数字分类函数 Input： kTup：核函数采用径向基函数 Output： 输出打印信息 """ #导入数据集 dataArr, labelArr = loadImages('trainingDigits') #调用Platt SMO算法 b, alphas = smoPK(dataArr, labelArr, 200, 0.0001, 10000, kTup) #初始化数据矩阵和标签向量 datMat = mat(dataArr); labelMat = mat(labelArr).transpose() #记录支持向量序号 svInd = nonzero(alphas.A &gt; 0)[0] #读取支持向量 sVs = datMat[svInd] #读取支持向量对应标签 labelSV = labelMat[svInd] #输出打印信息 print("there are %d Support Vectors" % shape(sVs)[0]) #获取数据集行列值 m, n = shape(datMat) #初始化误差计数 errorCount = 0 #遍历每一行，利用核函数对训练集进行分类 for i in range(m): #利用核函数转换数据 kernelEval = kernelTrans(sVs,datMat[i,:],kTup) #仅用支持向量预测分类 predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b #预测分类结果与标签不符则错误计数加一 if sign(predict)!=sign(labelArr[i]): errorCount += 1 #打印输出分类错误率 print "the training error rate is: %f" % (float(errorCount)/m) #导入测试数据集 dataArr,labelArr = loadImages('testDigits') #初始化误差计数 errorCount = 0 #初始化数据矩阵和标签向量 datMat=mat(dataArr); labelMat = mat(labelArr).transpose() #获取数据集行列值 m,n = shape(datMat) #遍历每一行，利用核函数对测试集进行分类 for i in range(m): #利用核函数转换数据 kernelEval = kernelTrans(sVs,datMat[i,:],kTup) #仅用支持向量预测分类 predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b #预测分类结果与标签不符则错误计数加一 if sign(predict)!=sign(labelArr[i]): errorCount += 1 #打印输出分类错误率 print "the test error rate is: %f" % (float(errorCount)/m) &emsp;&emsp;上面的大部分代码我们都已经很熟悉了，这里就不再赘述，直接进行测试。 12345678910111213&gt;&gt;&gt; reload(svmMLiA)&gt;&gt;&gt; svmMLiA.testDigits(('rbf', 20))L==HfullSet, iter: 6 i: 398, pairs changed 0j not moving enoughfullSet, iter: 6 i: 399, pairs changed 0fullSet, iter: 6 i: 400, pairs changed 0j not moving enoughfullSet, iter: 6 i: 401, pairs changed 0iteration number: 7there are 58 Support Vectorsthe training error rate is: 0.000000the test error rate is: 0.021505 &emsp;&emsp;尝试不同的σ，并尝试了线性核函数，总结得到如图结果： Kernel,settings Training error (%) Test error (%) # Support vectors RBF,0.1 0 52 402 RBF,5 0 3.2 402 RBF,10 0 0.5 99 RBF,50 0.2 2.2 41 RBF,100 1.5 4.3 26 Linear 2.7 2.2 28 &emsp;&emsp;结果表明，当径向基函数的参数σ取10左右时，就可以得到最小的测试错误率。同时，最小的训练错误率，并不对应于最小的支持向量数目。另外，线性核函数的效果并不是特别糟糕，可以以牺牲线性核函数的错误率来换取分类速度的提高。 总结&emsp;&emsp;支持向量机是一种分类器。之所以称为“机”是因为它会产生一个二值决策结果，即它是一种决策“机”。支持向量机的泛化错误率较低，具有良好的学习能力，且学到的结果具有很好的推广性。这些优点使得支持向量机十分流行，有些人认为他是监督学习中最好的定式算法。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之朴素贝叶斯（4）从个人广告中获取区域倾向]]></title>
    <url>%2F2017%2F11%2F04%2Fml-13%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch04 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;书中的最后一个例子，是分别从美国的两个城市中选取一些人，通过分析这些人发布的征婚广告信息，来比较这两个城市的人们在广告用词上是否不同。如果结论确实是不同，那么他们各自的常用词是哪些？从人们的用词当中，我们能否对不同城市的人所关心的内容有所了解？ 示例：使用朴素贝叶斯来发现地域相关的用词。 收集数据：从RSS源收集内容，这里需要对RSS创建一个接口。 准备数据：将文本文件解析成词条向量。 分析数据：检查词条确保解析的正确性。 训练算法：使用我们之间建立的trainNB0()函数。 测试算法：观察错误率，确保分类器可用，可以修改切分程序，以降低错误率，提高分类结果。 使用算法：构建一个完整的程序，封装所有内容，给定两个RSS源，该程序会显示最常用的公共词。 &emsp;&emsp;下面我们将使用来自不同城市的广告训练一个分类器，然后观察分类器的效果。注意，我们并不是要使用该分类器进行分类，而是通过观察单词和条件概率值来发现与特定城市相关的内容。 收集数据：导入RSS源&emsp;&emsp;第一件事当然就是要准备数据，我们可以Python下载文本。利用RSS，这些文本很容易得到。现在所需要的是一个RSS阅读器。Universal Feed Parser是Python中最常用的RSS程序库。你可以在http://code.google.com/p/feedparser/下浏览相关文档，然后和其他Python包一样来安装feedparser，即 pip3 install feedparse。 书中使用的是Craigslist上的个人广告，当然希望是在服务条款允许的条件下。 测试算法：RSS源分类器&emsp;&emsp;我们还是先来构建一个类似于spamTest()的函数来对测试过程自动化吧。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091def calcMostFreq(vocabList, fullText): """ Function： 计算出现频率 Args： vocabList：词汇表 fullText：全部词汇 Returns： sortedFreq[:30]：出现频率最高的30个词 """ import operator freqDict = &#123;&#125; for token in vocabList: freqDict[token] = fullText.count(token) sortedFreq = sorted(freqDict.items(), key=operator.itemgetter(1), reverse=True) return sortedFreq[:30]def localWords(feed1, feed0): """ Function： RSS源分类器 Args： feed1：RSS源 feed0：RSS源 Returns： vocabList：词汇表 p0V：类别概率向量 p1V：类别概率向量 """ import feedparser #初始化数据列表 docList = []; classList = []; fullText = [] minLen = min(len(feed1['entries']), len(feed0['entries'])) #导入文本文件 for i in range(minLen): #切分文本 wordList = textParse(feed1['entries'][i]['summary']) #切分后的文本以原始列表形式加入文档列表 docList.append(wordList) #切分后的文本直接合并到词汇列表 fullText.extend(wordList) #标签列表更新 classList.append(1) #切分文本 wordList = textParse(feed0['entries'][i]['summary']) #切分后的文本以原始列表形式加入文档列表 docList.append(wordList) #切分后的文本直接合并到词汇列表 fullText.extend(wordList) #标签列表更新 classList.append(0) #获得词汇表 vocabList = createVocabList(docList) #获得30个频率最高的词汇 top30Words = calcMostFreq(vocabList, fullText) #去掉出现次数最高的那些词 for pairW in top30Words: if pairW[0] in vocabList: vocabList.remove(pairW[0]) trainingSet = range(2*minLen); testSet = [] #随机构建测试集，随机选取二十个样本作为测试样本，并从训练样本中剔除 for i in range(20): #随机得到Index randIndex = int(random.uniform(0, len(trainingSet))) #将该样本加入测试集中 testSet.append(trainingSet[randIndex]) #同时将该样本从训练集中剔除 del(trainingSet[randIndex]) #初始化训练集数据列表和标签列表 trainMat = []; trainClasses = [] #遍历训练集 for docIndex in trainingSet: #词表转换到向量，并加入到训练数据列表中 trainMat.append(setOfWords2Vec(vocabList, docList[docIndex])) #相应的标签也加入训练标签列表中 trainClasses.append(classList[docIndex]) #朴素贝叶斯分类器训练函数 p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses)) #初始化错误计数 errorCount = 0 #遍历测试集进行测试 for docIndex in testSet: #词表转换到向量 wordVector = setOfWords2Vec(vocabList, docList[docIndex]) #判断分类结果与原标签是否一致 if classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]: #如果不一致则错误计数加1 errorCount += 1 #并且输出出错的文档 print("classification error",docList[docIndex]) #打印输出信息 print('the erroe rate is: ', float(errorCount)/len(testSet)) #返回词汇表和两个类别概率向量 return vocabList, p0V, p1V &emsp;&emsp;上述代码类似于spamTest()，只不过添加了新的功能，引入calcMostFreq()来返回出现频率最高的30个单词，再狠心将他们剔除。当我们注释掉移除高频词的三行代码，会发现错误率提高了百分之二十左右。有趣的是，vocalList的大小约为3000个词，前30个高频词却占了30%，也就是说词汇表中的这一小部分单词，占据了所有文本用词的一大部分。产生这种现象的原因是语言中大部分都是冗余和结构辅助性内容，另一个常用的方法不仅移除高频词，同时从某个预定词表中移除结构上的辅助词。该词表为停用词表（stop word list），网上可以找到很多，例如http://www.ranks.nl/resources/stopwords.html。 输出结果： 12345678910&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; ny = feedparser.parse('http://newyork.craiglist.org/stp/index.rss')&gt;&gt;&gt; sf = feedparser.parse('http://sfbay.craiglist.org/stp/index.rss')&gt;&gt;&gt; vocabList, pSF, pNY = bayes.localWords(ny, sf)the erroe rate is: 0.5&gt;&gt;&gt; vocabList, pSF, pNY = bayes.localWords(ny, sf)the erroe rate is: 0.35&gt;&gt;&gt; vocabList, pSF, pNY = bayes.localWords(ny, sf)the erroe rate is: 0.5 &emsp;&emsp;需要注意的是RSS源要在函数外导入，因为网站上的RSS源会随着时间而改变。&emsp;&emsp;为了得到错误率的精确估计，应该多次进行上述实验，然后取平均值。这里的错误率很高，但是我们关注的是单词概率而不是实际分类，因此这个问题倒不严重，可以改变要移除的单词数目，然后观察错误率的变化。 分析数据：显示地域性相关单词&emsp;&emsp;可以先对pSF和pNY进行排序，然后按照顺序将词打印出来。 代码实现： 123456789101112131415161718192021222324252627282930def getTopWords(ny, sf): """ Function： 最具表征性的词汇显示函数 Args： ny：RSS源 sf：RSS源 Returns： 打印信息 """ import operator #RSS源分类器返回概率 vocabList, p0V, p1V=localWords(ny, sf) #初始化列表 topNY = []; topSF = [] #设定阈值，返回大于阈值的所有词，如果输出信息很多，就提高一下阈值 for i in range(len(p0V)): if p0V[i] &gt; -4.5 : topSF.append((vocabList[i], p0V[i])) if p1V[i] &gt; -4.5 : topNY.append((vocabList[i], p1V[i])) #排序 sortedSF = sorted(topSF, key=lambda pair: pair[1], reverse=True) print("SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**") #打印 for item in sortedSF: print(item[0]) #排序 sortedNY = sorted(topNY, key=lambda pair: pair[1], reverse=True) print("NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**") #打印 for item in sortedNY: print(item[0]) &emsp;&emsp;可以通过调节阈值的大小来改变输出量的多少，记住这里的阈值时取自然对数之后的概率哦，所以是负数。 输出结果： 1234567891011121314151617181920212223242526&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; bayes.getTopWords(ny,sf)the erroe rate is: 0.45SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**verylethelloemailsurewasenjoynewwelldateswalkNY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**downthemgirltimesgreatwhatfeetmostbeen &emsp;&emsp;值得注意的是程序输出了大量的停用词，有兴趣的同学可以试着把停用词去掉，然后看看分类错误率会不会降低。 总结：&emsp;&emsp;对于分类而言，使用概率有时要比使用硬规则更为有效，贝叶斯概率及贝叶斯准则提供了一种利用已知值来估计未知概率的有效方法。尽管条件独立性假设并不正确，但是朴素贝叶斯仍然是一种有效的分类器。 &emsp;&emsp;朴素贝叶斯： 优点：在数据较少的情况下仍然有效，可以处理多类别问题。 缺点：对于输入数据的准备方式较为敏感。 适用数据类型：标称型数据。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之朴素贝叶斯（3）过滤垃圾邮件]]></title>
    <url>%2F2017%2F11%2F04%2Fml-12%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch04 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;使用朴素贝叶斯解决一些现实生活的问题时，需要先从文本内容得到字符串列表，然后生成词向量。下面这个例子中，我们将了解朴素贝叶斯的一个最著名的应用：电子邮件垃圾过滤。 示例：使用朴素贝叶斯对电子邮件进行分类 收集数据：提供文本文件。 准备数据：将文本文件解析成词条向量。 分析数据：检查词条确保解析的正确性。 训练算法：使用我们之前建立的trainNB0()函数。 测试算法：使用calssifyNB()，并且构建一个新的测试函数来计算文档集的错误率。 使用算法：构建一个完整的程序对一组文档进行分类，将错分的文档输出。 准备数据：切分文本&emsp;&emsp;先前的次向量都是我们预先给定的，这次将介绍如何从文本文档中构建自己的词列表。对于一个文本字符串，可以使用Python的string.split()方法将其切分。 string.split()的使用详解，请打开传送门：http://blog.csdn.net/u011475210/article/details/77925994 代码实现： 1234567891011121314def textParse(bigString): """ Function： 切分文本 Args： bigString：输入字符串 Returns： [*]：切分后的字符串列表 """ import re #利用正则表达式，来切分句子，其中分隔符是除单词、数字外的任意字符串 listOfTokens = re.split(r'\W*', bigString) #返回切分后的字符串列表 return [tok.lower() for tok in listOfTokens if len(tok) &gt; 2] &emsp;&emsp;Python中有一些内嵌的方法，可以将字符串全部转换成小写（.lower()）或者大写（.upper()），借助这些方法可以达到目的。程序的最后一行就是用的这种方法。同时，如果某些文件包含一些URL（http://docs.google.com/support/bin/answer.py?hl=en&amp;answer=66343），例如ham下的6.txt，那么切分文本时就会出现很多单词，如py、hl，很显然这些都是没用的，所以我们在程序最后一行只输出长度大于2的词条，好机智哦！ 测试算法：使用朴素贝叶斯进行交叉验证&emsp;&emsp;下面我们将文本解析器集成到一个完整的分类器中。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def spamTest(): """ Function： 贝叶斯垃圾邮件分类器 Args： 无 Returns： float(errorCount)/len(testSet)：错误率 vocabList：词汇表 fullText：文档中全部单词 """ #初始化数据列表 docList = []; classList = []; fullText = [] #导入文本文件 for i in range(1, 26): #切分文本 wordList = textParse(open('email/spam/%d.txt' % i).read()) #切分后的文本以原始列表形式加入文档列表 docList.append(wordList) #切分后的文本直接合并到词汇列表 fullText.extend(wordList) #标签列表更新 classList.append(1) #切分文本 #print('i = :', i) wordList = textParse(open('email/ham/%d.txt' % i).read()) #切分后的文本以原始列表形式加入文档列表 docList.append(wordList) #切分后的文本直接合并到词汇列表 fullText.extend(wordList) #标签列表更新 classList.append(0) #创建一个包含所有文档中出现的不重复词的列表 vocabList = createVocabList(docList) #初始化训练集和测试集列表 trainingSet = list(range(50)); testSet = [] #随机构建测试集，随机选取十个样本作为测试样本，并从训练样本中剔除 for i in range(10): #随机得到Index randIndex = int(random.uniform(0, len(trainingSet))) #将该样本加入测试集中 testSet.append(trainingSet[randIndex]) #同时将该样本从训练集中剔除 del(trainingSet[randIndex]) #初始化训练集数据列表和标签列表 trainMat = []; trainClasses = [] #遍历训练集 for docIndex in trainingSet: #词表转换到向量，并加入到训练数据列表中 trainMat.append(setOfWords2Vec(vocabList, docList[docIndex])) #相应的标签也加入训练标签列表中 trainClasses.append(classList[docIndex]) #朴素贝叶斯分类器训练函数 p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses)) #初始化错误计数 errorCount = 0 #遍历测试集进行测试 for docIndex in testSet: #词表转换到向量 wordVector = setOfWords2Vec(vocabList, docList[docIndex]) #判断分类结果与原标签是否一致 if classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]: #如果不一致则错误计数加1 errorCount += 1 #并且输出出错的文档 print("classification error",docList[docIndex]) #打印输出信息 print('the erroe rate is: ', float(errorCount)/len(testSet)) #返回词汇表和全部单词列表 #return vocabList, fullText 输出结果： 12345678&gt;&gt;&gt; bayes.spamTest()the erroe rate is: 0.0&gt;&gt;&gt; bayes.spamTest()the erroe rate is: 0.0&gt;&gt;&gt; bayes.spamTest()classification error ['home', 'based', 'business', 'opportunity', 'knocking', 'your', 'door', 'don抰', 'rude', 'and', 'let', 'this', 'chance', 'you', 'can', 'earn', 'great', 'income', 'and', 'find', 'your', 'financial', 'life', 'transformed', 'learn', 'more', 'here', 'your', 'success', 'work', 'from', 'home', 'finder', 'experts']classification error ['scifinance', 'now', 'automatically', 'generates', 'gpu', 'enabled', 'pricing', 'risk', 'model', 'source', 'code', 'that', 'runs', '300x', 'faster', 'than', 'serial', 'code', 'using', 'new', 'nvidia', 'fermi', 'class', 'tesla', 'series', 'gpu', 'scifinance', 'derivatives', 'pricing', 'and', 'risk', 'model', 'development', 'tool', 'that', 'automatically', 'generates', 'and', 'gpu', 'enabled', 'source', 'code', 'from', 'concise', 'high', 'level', 'model', 'specifications', 'parallel', 'computing', 'cuda', 'programming', 'expertise', 'required', 'scifinance', 'automatic', 'gpu', 'enabled', 'monte', 'carlo', 'pricing', 'model', 'source', 'code', 'generation', 'capabilities', 'have', 'been', 'significantly', 'extended', 'the', 'latest', 'release', 'this', 'includes']the erroe rate is: 0.2 &emsp;&emsp;函数spamTest()会输出在10封随机选择的电子邮件上的分类错误率。因为是随机的，所以每次输出结果可能有些差别。所以如果想要更好的估计错误率，就需要多次重复求平均值。 报错信息汇总运行报错：12345678&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; bayes.spamTest()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "E:\机器学习实战\mycode\Ch04\bayes.py", line 221, in spamTest wordList = textParse(open('email/ham/%d.txt' % i).read())UnicodeDecodeError: 'gbk' codec can't decode byte 0xae in position 199: illegal multibyte sequence &emsp;&emsp;一看就是编码问题，所以在程序中加入了打印信息，想看看是哪个文档读取出了问题，最后发现数据集ham下第23个文本中有不能识别的字符（®），修改之后程序运转正常。如果从我的github上下载的数据集，那就大可放心，不会出现这种问题的。 报错文档：12345SciFinance now automatically generates GPU-enabled pricing &amp; risk model source code that runs up to 50-300x faster than serial code using a new NVIDIA Fermi-class Tesla 20-Series GPU.SciFinance® is a derivatives pricing and risk model development tool that automatically generates C/C++ and GPU-enabled source code from concise, high-level model specifications. No parallel computing or CUDA programming expertise is required.SciFinance's automatic, GPU-enabled Monte Carlo pricing model source code generation capabilities have been significantly extended in the latest release. This includes: 运行报错： 12345678&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; bayes.spamTest()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "E:\机器学习实战\mycode\Ch04\bayes.py", line 239, in spamTest del(trainingSet[randIndex])TypeError: 'range' object doesn't support item deletion &emsp;&emsp;range()函数报错，这里主要涉及到python版本问题，详情请打开传送门：http://blog.csdn.net/u011475210/article/details/77925697 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之朴素贝叶斯（1）算法概述]]></title>
    <url>%2F2017%2F11%2F04%2Fml-10%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch04 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;本周WordZzzz学习了朴素贝叶斯（naive Bayes）。朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法，对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯发实现简单，学习与预测的效率都很高，是一种常用的方法。 基于贝叶斯决策理论的分类方法&emsp;&emsp;朴素贝叶斯： 优点：在数据较少的情况下仍然有效，可以处理多类别问题。 缺点：对于输入数据的准备方式较为敏感。 适用数据类型：标称型数据。 &emsp;&emsp;朴素贝叶斯是贝叶斯决策理论的一部分，所以在此之前我们有必要快速了解一下贝叶斯决策理论。 &emsp;&emsp;假设现在我们有一个数据集，它由两类数据组成，数据分布如下图所示。 &emsp;&emsp;假设WordZzzz找到了描述图中两类数据的统计参数。现在用P1(x,y)表示数据点(x,y)属于类别1（图中用原点表示的类别）的概率，用P2(x,y)表示数据点(x,y)属于类别2（图中用三角形表示的类别）的概率，那么对于一个新数据点(x,y)，可以用下面的规则来判断它的类别： 如果P1(x,y) &gt; P2(x,y)，那么类别为1. 如果P1(x,y) &lt; P2(x,y)，那么类别为2. &emsp;&emsp;也即是说，我们会选择该概率对应的类别。这就是贝叶斯决策理论的核心思想，即选择具有最高概率的决策。 &emsp;&emsp;回到上图，如果图中的整个数据使用6个浮点数来表示，并且计算类别概率的Python代码只有两行，那么你会更加倾向于使用下面哪种方法来对该数据点进行分类？ (1)使用第一章的kNN，进行1000次距离计算； (2)使用第二章的决策树，分别沿x轴、y轴划分数据； (3)计算数据点属于每个类别的概率，并进行比较。 &emsp;&emsp;使用决策树不会非常成功；而和简单的概率计算相比，kNN的计算量太大。因此，对于上述问题，最佳选择是使用刚才提到的概率比较方法。 &emsp;&emsp;这里使用的概率解释属于贝叶斯概率理论的范畴，该理论非常流行且效果良好，贝叶斯概率以18世纪的以为神学家Thomas Bayes的名字命名。贝叶斯概率引入先验知识和逻辑推理来处理不确定命题。另一种概率解释称为频数概率，他只从数据本身获得结论，并不考虑逻辑推理及先验知识。 条件概率&emsp;&emsp;接下来讲讲概率和条件概率。还好，就一两个公式。 &emsp;&emsp;假设现在有一个装了7块石头的罐子，其中3块是灰色的，4块是黑色的，如下图所示。 &emsp;&emsp;如果从罐子里随机抽取一块石头，那么是灰色石头的可能性是多少？很显然，灰色石头概率3/7，黑色石头概率4/7。我们使用P(gray)来表示取到灰色石头的概率，其概率值可以通过灰色石头数目除以总数目来得到。 &emsp;&emsp;如果这7块石头放在两个桶里，如下图所示，那么上述概率如何计算？ &emsp;&emsp;要计算$P(gray)$或者$P(black)$，事先得到石头所在桶的信息会不会改变结果？假定计算的是从B桶中取到灰色石头的概率，这个概率记作$P(gray | bucketB)$，我们称之为“在已知石头出自B桶的条件下，取出灰色石头的概率”。不难的到$P(gray | bucketA)$的值为2/4，$P(gray | bucketB)$的值为1/3。 &emsp;&emsp;条件概率的计算公式如下所示： $$P(gray | bucketB) = P(gray and bucketB)/P(bucketB)$$ &emsp;&emsp;首先，用B桶中灰色石头的个数除以两个桶中的总石头数，得到$P(gray and bucketB)=1/7$。其次，由于B桶中有三块石头，而总石头数为7，于是$P(bucketB)=3/7$。于是有$P(gray|bucketB) = P(gray and bucketB)/P(bucketB) = (1/7)/(3/7) = 1/3$。这个公式虽然对于简单例子来说有点复杂，因为像WordZzzz一样的大部分明眼人一眼就能看出结果而没必要使用公式，但是当存在更多特征时，这个公式是非常有效的。用代数方法计算条件概率时，该公式也很有用。 &emsp;&emsp;另一种有效计算条件概率的方法被称为贝叶斯准则。贝叶斯准则告诉我们如何交换条件概率中的条件和结果，即如果已知P(x|c)，要求P(x|c)，那么可以使用下面的计算方法： $$ P(c|x) = \frac {p(x|c)p(c)} {p(x)} $$ &emsp;&emsp;知道条件概率怎么算之后，接下来的问题就是如何将其应用到分类器中。接下来，我们将讨论如何结合贝叶斯决策理论使用条件概率。 使用条件概率来分类&emsp;&emsp;贝叶斯决策理论要求计算两个概率P1(x,y)和P2(x,y)： 如果$P1(x,y) &gt; P2(x,y)$，那么属于类别1； 如果$P1(x,y) &lt; P2(x,y)$，那么属于类别2。 &emsp;&emsp;但这两个准则并不是贝叶斯决策理论的所有内容，使用P1()和P2()只是为了尽可能简化描述，而真正需要计算和比较的是$P(c_1|x,y)$和$P(c_2|x,y)$。这些符号所代表的具体意义是：给定某个由x、y表示的数据点，那么该数据点来自类别$c_1$的概率是多少？数据点来自类别$c_2$的概率又是多少？注意这些概率与刚才给出的概率$P(x,y|c_1)$并不一样，不过可以使用贝叶斯准则来交换概率中条件与结果。具体地，应用贝叶斯准则得到： $$ P(c_i|x,y) = \frac {p(x,y|c_i)p(c_i)} {p(x,y)} $$ &emsp;&emsp;使用这些定义，可以定义贝叶斯分类准则为： 如果$P1(c_i|x,y) &gt; P2(c_i|x,y)$，那么属于类别1； 如果$P1(c_i|x,y) &lt; P2(c_i|x,y)$，那么属于类别2。 &emsp;&emsp;使用贝叶斯准则，可以通过已知的三个概率值来计算未知的概率值。下一篇就会给出利用贝叶斯准则来计算概率并对数据进行分类的代码。 贝叶斯定理&emsp;&emsp;大家要是对贝叶斯定理不是很理解的话，可以看看这部分内容（摘自中文维基百科：https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86）。 &emsp;&emsp;贝叶斯定理是关于随机事件A和B的条件概率的一则定理。$${\displaystyle P(A|B)={\frac {P(B|A)\,P(A)}{P(B)}}}$$其中P(A|B)是在B发生的情况下A发生的可能性。&emsp;&emsp;在贝叶斯定理中，每个名词都有约定俗成的名称： [ ] P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。 P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。 P(A)是A的先验概率（或边缘概率）。之所以称为”先验”是因为它不考虑任何B方面的因素。 P(B)是B的先验概率或边缘概率。 &emsp;&emsp;按这些术语，贝叶斯定理可表述为： 后验概率 = (相似度*先验概率)/标准化常量 &emsp;&emsp;也就是说，后验概率与先验概率和相似度的乘积成正比。&emsp;&emsp;另外，比例P(B|A)/P(B)也有时被称作标准相似度（standardised likelihood），贝叶斯定理可表述为： 后验概率 = 标准相似度*先验概率 胰腺癌检测： &emsp;&emsp;基于贝叶斯定理：即使100%的胰腺癌症患者都有某症状，而某人有同样的症状，绝对不代表该人有100%的概率得胰腺癌，还需要考虑先验概率，假设胰腺癌的发病率是十万分之一，而全球有同样症状的人有万分之一，则此人得胰腺癌的概率只有十分之一，90%的可能是是假阳性。 恐怖分子检测： &emsp;&emsp;基于贝叶斯定理：假设100%的恐怖分子都相信A宗教，而某人相信A宗教，并不代表此人100%是恐怖分子，还需要考虑先验概率，假设全球有6万恐怖分子，在人类中的概率是十万分之一（假设人类有60亿人），假设全球有1/3的人口相信A宗教（20亿人信A宗教），则此人是恐怖分子的概率只有十万分之三。 使用朴素贝叶斯进行文档分类&emsp;&emsp;机器学习的一个重要应用就是文档的自动分类。在文档分类中，整个文档是实例，而电子邮件中的某些元素则构成特征。虽然电子邮件是一种会不断增加的文本，但我们同样可以对新闻报道、用户留言、政府公文等其他任意类型的文本进行分类。朴素贝叶斯是贝叶斯分类器的一个扩展，是用于文档分类的常用算法。 朴素贝叶斯的一般流程： 收集数据：可以使用任何方法，本章使用RSS源。 准备数据：准备数值型或者布尔型数据。 分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。 训练算法：计算不同的独立特征的条件概率。 测试算法：计算错误率。 使用算法：一个常见的朴素贝叶斯应用是文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。 &emsp;&emsp;由统计学知，如果每个特征需要N个样本，那么对于10个特征将需要$N^{10}$个样本，对于包含1000个特征的词汇表将需要$N^{1000}$个样本。吓我一跳，所需要的样本数会随着特征数目增大而迅速增长。 &emsp;&emsp;如果特征之间相互独立，那么样本数就可以减少到1000*N，所谓独立指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系，但是我们知道这种假设并不正确。这个假设正式朴素贝叶斯分类器中朴素（naive，天真！）一词的含义。朴素贝叶斯分类器中的另一个假设是，每个特征同等重要。其实这个假设也有问题。如果要判断留言是否得当，那么可能不需要看完所有的1000个单词，而只需要看10-20个就够了。尽管上述假设存在一些瑕疵，但朴素贝叶斯的实际效果却很好。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之朴素贝叶斯（2）使用Python进行文本分类]]></title>
    <url>%2F2017%2F11%2F04%2Fml-11%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch04 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;要从文本中获取特征，需要先拆分文本。这里的特征是来自文本的词条（token），一个词条是字符的任意组合。可以把词条想象为单词，也可以使用非单词词条，如URL、IP地址或者任意其他字符串。然后将一个文本片段表示为一个词向量，其中值为1表示词条出现，0表示词条未出现。 &emsp;&emsp;以在线社区的留言板为例，为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的言语，那么就将该留言表示为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类别：侮辱类和非侮辱类，使用1和0分别表示。 &emsp;&emsp;本文主要利用Python实现文本分类。 准备数据：从文本中构建词向量&emsp;&emsp;我们将把文本看成单词向量或者词条向量，也就是说将句子转换为向量。打开文本编辑器，创建一个叫bayes.py的新文件，用如下代码实现构建词向量。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: UTF-8 -*-"""Created on Sep 08, 2017Naive Bayes@author: wordzzzz"""from numpy import *def loadDataSet(): """ Function： 创建实验样本 Args： 无 Returns： postingList：词条切分后的文档集合 classVec：类别标签的集合 """ #词条切分后的文档集合 postingList=[['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] #类别标签的集合 classVec = [0,1,0,1,0,1] #1 is abusive, 0 not #词条切分后的文档集合和类别标签结合 return postingList,classVecdef createVocabList(dataSet): """ Function： 创建一个包含所有文档中出现的不重复词的列表 Args： dataSet：数据集 Returns： list(vocabSet)：返回一个包含所有文档中出现的不重复词的列表 """ #创建一个空集 vocabSet = set([]) #将新词集合添加到创建的集合中 for document in dataSet: #操作符 | 用于求两个集合的并集 vocabSet = vocabSet | set(document) #返回一个包含所有文档中出现的不重复词的列表 return list(vocabSet)def setOfWords2Vec(vocabList, inputSet): """ Function： 词表到向量的转换 Args： vocabList：词汇表 inputSet：某个文档 Returns： returnVec：文档向量 """ #创建一个所含元素都为0的向量 returnVec = [0]*len(vocabList) #遍历文档中词汇 for word in inputSet: #如果文档中的单词在词汇表中，则相应向量位置置1 if word in vocabList: returnVec[vocabList.index(word)] = 1 #否则输出打印信息 else: print("the word: %s is not in my Vocablary!" % word) #向量的每一个元素为1或0，表示词汇表中的单词在文档中是否出现 return returnVec &emsp;&emsp;首先命令行生成词汇表，程序中巧妙地运用了Python的set数据类型，通过并集运算，可以生成一个包含所有文档中出现的不重复词的列表。 输出结果： 12345&gt;&gt;&gt; import bayes&gt;&gt;&gt; listOPosts, listClasses = bayes.loadDataSet()&gt;&gt;&gt; myVocabList = bayes.createVocabList(listOPosts)&gt;&gt;&gt; myVocabList['mr', 'cute', 'please', 'to', 'steak', 'worthless', 'not', 'how', 'so', 'I', 'stop', 'ate', 'buying', 'help', 'has', 'maybe', 'dog', 'him', 'flea', 'posting', 'stupid', 'is', 'food', 'garbage', 'take', 'park', 'my', 'quit', 'licks', 'dalmation', 'love', 'problems'] &emsp;&emsp;检查上述词表，就会发现这里不会出现重复的单词。目前该词表并没有进行排序，需要的话稍后可以对其排序。然后看一下setOfWords2Vec的运行效果： 1234&gt;&gt;&gt; bayes.setOfWords2Vec(myVocabList, listOPosts[0])[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]&gt;&gt;&gt; bayes.setOfWords2Vec(myVocabList, listOPosts[3])[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0] &emsp;&emsp;该函数使用词汇表或者想要检查的所有单词作为输入，然后为其中每一个单词构建一个特征。我们来看对listOPosts[0]（[‘my’, ‘dog’, ‘has’, ‘flea’, ‘problems’, ‘help’, ‘please’]）进行词条转换输出的结果，可以看到第三个元素值为1，即词汇表中对应的please这个单词在listOPosts[0]中，事实也确实如此。 训练算法：从词向量计算概率&emsp;&emsp;前面介绍了如何将一组单词转换为一组数字，现在我们就开始使用这些数字计算概率。我们把上篇文章的贝叶斯准则再掏出来，讲之前的x、y替换为w。w表示这是一个向量，即它由多个数值组成。在这个例子中，数值个数与词汇表中的词个数相同。 $$ P(c_i | w) = \frac {P(w | c_i)P(c_i)} {P(w)} $$ &emsp;&emsp;使用上述公式，对每个类计算该值，然后比较这两个概率值的大小。首先通过类别i（侮辱性留言或者非侮辱性留言）中文档数除以总的文档数来计算概率$ P(c_i) $。接下来计算$ P(w | c_i) $，这里就用到了贝叶斯假设。如果将w展开为一个个独立特征，那么就可以将上述概率写作$P(w_0, w_1, w_2, ···w_N|c_i)$。这里假设所有词都互相独立，就是我们之前提到的naive的条件独立性假设，这意味着我们可以使用$P(w_0|c_i)P(w_1|c_i)P(w_2|c_i)…P(w_N|c_i)$来计算上述概率，就算起来so easy! &emsp;&emsp;写个伪代码大概就是这么个意思： 123456789计算每个类别中的文档数目对每篇训练文档： 对每个类别： 如果词条出现在文档中，则增加该词条的计数 增加所有词条的计数值对每个类别： 对每个词条： 将该词条的数目除以总词条数目得到条件概率返回每个类别的条件概率 &emsp;&emsp;下面的代码使用了NumPy的一些函数，故应确保将from numpy import *语句添加到bayes.py文件的最前面。 代码实现： 123456789101112131415161718192021222324252627282930313233343536def trainNB0(trainMatrix, trainCategory): """ Function： 朴素贝叶斯分类器训练函数 Args： trainMatrix：文档矩阵 trainCategory：类别标签向量 Returns： p0Vect：非侮辱性词汇概率向量 p1Vect：侮辱性词汇概率向量 pAbusive：侮辱性文档概率 """ #获得训练集中文档个数 numTrainDocs = len(trainMatrix) #获得训练集中单词个数 numWords = len(trainMatrix[0]) #计算文档属于侮辱性文档的概率 pAbusive = sum(trainCategory)/float(numTrainDocs) #初始化概率的分子变量 p0Num = zeros(numWords); p1Num = zeros(numWords) #初始化概率的分母变量 p0Denom = 0.0; p1Denom = 0.0 #遍历训练集trainMatrix中所有文档 for i in range(numTrainDocs): #如果侮辱性词汇出现，则侮辱词汇计数加一，且文档的总词数加一 if trainCategory[i] ==1: p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) #如果非侮辱性词汇出现，则非侮辱词汇计数加一，且文档的总词数加一 else: p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) #对每个元素做除法求概率 p1Vect = p1Num/p1Denom p0Vect = p0Num/p0Denom #返回两个类别概率向量和一个概率 return p0Vect, p1Vect, pAbusive 输出结果： 123456789101112131415161718192021222324252627&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; listOPosts, listClasses = bayes.loadDataSet() #从预先加载值中调入数据&gt;&gt;&gt; myVocabList = bayes.createVocabList(listOPosts) #构建一个包含所有值得词汇表&gt;&gt;&gt; trainMat = [] #利用for循环来填充trainMat列表&gt;&gt;&gt; for postinDoc in listOPosts:... trainMat.append(bayes.setOfWords2Vec(myVocabList, postinDoc))...&gt;&gt;&gt; p0V, p1V, pAb = bayes.trainNB0(trainMat, listClasses)&gt;&gt;&gt; pAb #任意侮辱性文档的概率0.5&gt;&gt;&gt; p0Varray([ 0.04166667, 0.04166667, 0.04166667, 0.04166667, 0.04166667, 0. , 0. , 0.04166667, 0.04166667, 0.04166667, 0.04166667, 0.04166667, 0. , 0.04166667, 0.04166667, 0. , 0.04166667, 0.08333333, 0.04166667, 0. , 0. , 0.04166667, 0. , 0. , 0. , 0. , 0.125 , 0. , 0.04166667, 0.04166667, 0.04166667, 0.04166667])&gt;&gt;&gt; p1Varray([ 0. , 0. , 0. , 0.05263158, 0. , 0.10526316, 0.05263158, 0. , 0. , 0. , 0.05263158, 0. , 0.05263158, 0. , 0. , 0.05263158, 0.10526316, 0.05263158, 0. , 0.05263158, 0.15789474, 0. , 0.05263158, 0.05263158, 0.05263158, 0.05263158, 0. , 0.05263158, 0. , 0. , 0. , 0. ]) &emsp;&emsp;首先，我们发现文档属于侮辱类的概率pAb为0.5，该值是正确定。词汇表中的第一个词是cute，其在类别0中出现一次，在类别1中从未出现，对应的条件概率分别为0.44166667和0.0。该计算是正确的。 测试算法：根据现实情况修改分类器&emsp;&emsp;利用贝叶斯分类器对文档进行分类时，要计算过个概率的乘积以获得文档属于某个类别的概率，如果其中一个概率值为0，那么最后的乘积也为0。为降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。所以需要修改一下trainNB()中的分母分子初始化代码。 1234#初始化概率的分子变量p0Num = ones(numWords); p1Num = ones(numWords)#初始化概率的分母变量p0Denom = 2.0; p1Denom = 2.0 &emsp;&emsp;另一个遇到的问题就是下溢出，太多的很小数相乘，导致程序向下溢出或者得不到正确的答案（比如四舍五入后乘积为0）。一种解决办法就是对乘积取自然对数。即!$ln(a*b) = ln(a) + ln(b)$，于是通过求对数可以避免下溢出或者浮点数舍入导致的错误。我们可以放心的是，采用自然对数处理不会有任何损失。下图给出了函数f(x)和ln(f(x))的曲线。 &emsp;&emsp;检查这两条曲线，就会发现他们在相同区域内同时增加或者减少，并且在相同点上取到极值。取值虽然不同，但是不影响最终结果。所以需要修改一下trainNB()中的求概率代码。 123#对每个元素做除法求概率p1Vect = log(p1Num/p1Denom)p0Vect = log(p0Num/p0Denom) &emsp;&emsp;下面构建朴素贝叶斯分类函数和测试函数： 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): """ Function： 朴素贝叶斯分类函数 Args： vec2Classify：文档矩阵 p0Vec：非侮辱性词汇概率向量 p1Vec：侮辱性词汇概率向量 pClass1：侮辱性文档概率 Returns： 1：侮辱性文档 0：非侮辱性文档 """ #向量元素相乘后求和再加到类别的对数概率上，等价于概率相乘 p1 = sum(vec2Classify * p1Vec) + log(pClass1) p0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1) #分类结果 if p1 &gt; p0: return 1 else: return 0def testingNB(): """ Function： 朴素贝叶斯分类器测试函数 Args： 无 Returns： testEntry：测试词汇列表 classifyNB(thisDoc, p0V, p1V, pAb)：分类结果 """ #从预先加载中调入数据 listOPosts, listClasses = loadDataSet() #构建一个包含所有词的列表 myVocabList = createVocabList(listOPosts) #初始化训练数据列表 trainMat = [] #填充训练数据列表 for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) #训练 p0V, p1V, pAb = trainNB0(trainMat, listClasses) #测试 testEntry = ['love', 'my', 'dalmation'] thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) print(testEntry,'classified as: ', classifyNB(thisDoc, p0V, p1V, pAb)) #测试 testEntry = ['stupid', 'garbage'] thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) print(testEntry,'classified as: ', classifyNB(thisDoc, p0V, p1V, pAb)) 输出结果： 12345&gt;&gt;&gt; reload(bayes)&lt;module 'bayes' from 'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'&gt;&gt;&gt;&gt; bayes.testingNB()['love', 'my', 'dalmation'] classified as: 0['stupid', 'garbage'] classified as: 1 &emsp;&emsp;大家可以对输入文本做一下修改，看看分类器会输出什么结果。这个例子非常简单，但是它展示了朴素贝叶斯分类器的工作原理。接下来我们可以对代码做一些修改，使分类器工作得更好。 准备数据：文档词袋模型&emsp;&emsp;我们将每个词的出现与否作为一个特征，可以被描述为词集模型（set-of-words model）。如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某些信息，这种方法被称为词袋模型（bag-of-words model）。词袋中的单词可以出现多次，而在词集中，每个单词只能出现一次。下面的程序给出了基于词袋模型的朴素贝叶斯代码，。它与函数setOfWords2Vec()几乎完全相同，唯一不同的是每当遇到一个单词时，它会增加词向量中的对应值，而不只是将对应的数值设为1。 代码实现： 123456789101112131415161718def bagOfWords2VecMN(vocabList, inputSet): """ Function： 词袋到向量的转换 Args： vocabList：词袋 inputSet：某个文档 Returns： returnVec：文档向量 """ #创建一个所含元素都为0的向量 returnVec = [0]*len(vocabList) #将新词集合添加到创建的集合中 for word in inputSet: #如果文档中的单词在词汇表中，则相应向量位置加1 if word in vocabList: returnVec[vocabList.index(word)] += 1 #返回一个包含所有文档中出现的词的列表 return returnVec 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之决策树算法（2）画个儿时的树]]></title>
    <url>%2F2017%2F11%2F03%2Fml-8%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch03 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;上一篇博文已经介绍了如何从数据集中创建树，然而字典的表示形式非常不易理解，而且直接绘制图形也比较困难。决策树的主要优点就是直观易于理解，如果不能将其直观的显示出来，优势便无从谈起，所以本片博文就介绍一下如何利用Matplotlib库来创建树形图。 Matplotlib注解：&emsp;&emsp;Matplotlib提供了一个非常有用的注解工具annotations，它可以在数据图像上添加文本注解。由于数据上面直接存在文本描述非常丑陋，因此工具内嵌支持带尖头的画线工具，使得我们可以在其他前挡的地方指向数据位置，并在此处添加描述信息，解释数据内容，如下图： &emsp;&emsp;打开文本编辑器，创建名为treePlotter.py的新文件，输入下面的程序代码。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'''Created on Aug 14, 2017@author: WordZzzz'''import matplotlib.pyplot as plt#定义文本框和箭头格式decisionNode = dict(boxstyle="sawtooth", fc="0.8")leafNode = dict(boxstyle="round4", fc="0.8")arrow_args = dict(arrowstyle="&lt;-")def plotNode(nodeTxt, centerPt, parentPt, nodeType): """ Function： 绘制带箭头的注解 Args： nodeTxt：文本注解 centerPt：箭头终点坐标 parentPt：箭头起始坐标 nodeType：文本框类型 Returns： 无 """ #在全局变量createPlot0.ax1中绘图 createPlot0.ax1.annotate(nodeTxt, xy=parentPt, xycoords='axes fraction', xytext=centerPt, textcoords='axes fraction', va="center", ha="center", bbox=nodeType, arrowprops=arrow_args )def createPlot0(): """ Function： 使用文本注解绘制树节点 Args： 无 Returns： 无 """ #创建一个新图形 fig = plt.figure(1, facecolor='white') #清空绘图区 fig.clf() #给全局变量createPlot0.ax1赋值 createPlot0.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses #绘制第一个文本注解 plotNode('a decision node', (0.5, 0.1), (0.1, 0.5), decisionNode) #绘制第二个文本注解 plotNode('a leaf node', (0.8, 0.1), (0.3, 0.8), leafNode) #显示最终绘制结果 plt.show() 输出结果： 12&gt;&gt;&gt; import treePlotter&gt;&gt;&gt; treePlotter.createPlot0() &emsp;&emsp;程序结果如图所示，我们也可以改变函数plotNode()，观察图中x、y的位置如何变化。 构造注解树：&emsp;&emsp;绘制一颗完整的树需要技巧，虽然我们有坐标，但是如何放置所有的树节点却是个问题。所以我们需要知道有多少个叶节点来确定x轴长度；haixuyao知道有多少层来确定y轴的高度。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def getNumLeafs(myTree): """ Function： 获取叶节点的数目 Args： myTree：树信息 Returns： numLeafs：叶节点的数目 """ #初始化叶节点数目 numLeafs = 0 #第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值 firstStr = myTree.keys()[0] #新的树，相当于脱了一层皮 secondDict = myTree[firstStr] for key in secondDict.keys(): #判断子节点是否为字典类型 if type(secondDict[key]).__name__=='dict': #是的话表明该节点也是一个判断节点，递归调用getNumLeafs()函数 numLeafs += getNumLeafs(secondDict[key]) else: numLeafs += 1 #返回叶节点数目 return numLeafsdef getTreeDepth(myTree): """ Function： 获取树的层数 Args： myTree：树信息 Returns： maxDepth：最大层数 """ #初始化最大层数 maxDepth = 0 #第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值 firstStr = myTree.keys()[0] #新的树，相当于脱了一层皮 secondDict = myTree[firstStr] for key in secondDict.keys(): #判断子节点是否为字典类型 if type(secondDict[key]).__name__=='dict': #是的话表明该节点也是一个判断节点，递归调用getTreeDepth()函数 thisDepth = 1 + getTreeDepth(secondDict[key]) else: thisDepth = 1 if thisDepth &gt; maxDepth: maxDepth = thisDepth #返回最大层数 return maxDepth &emsp;&emsp;retrieveTree()主要用于测试，返回预定义的树结构。 123456789101112def retrieveTree(i): """ Function： 创建树 Args： i：要输出的树在里列表中的位置 Returns： listOfTrees[i]：输出预先存储的树 """ listOfTrees =[&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125;, &#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: &#123;'head': &#123;0: 'no', 1: 'yes'&#125;&#125;, 1: 'no'&#125;&#125;&#125;&#125; ] return listOfTrees[i] 输出结果： 1234567891011&gt;&gt;&gt; reload(treePlotter)&lt;module 'treePlotter' from 'E:\\机器学习实战\\mycode\\Ch03\\treePlotter.py'&gt;&gt;&gt;&gt; treePlotter.retrieveTree(1)&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: &#123;'head': &#123;0: 'no', 1: 'yes'&#125;&#125;, 1: 'no'&#125;&#125;&#125;&#125;&gt;&gt;&gt; treePlotter.retrieveTree(0)&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125;&gt;&gt;&gt; myTree = treePlotter.retrieveTree(0)&gt;&gt;&gt; treePlotter.getNumLeafs(myTree)3&gt;&gt;&gt; treePlotter.getTreeDepth(myTree)2 报（python2.x与python3.x的差异）： 1TypeError: 'dict_keys' object does not support indexing 解决（强制类型转换）：Probably this was written with python2.x (when d.keys() returned a list). With python3.x, d.keys() returns a dict_keys object which behaves a lot more like a set than a list. As such, it can’t be indexed. The solution is to pass list(d.keys()) (or simply list(d)) to shuffle. &emsp;&emsp;我们需要重新编写createPlot()函数，在createPlot0()的基础上进行完善。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384def plotMidText(cntrPt, parentPt, txtString): """ Function： 在父子节点间填充文本信息 Args： cntrPt：树信息 parentPt：父节点坐标 txtString：文本注解 Returns： 无 """ xMid = (parentPt[0]-cntrPt[0])/2.0 + cntrPt[0] yMid = (parentPt[1]-cntrPt[1])/2.0 + cntrPt[1] createPlot.ax1.text(xMid, yMid, txtString, va="center", ha="center", rotation=30)def plotTree(myTree, parentPt, nodeTxt):#if the first key tells you what feat was split on """ Function： 创建数据集和标签 Args： myTree：树信息 parentPt：箭头起始坐标 nodeTxt：文本注解 Returns： 无 """ #计算树的宽 numLeafs = getNumLeafs(myTree) #this determines the x width of this tree #计算树的高 depth = getTreeDepth(myTree) #第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值 firstStr = list(myTree.keys())[0] #the text label for this node should be this #下一个节点的位置 cntrPt = (plotTree.xOff + (1.0 + float(numLeafs))/2.0/plotTree.totalW, plotTree.yOff) #计算父节点和子节点的中间位置，并在此处添加简单的文本信息 plotMidText(cntrPt, parentPt, nodeTxt) #绘制此节点带箭头的注解 plotNode(firstStr, cntrPt, parentPt, decisionNode) #新的树，相当于脱了一层皮 secondDict = myTree[firstStr] #按比例减少全局变量plotTree.yOff plotTree.yOff = plotTree.yOff - 1.0/plotTree.totalD # for key in secondDict.keys(): #判断子节点是否为字典类型 if type(secondDict[key]).__name__=='dict': #是的话表明该节点也是一个判断节点，递归调用plotTree()函数 plotTree(secondDict[key],cntrPt,str(key)) else: #不是的话更新x坐标值 plotTree.xOff = plotTree.xOff + 1.0/plotTree.totalW #绘制此节点带箭头的注解 plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode) #绘制此节点带箭头的注解 plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key)) #按比例增加全局变量plotTree.yOff plotTree.yOff = plotTree.yOff + 1.0/plotTree.totalD#if you do get a dictonary you know it's a tree, and the first element will be another dictdef createPlot(inTree): """ Function： 使用文本注解绘制树节点 Args： inTree： Returns： 无 """ #创建一个新图形 fig = plt.figure(1, facecolor='white') #清空绘图区 fig.clf() #创建一个字典 axprops = dict(xticks=[], yticks=[]) #给全局变量createPlot.ax1赋值 createPlot.ax1 = plt.subplot(111, frameon=False, **axprops) #no ticks #createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses #取得叶节点数目 plotTree.totalW = float(getNumLeafs(inTree)) #取得树最大层 plotTree.totalD = float(getTreeDepth(inTree)) #设置起点值 plotTree.xOff = -0.5/plotTree.totalW; plotTree.yOff = 1.0; #绘制数 plotTree(inTree, (0.5,1.0), '') #显示最终绘制结果 plt.show() 输出结果： 1234&gt;&gt;&gt; reload(treePlotter)&lt;module 'treePlotter' from 'E:\\机器学习实战\\mycode\\Ch03\\treePlotter.py'&gt;&gt;&gt;&gt; myTree = treePlotter.retrieveTree(0)&gt;&gt;&gt; treePlotter.createPlot(myTree) 输出效果如下图所示： &emsp;&emsp;接着按照命令更改字典，重新绘制树形图。 输出结果： 1234&gt;&gt;&gt; myTree['no surfacing'][3] = 'maybe'&gt;&gt;&gt; myTree&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;, 3: 'maybe'&#125;&#125;&gt;&gt;&gt; treePlotter.createPlot(myTree) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之决策树算法（3）预测隐形眼镜类型]]></title>
    <url>%2F2017%2F11%2F03%2Fml-9%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch03 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;本博文先介绍在实际应用中如何存储分类器，然后在实际数据上使用决策树分类算法，验证它是否可以正确预测出患者应该使用的隐形眼镜类型。 测试和存储算法测试算法：使用决策树执行分类&emsp;&emsp;在执行数据分类时，需要使用决策树以及用于构造决策树的标签向量。然后，程序比较测试数据与决策树上的数值，递归执行该过程知道进入叶子结点；最后将测试数据定义为叶子节点所属的类型。 代码实现： 1234567891011121314151617181920212223242526272829def classify(inputTree, featLabels, testVec): """ Function： 使用决策树的分类函数 Args： inputTree：树信息 featLabels：标签列表 testVec：测试数据 Returns： classLabel：分类标签 """ #第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值 firstStr = list(inputTree.keys())[0] #新的树，相当于脱了一层皮 secondDict = inputTree[firstStr] #将标签字符串转为索引 featIndex = featLabels.index(firstStr) #遍历整棵树 for key in secondDict.keys(): #比较testVec变量中的值与树节点的值 if testVec[featIndex] == key: #判断子节点是否为字典类型，进而得知是否到达叶子结点 if type(secondDict[key]).__name__=='dict': #没到达叶子结点，则递归调用classify() classLabel = classify(secondDict[key], featLabels, testVec) else: #到达叶子结点，则分类结果为当前节点的分类标签 classLabel = secondDict[key] #返回分类标签 return classLabel 输出结果： 123456789101112&gt;&gt;&gt; reload(trees)&lt;module 'trees' from 'E:\\机器学习实战\\mycode\\Ch03\\trees.py'&gt;&gt;&gt;&gt; myDat, labels = trees.createDataSet()&gt;&gt;&gt; labels['no surfacing', 'flippers']&gt;&gt;&gt; myTree = treePlotter.retrieveTree(0)&gt;&gt;&gt; myTree&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125;&gt;&gt;&gt; trees.classify(myTree, labels, [1,0])'no'&gt;&gt;&gt; trees.classify(myTree, labels, [1,1])'yes' 使用算法：决策树的存储&emsp;&emsp;构造决策树是很耗时的任务，及时处理很小的数据集。如果使用创建好的决策树解决分类问题，则可以很快完成。因此，为了节省计算时间，我们使用Python模块pickle序列化对象，以便在硬盘上保存和读取字典。 代码实现：： 12345678910111213141516171819202122232425262728293031323334def storeTree(inputTree, filename): """ Function： 存储决策树 Args： inputTree：树信息 filename：文件名称 Returns： 无 """ #导入模块 import pickle #新建文件，一定要加b属性，否则可能报错： #TypeError: write() argument must be str, not bytes fw = open(filename, 'wb') #写入数据 pickle.dump(inputTree, fw) #关闭文件 fw.close()def grabTree(filename): """ Function： 读取决策树 Args： filename：文件名称 Returns： pickle.load(fr)：树信息 """ #导入模块 import pickle #打开文件，写入属性一致，否则可能报错： #UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 0: illegal multibyte sequence fr = open(filename, 'rb') #导出数据 return pickle.load(fr) 输出结果： 12345&gt;&gt;&gt; reload(trees)&gt;&gt;&gt; trees.storeTree(myTree, 'classifierStorage.txt')&gt;&gt;&gt; trees.grabTree('classifierStorage.txt')&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125; &emsp;&emsp;通过上面的代码，我们可以将分类器存储在硬盘上，而不用每次对数据分类时重新学习一遍，这也是决策树的优点之一，而k-近邻算法却无法持久化分类器。 使用决策树预测隐形眼镜类型：示例：使用决策树预测隐形眼镜类型： 收集数据：提供的文本文件。 准备数据：解析tab键分割的数据行。 分析数据：快速检查数据，确保正确地解析数据内容，使用createPlot()函数绘制最终的树形图。 训练算法：使用前面编写好的createTree()函数。 测试算法：编写测试函数验证决策树科一正确分类给定的数据实例。 使用算法：存储树的数据结构，以便下次使用时无需重新构造树。 &emsp;&emsp;隐形眼镜数据集是非常著名的数据集，它包含很多患者眼部状况的观察条件以及医生推荐的隐形眼镜类型，数据来源于UCI数据库，为了更容易显示数据，书中对数据做了简单的更改，即lenses.txt文件。 123456789&gt;&gt;&gt; fr = open('lenses.txt')&gt;&gt;&gt; lenses = [inst.strip().split('\t') for inst in fr.readlines()]&gt;&gt;&gt; lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate']&gt;&gt;&gt; import trees&gt;&gt;&gt; lensesTree = trees.createTree(lenses, lensesLabels)&gt;&gt;&gt; lensesTree&#123;'tearRate': &#123;'reduced': 'no lenses', 'normal': &#123;'astigmatic': &#123;'yes': &#123;'prescript': &#123;'myope': 'hard', 'hyper': &#123;'age': &#123;'pre': 'no lenses', 'young': 'hard', 'presbyopic': 'no lenses'&#125;&#125;&#125;&#125;, 'no': &#123;'age': &#123;'pre': 'soft', 'young': 'soft', 'presbyopic': &#123;'prescript': &#123;'myope': 'no lenses', 'hyper': 'soft'&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&gt;&gt;&gt; import treePlotter&gt;&gt;&gt; treePlotter.createPlot(lensesTree) &emsp;&emsp;本渣渣将上述代码包装成函数，方便大家直接调用。 代码实现： 1234567891011121314151617181920212223242526272829303132# -*- coding: UTF-8 -*-"""Created on Aug 31, 2017Test on the modules@author: wordzzzz"""import treesimport treePlotterdef main(): """ Function： 主函数 Args： 无 Returns： 无 """ #打开文件 fr = open('lenses.txt') #读取文件信息 lenses = [inst.strip().split('\t') for inst in fr.readlines()] #定义标签 lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #创建树 lensesTree = trees.createTree(lenses, lensesLabels) #打印树信息 print(lensesTree) #绘制树信息 treePlotter.createPlot(lensesTree)if __name__ == "__main__": main() 输出结果： 12E:\机器学习实战\mycode\Ch03&gt;python3 test.py&#123;'tearRate': &#123;'reduced': 'no lenses', 'normal': &#123;'astigmatic': &#123;'no': &#123;'age': &#123;'presbyopic': &#123;'prescript': &#123;'myope': 'no lenses', 'hyper': 'soft'&#125;&#125;, 'young': 'soft', 'pre': 'soft'&#125;&#125;, 'yes': &#123;'prescript': &#123;'myope': 'hard', 'hyper': &#123;'age': &#123;'presbyopic': 'no lenses', 'young': 'hard', 'pre': 'no lenses'&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125; &emsp;&emsp;隐形眼睛的例子表明决策树可能会产生过多的数据集划分，从而产生过度匹配数据集的问题。我们可以通过裁剪决策树，合并相邻的无法产生大量信息增益的叶节点，消除过度匹配问题。淡然还有很多决策树构造算法，最流行的是C4.5和CART。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之决策树算法（1）算法概述]]></title>
    <url>%2F2017%2F11%2F03%2Fml-7%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch03 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;本渣渣（WordZzzz直接被舍友叫成了“我的渣”，所以以后我在博客中就以此自居了！），最近在学习Peter Harrington的Machine Learning in Action，一边看书一边用Python3.6实现课本中的算法（原书中使用的是Python2.x）。好记性不如烂笔头，奈何本渣渣连烂笔头都买不起，所以就来这不费笔墨的地方费尽心思写博客。本渣渣记性不是一般的差，在此记下每个算法的学习要点及Python代码实现，一方面方便自己以后复习，另一方面贴出来和大家一起学习，共同进步~~~ 注意：python3.x与python2.x的部分函数库有较大差异，针对这个问题，本渣渣会将代码版本升级中遇到的问题在每篇博文的最后列出来，并加以解释说明，帮助大家区分理解。 原著代码（python2.x）地址：https://www.manning.com/books/machine-learning-in-action本渣渣代码（python3.x）地址：https://github.com/WordZzzz/ML/tree/master/Ch03 &emsp;&emsp;博客中的代码都会在本渣渣的GitHub上贴出，欢迎Watch、Star、Fork。 一、算法介绍：&emsp;&emsp;上一个算法介绍的是k-近邻算法，它可以完成很多分类任务，但是它最大的缺点就是无法给出数据的内在含义，决策树的主要优势就在于数据形式非常容易理解。决策树的一个重要任务就是为了理解数据中所蕴含的知识信息，所以决策树可以使用不熟悉的数据集合，并从中提取出一系列规则，这些机器根据数据集创建规则的过程就是机器学习的过程。专家系统中经常食用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。流程图形式的决策树如下： 决策树： 优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。 缺点：可能会产生过度匹配问题。 适用数据类型：数值型和标称型。 &emsp;&emsp;在构造决策树之前，我们需要解决一个问题：当前数据集上哪个特征在划分数据分类时起决定性作用。为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征。完成测试之后，原始数据集就被划分为几个数据子集。这些数据子集会分布在第一个决策点的所有分支上，如果某个分支下的数据属于同一类型，则无需进一步对数据进行分割，如果数据子集内的数据不属于同一类型，则需要重复划分数据子集的过程。 决策树的一般流程 收集数据：可以使用任何方法。 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否否和预测。 训练算法：构造树的数据结构。 测试算法：使用经验树计算错误率。 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好的理解数据的内在含义。 二、代码实现与详解：&emsp;&emsp;一些决策树算法采用二分法划分数据，书里面采用的是ID3算法划分数据集，该算法处理如何划分数据集，何时停止划分数据集。&emsp;&emsp;前面提了个问题，这么多特征，我们每次之选一个特征值进行划分，那这个特征要如何选择呢？下面将进行讲解。 信息增益：&emsp;&emsp;划分数据集的最大原则是：将无序的数据变得更加有序。组织杂乱无章数据的一种方法是使用信息论度量信息，信息论是量化处理信息的分支科学。我们可以在划分数据之前或者之后使用信息论量化信息的内容。 &emsp;&emsp;在划分数据集之前之后信息发生的变化称之为信息增益，获得信息增益最高的特征就是最好的选择。几何信息的度量方式称为香农熵或者简称为熵（其他学科也有熵这个定义，意思都差不多），这个名字来源于信息论之父克劳德·香农。 &emsp;&emsp;熵定义为信息的期望值，如果待分类的事物可能划分在多类分类中，则符号$x_i$的信息论定义为： $$l(x_i) = -log_2p(x_i)$$ 其中$p(x_i)$是选择该分类的概率。 &emsp;&emsp;为了计算熵，我们需要计算所有类别可能值包含的信息期望值，通过下面的公式得到： $$H = - \sum{^n_{i-1}p(x_i)log_2p(x_i)}$$ 其中n是分类的数目。创建trees.py文件，我们来使用python计算信息熵。 &emsp;&emsp;为了后续测试方便，我们先编写createDataSet()函数，创建数据集。 代码实现： 123456789101112131415161718192021222324252627# -*- coding: UTF-8 -*-"""Created on Aug 18, 2017Decision Tree Source Code@author: wordzzzz"""from math import logdef createDataSet(): """ Function： 创建数据集 Args： 无 Returns： dataSet：数据集 labels：标签 """ #创建数据集 dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] #创建标签 labels = ['no surfacing','flippers'] #返回创建的数据集和标签 return dataSet, labels 结果输出： 1234&gt;&gt;&gt; import trees&gt;&gt;&gt; myDat, labels = trees.createDataSet()&gt;&gt;&gt; myDat[[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] &emsp;&emsp;接下来编写calcShannonEnt(dataSet)函数，计算给定数据集的香农熵。 代码实现： 12345678910111213141516171819202122232425262728293031def calcShannonEnt(dataSet): """ Function： 计算给定数据集的香农熵 Args： dataSet：数据集 Returns： shannonEnt：香农熵 """ #计算数据集中实例的总数 numEntries = len(dataSet) #创建一个数据字典 labelCounts = &#123;&#125; #为所有可能的分类创建字典 for featVec in dataSet: #字典的键值等于最后一列的数值 currentLabel = featVec[-1] #如果当前键值不存在，则扩展字典并将当前键值加入字典 if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 #每个键值都记录下当前类别出现的次数 labelCounts[currentLabel] += 1 #初始化香农熵 shannonEnt = 0.0 #计算香农熵 for key in labelCounts: #利用所有类别标签发生频率计算类别出现的概率 prob = float(labelCounts[key])/numEntries #计算香农熵，log(prob, 2)是以2为底求prob的对数 shannonEnt -= prob * log(prob, 2) #返回香农熵计算结果 return shannonEnt 结果输出： 12&gt;&gt;&gt; trees.calcShannonEnt(myDat)0.9709505944546686 &emsp;&emsp;熵越高，则混合的数据也越多，我们可以在数据集中添加更多的分类，观察熵是如何变化的： 12345&gt;&gt;&gt; myDat[0][-1]='maybe'&gt;&gt;&gt; myDat[[1, 1, 'maybe'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]&gt;&gt;&gt; trees.calcShannonEnt(myDat)1.3709505944546687 划分数据集：&emsp;&emsp;分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以判断当前是否正确划分了数据集。我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式。 &emsp;&emsp;编写splitDataSet(dataSet, axis, value)函数，按照给定特征划分数据集。 代码实现： 123456789101112131415161718192021222324def splitDataSet(dataSet, axis, value): """ Function： 按照给定特征划分数据集 Args： dataSet：带划分的数据集 axis：划分数据集的特征 value：需要返回的特征的值 Returns： retDataSet：符合特征的数据集 """ #创建新的list对象 retDataSet = [] #抽取数据集 for featVec in dataSet: #将符合特征的数据抽取出来 if featVec[axis] == value: #截取列表中第axis+1个之前的数据 reducedFeatVec = featVec[:axis] #将第axis+2之后的数据接入到上述数据集 reducedFeatVec.extend(featVec[axis+1:]) #将处理结果作为列表接入到返回数据集 retDataSet.append(reducedFeatVec) #返回符合特征的数据集 return retDataSet 输出结果： 123456789&gt;&gt;&gt; reload(trees)&lt;module 'trees' from 'E:\\机器学习实战\\mycode\\Ch03\\trees.py'&gt;&gt;&gt;&gt; myDat, labels = trees.createDataSet()&gt;&gt;&gt; myDat[[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]&gt;&gt;&gt; trees.splitDataSet(myDat,0,1)[[1, 'yes'], [1, 'yes'], [0, 'no']]&gt;&gt;&gt; trees.splitDataSet(myDat,0,0)[[1, 'no'], [1, 'no']] 注意事项： Python语言不用考虑内存分配问题，在函数中传递的是列表的引用，在函数内部对列表对象的更改，将会影响该列表对象的整个生存周期。为了消除这个不良影响，我们需要在函数的开始创建一个新列表。 代码中使用了extend()和append()来抽取符合要求的元素，这两个方法功能类似，但是在处理多个列表时，这两个方法的处理结果是完全不同的。 append 12345&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[4,5,6]&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; a[1, 2, 3, [4, 5, 6]] extend 1234&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6] &emsp;&emsp;编写chooseBestFeatureToSplit(dataSet)函数， 选择最好的数据集划分方式。该函数调用的数据需要满足一定的要求：第一个要求是，数据必须是一种由列表元素组成的列表，而且所有的列表元素都要具有相同的数据长度；第二个要求是，数据的最后一列或者每个实例的最后一个元素是当前实例的类别标签。 代码实现： 1234567891011121314151617181920212223242526272829303132333435def chooseBestFeatureToSplit(dataSet): """ Function： 选择最好的数据集划分方式 Args： dataSet：待划分的数据集 Returns： bestFeature：划分数据集最好的特征 """ #初始化特征数量 numFeatures = len(dataSet[0]) - 1 #计算原始香农熵 baseEntropy = calcShannonEnt(dataSet) #初始化信息增益和最佳特征 bestInfoGain = 0.0; bestFeature = -1 #选出最好的划分数据集的特征 for i in range(numFeatures): #创建唯一的分类标签列表 featList = [example[i] for example in dataSet] #从列表中创建集合，以得到列表中唯一元素值 uniqueVals = set(featList) #初始化香农熵 newEntropy = 0.0 #计算每种划分方式的信息熵 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) prob = len(subDataSet)/float(len(dataSet)) newEntropy += prob * calcShannonEnt(subDataSet) #得到信息增益 infoGain = baseEntropy - newEntropy #计算最好的信息增益 if (infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i #返回最好的特征 return bestFeature note：从列表中创建集合是Python语言得到列表中唯一元素值的最快方法。 输出结果： 12345678&gt;&gt;&gt; reload(trees)&lt;module 'trees' from 'E:\\机器学习实战\\mycode\\Ch03\\trees.py'&gt;&gt;&gt;&gt; myDat, labels = trees.createDataSet()&gt;&gt;&gt; trees.chooseBestFeatureToSplit(myDat)0&gt;&gt;&gt; myDat[[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]&gt;&gt;&gt; 递归构建决策树：&emsp;&emsp;从数据集构造决策树算法的工作原理如下：得到原始数据，然后基于最好的属性值划分数据集。第一次划分之后，数据将被向下传递到树分支的下一个节点，在这个节点上，可以再次划分数据（递归）。 &emsp;&emsp;递归结束的条件：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所欲实例都具有相同的分类，则得到一个叶子节点或者终止块。任何到达叶子节点的数据必须属于叶子节点的分类，如下图： &emsp;&emsp;如果数据集已经处理了所有的属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，在这种情况下，书中采用的是多数表决的方法决定该叶子节点的分类。 &emsp;&emsp;编写majorityCnt(classList)函数，进行多数表决，这里和k-近邻算法里面的classify0部分的投票表决代码非常类似。 代码实现： 123456789101112131415161718192021def majorityCnt(classList): """ Function： 决定叶子结点的分类 Args： classList：分类列表 Returns： sortedClassCount[0][0]：叶子结点分类结果 """ #创建字典 classCount=&#123;&#125; #给字典赋值 for vote in classList: #如果字典中没有该键值，则创建 if vote not in classCount.keys(): classCount[vote] = 0 #为每个键值计数 classCount[vote] += 1 #对classCount进行排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) #返回叶子结点分类结果 return sortedClassCount[0][0] &emsp;&emsp;编写createTree(dataSet, labels)函数，创建树 代码实现： 1234567891011121314151617181920212223242526272829303132333435def createTree(dataSet, labels): """ Function： 创建树 Args： dataSet：数据集 labels：标签列表 Returns： myTree：创建的树的信息 """ #创建分类列表 classList = [example[-1] for example in dataSet] #类别完全相同则停止划分 if classList.count(classList[0]) == len(classList): return classList[0] #遍历完所有特征时返回出现次数最多的类别 if len(dataSet[0]) == 1: return majorityCnt(classList) #选取最好的分类特征 bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] #创建字典存储树的信息 myTree = &#123;bestFeatLabel:&#123;&#125;&#125; del(labels[bestFeat]) #得到列表包含的所有属性值 featValues = [example[bestFeat] for example in dataSet] #从列表中创建集合 uniqueVals = set(featValues) #遍历当前选择特征包含的所有属性值 for value in uniqueVals: #复制类标签 subLabels =labels[:] #递归调用函数createTree()，返回值将被插入到字典变量myTree中 myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) #返回字典变量myTree return myTree 输出结果： 123456&gt;&gt;&gt; reload(trees)&lt;module 'trees' from 'E:\\机器学习实战\\mycode\\Ch03\\trees.py'&gt;&gt;&gt;&gt; myDat, labels = trees.createDataSet()&gt;&gt;&gt; myTree = trees.createTree(myDat, labels)&gt;&gt;&gt; myTree&#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125; &emsp;&emsp;变量myTree包含了很多代表树结构信息的嵌套字典，从左边开始，第一个关键字no surfacing是第一个划分数据集的特征名称，该关键字的值也是另一个数据字典。第二个关键字是no surfacing特征划分的数据集，这些关键字的值是no surfacing节点的子节点。这些值可能是类标签，也可能是另一个数据字典，如果值是标签，则该子节点是叶子结点；如果是另一个数据字典，则子节点是一个判断节点，这种格式结构不断重复就构成了整棵树。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之Logistic回归（2）最佳回归系数确定]]></title>
    <url>%2F2017%2F11%2F02%2Fml-5%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch05 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;Sigmoid函数的输入记为z，有下面公式得出： $$z = w_0x_0 + w_1x_1 + w_2x_2 +···+ w_nx_n$$ &emsp;&emsp;如果采用向量的写法，上述公式可以写成$$z = w^Tx$$，它表示将这两个数值向量对应元素相乘然后全部加起来即得到z值。其中的向量x是分类器的输入数据，向量w也就是我们要找到的最佳参数系数，从而使得分类器尽可能的精确。为了寻找最佳参数，我们需要用到最优化理论的一些知识。 &emsp;&emsp;下面首先介绍梯度上升这一优化算法，我们将学习到如何使用该方法求得数据集的最佳参数。接下来，展示如何绘制梯度上升法产生的决策变截图，该图能将梯度上升法的分类效果可视化地呈现出来。最后，我们将学习随机梯度上升算法，以及如何对其进行修改以获得更好的效果。 梯度上升算法&emsp;&emsp;梯度上升算法基于的思想是：要找到某函数的最大值，最好的办法就是沿着该函数的梯度方向探寻。如果梯度记为$\nabla$，则函数f(x,y)的梯度由下式表示： $$\nabla f(x,y) = \begin{pmatrix} \frac {\partial f(x,y)} {\partial x} \ \frac {\partial f(x,y)} {\partial y} \ \end{pmatrix}$$ &emsp;&emsp;这是机器学习中最容易造成混淆的一个地方，但在数学上并不难，需要做的只是牢记这些符号的含义。这个梯度意味着要沿x的方向移动$\frac {\partial f(x,y)} {\partial x}$，沿y的方向移动$\frac {\partial f(x,y)} {\partial y}$。其中，函数f(x,y)必须要在待计算的点上有定义并且可微。一个具体的函数例子见下图。 &emsp;&emsp;图中的梯度上升算法沿梯度方向移动了一步。乐意看到，梯度算子总是指向函数值增长最快的方向。这里说到移动方向，而未提及移动量的大小。该量值称为步长，记作α。用向量来表示的话，梯度上升算法的迭代公式如下： $$w: = w + \alpha \nabla_w f(w)$$ &emsp;&emsp;该公式将一直被迭代执行，直到达到某个停止条件为止，比如设定的迭代次数或者达到某个允许的误差范围。 &emsp;&emsp;如果我没记错的话，Andrew在course的machine learning第三周的课程中使用的是梯度下降算法，它的公式为： $$w: = w - \alpha \nabla_w f(w)$$ &emsp;&emsp;我们可以看到，两个算法其实是一样的，只是公式中的加减法不同而已。梯度上升算法用来求函数的最大值，而梯度下降算法用来求函数的最小值。 训练算法：使用梯度上升找到最佳参数&emsp;&emsp;基于上面的内容，我们来看一个Logistic回归分类器的应用例子，从下图可以看到我们采集的数据集。 &emsp;&emsp;上图中有100个样本点，每个点包含两个数值型特征：X1和X2。在此数据集上，我们将通过使用梯度上升法找到最佳回归系数，也就是拟合出Logistic回归模型的最佳参数。 &emsp;&emsp;梯度上升法的伪代码如下： 12345每个回归系数初始化为1重复R次： 计算整个数据集的梯度 使用alpha 下gradient 更新回归系数的向量返回回归系数 &emsp;&emsp;下面的代码是梯度上升算法的具体实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# -*- coding: UTF-8 -*- #'''Created on Sep 15, 2017Logistic Regression Working Module@author: WordZzzz'''from numpy import *def loadDataSet(): """ Function： 加载数据集 Input： testSet.txt：数据集 Output： dataMat：数据矩阵100*3 labelMat：类别标签矩阵1*100 """ #初始化数据列表和标签列表 dataMat = []; labelMat = [] #打开数据集 fr = open('testSet.txt') #遍历每一行 for line in fr.readlines(): #删除空白符之后进行切分 lineArr = line.strip().split() #数据加入数据列表 dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])]) #标签加入数据列表 labelMat.append(int(lineArr[2])) #返回数据列表和标签列表 return dataMat, labelMatdef sigmoid(inX): """ Function： sigmoid函数 Input： inX：矩阵运算结果100*1 Output： 1.0/(1+exp(-inX))：计算结果 """ #返回计算结果 return 1.0/(1+exp(-inX))def gradAscent(dataMatIn, classLabels): """ Function： logistic回归梯度上升函数 Input： dataMatIn：数据列表100*3 classLabels：标签列表1*100 Output： weights：权重参数矩阵 """ #转换为numpy矩阵dataMatrix：100*3 dataMatrix = mat(dataMatIn) #转换为numpy矩阵并转置为labelMat：100*1 labelMat = mat(classLabels).transpose() #获得矩阵行列数 m,n = shape(dataMatrix) #初始化移动步长 alpha = 0.001 #初始化地带次数 maxCycles = 500 #初始化权重参数矩阵，初始值都为1 weights = ones((n,1)) #开始迭代计算参数 for k in range(maxCycles): #100*3 * 3*1 =&gt; 100*1 h = sigmoid(dataMatrix * weights) #计算误差100*1 error = (labelMat - h) #更新参数值 weights = weights + alpha * dataMatrix.transpose() * error #返回权重参数矩阵 return weights &emsp;&emsp;需要强调的是，gradAscent函数中的for循环部分中的运算是矩阵运算。变量h不是一个数而是一个列向量，列向量的元素个数等于样本个数，这里是100.对应的运算dataMatrix * weights代表不止一次乘积计算，实际上该运算包含了300次的乘积。 &emsp;&emsp;接下来我们看看实际效果，打开终端，输入命令行： 123456&gt;&gt;&gt; import logRegres&gt;&gt;&gt; dataArr, labelMat = logRegres.loadDataSet()&gt;&gt;&gt; logRegres.gradAscent(dataArr, labelMat)matrix([[ 4.12414349], [ 0.48007329], [-0.6168482 ]]) 分析数据：画出决策边界&emsp;&emsp;分析数据，当然离不开可视化模块matplotlib，代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445def plotBestFit(weights): """ Function： 画出数据集和最佳拟合直线 Input： weights：权重参数矩阵 Output： 包含数据集和拟合直线的图像 """ #加载matplotlib中的pyplot模块 import matplotlib.pyplot as plt #导入数据 dataMat, labelMat = loadDataSet() #创建数组 dataArr =array(dataMat) #获取数组行数 n = shape(dataArr)[0] #初始化坐标 xcord1 = []; ycord1 = [] xcord2 = []; ycord2 = [] #遍历每一行数据 for i in range(n): #如果对应的类别标签对应数值1，就添加到xcord1，ycord1中 if int(labelMat[i]) == 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2]) #如果对应的类别标签对应数值0，就添加到xcord2，ycord2中 else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2]) #创建空图 fig = plt.figure() #添加subplot，三种数据都画在一张图上 ax = fig.add_subplot(111) #1类用红色标识，marker='s'形状为正方形 ax.scatter(xcord1, ycord1, s=30, c='red', marker='s') #0类用绿色标识，弄认marker='o'为圆形 ax.scatter(xcord2, ycord2, s=30, c='green') #设置x取值，arange支持浮点型 x = arange(-3.0, 3.0, 0.1) #配计算y的值 y = (-weights[0]-weights[1]*x)/weights[2] #画拟合直线 ax.plot(x, y) #贴坐标表头 plt.xlabel('X1'); plt.ylabel('X2') #显示结果 plt.show() &emsp;&emsp;打开终端，输入命令行进行测试： 12345&gt;&gt;&gt; from imp import reload&gt;&gt;&gt; reload(logRegres)&lt;module 'logRegres' from 'logRegres.py'&gt;&gt;&gt;&gt; weights = logRegres.gradAscent(dataArr, labelMat)&gt;&gt;&gt; logRegres.plotBestFit(weights.getA()) &emsp;&emsp;这个分类效果相当不错，从图上看之分错了两到四个点。但是，尽管例子简单并且数据集很小，这个方法却很需要大量的计算（300次乘积）。下面我们将对该算法进行改进，从而使它可以用到真实数据上。 训练算法：随机梯度上升&emsp;&emsp;梯度上升算法在每次更新回归系数时都需要遍历整个数据集，计算复杂度太高了。一种改进方法就是一次仅用一个样本点来更新回归系数，该方法称为随机梯度上升算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度上升算法是一个在线学习方法。与“在线学习”相对应的，一次处理所有数据被称为是“批处理”。 &emsp;&emsp;随机梯度上升算法伪代码如下： 12345所有回归系数初始化为1对数据集中每个样本 计算该样本的梯度 使用alpha x gradient 更新回归系数值返回回归系数值 &emsp;&emsp;代码实现如下： 12345678910111213141516171819202122232425def stocGradAscent0(dataMatrix, classLabels): """ Function： 随机梯度上升算法 Input： dataMatIn：数据列表100*3 classLabels：标签列表1*100 Output： weights：权重参数矩阵 """ #获取数据列表大小 m,n = shape(dataMatrix) #步长设置为0.01 alpha = 0.01 #初始化权重参数矩阵，初始值都为1 weights = ones(n) #遍历每一行数据 for i in range(m): #1*3 * 3*1 h = sigmoid(sum(dataMatrix[i]*weights)) #计算误差 error = classLabels[i] - h #更新权重值 weights = weights + alpha * error * dataMatrix[i] #返回权重参数矩阵 return weights &emsp;&emsp;可以看到，随机梯度上升算法与梯度上升算法在代码上很相似，但也有一些区别：第一，后者的变量h和误差error都是向量，而前者则全是数值；第二，前者没有矩阵的转换过程，所有变量的数据类型都是Numpy数组。 123456&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; reload(logRegres)&lt;module 'logRegres' from 'logRegres.py'&gt;&gt;&gt;&gt; dataArr, labelMat = logRegres.loadDataSet()&gt;&gt;&gt; weights=logRegres.stocGradAscent0(array(dataArr), labelMat)&gt;&gt;&gt; logRegres.plotBestFit(weights) &emsp;&emsp;执行完毕之后，效果如下图所示，该图与上一张图有一些相似之处。可以看到，拟合出来的直线比上次差了点，但是你要知道，这次的随机梯度上升算法，我们只是在整个数据集上迭代了一次而已（算成100次也是和500次差很多）。 &emsp;&emsp;一个判断优化算法优劣的可靠算法是看它是否收敛，也就是说参数是否达到了稳定值。随机梯度上升算法迭代200次，三个回归系数的变化如下图所示。 &emsp;&emsp;从上图中我们可以看到，X2迭代50次左右就稳定了，但是其他两个则需要过多次的迭代。同时我们发现在大的波动停止之后，还会有一些小的周期性波动，产生这种现象的原因是因为存在一些不能正确分类的样本点（数据集并非线性可分），在每次迭代时会引发系数的剧烈改变。我们期望算法能避免来回波动，并且收敛也要足够快。 改进的随机梯度上升算法&emsp;&emsp;先上代码： 12345678910111213141516171819202122232425262728293031323334def stocGradAscent1(dataMatrix, classLabels, numIter=150): """ Function： 改进的随机梯度上升算法 Input： dataMatIn：数据列表100*3 classLabels：标签列表1*100 numIter：迭代次数 Output： weights：权重参数矩阵 """ #获取数据列表大小 m, n = shape(dataMatrix) #初始化权重参数矩阵，初始值都为1 weights = ones(n) #开始迭代，迭代次数为numIter for j in range(numIter): #初始化index列表，这里要注意将range输出转换成list dataIndex = list(range(m)) #遍历每一行数据，这里要注意将range输出转换成list for i in list(range(m)): #更新alpha值，缓解数据高频波动 alpha = 4/(1.0+j+i)+0.0001 #随机生成序列号，从而减少随机性的波动 randIndex = int(random.uniform(0, len(dataIndex))) #序列号对应的元素与权重矩阵相乘，求和后再求sigmoid h = sigmoid(sum(dataMatrix[randIndex]*weights)) #求误差，和之前一样的操作 error = classLabels[randIndex] - h #更新权重矩阵 weights = weights + alpha * error * dataMatrix[randIndex] #删除这次计算的数据 del(dataIndex[randIndex]) #返回权重参数矩阵 return weights &emsp;&emsp;改进： 一方面，alpha在每次迭代的时候都会调整，这会缓解上一张图中的数据高频波动。另外，虽然alpha会随着迭代次数不断减小，但永远不会减小到0，这是因为alpha更新公式中存在一个常数项，必须这样做的原因是为了保证在多次迭代之后新数据仍然具有一定得影响。如果要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。另一点值得注意的是，在降低alpha的函数中，alpha每次减少i/(j+i)时，alpha就不是严格下降的。便面参数的严格下降也常见于模拟退火算法等其他优化算法中。 另一方面，通过随机选取样本来更新回归系数，可以减少周期性的波动。 &emsp;&emsp;同样的，下图反映了stocGradAscent1函数中，每次迭代时各个回归系数的变化情况。 &emsp;&emsp;我们可以看到，除了周期性波动的减少，上图的水平轴也少了很多（只迭代了40次），这是因为该函数可以收敛的更快。 12345&gt;&gt;&gt; reload(logRegres)&lt;module 'logRegres' from 'logRegres.py'&gt;&gt;&gt;&gt; dataArr, labelMat = logRegres.loadDataSet()&gt;&gt;&gt; weights=logRegres.stocGradAscent1(array(dataArr), labelMat)&gt;&gt;&gt; logRegres.plotBestFit(weights) &emsp;&emsp;分类效果如图所示： &emsp;&emsp;迄今为止我们分析了回归系数的变化情况，但还没有达到本章的最终目标，即完成具体的分类任务。下一届将使用随机梯度上升算法来解决病马的生死预测问题。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之Logistic回归（1）算法概述]]></title>
    <url>%2F2017%2F11%2F02%2Fml-4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch05 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;其实从贝叶斯那一章开始，公式推导就渐渐多了起来，当然我在这里不是特指《机器学习实战》这本书，而是指整个机器学习的学习过程。但是为了按照原计划按时推博客（每周末推送《机器学习实战》一章的内容），所以公式推导部分相对于《机器学习实战》中对应的章节，会滞后两到三周发布。 Logistic回归&emsp;&emsp;Andrew在course的machine learning第三周的课程中，讲的就是logistic回归，感兴趣的朋友们可以去看看。 &emsp;&emsp;首先介绍一下什么是回归。假设现在有一些数据点，我们用一条直线对这些点进行拟合（该线称为最佳拟合直线），这个拟合过程就称作回归。利用logistic回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归”一词源于最佳拟合，表示要找到最佳拟合参数集。训练分类器时的做大就是寻找最佳拟合参数，实用的是最优化方法，这也是我们首次接触最优化算法。 Logistic回归的一般过程： 收集数据：采用任意方法收集数据。 准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。 分析数据：采用任意方法对数据进行分析。 训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。 测试算法：一旦训练步骤完成，分类将会很快。 使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数就可以对这些数值进行简单的回归计算，判定他们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。 基于Logistic回归和Sigmoid函数的分类Logistic回归： 优点：计算代价不高，易于理解和实现。 缺点：容易欠拟合，分类精度可能不高。 适用数据类型：数值型和标称型数据。 &emsp;&emsp;我们想要的函数，应该是能接受所有的输入然后预测出类别。例如，在两个类的情况下，预测结果输出0或1。我们之前应该接触过类似的函数：单位阶跃函数。我的天，看书之前，我都没想起来单位阶跃函数还有个高大上的名字：海维塞德阶跃函数（Heaviside step function）。然而，单位阶跃函数的问题在于这个函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程很难处理。还好，Sigmoid函数挺身而出，用于和单位阶跃函数类似的性质，但在数学上更易处理。公式如下： $$\sigma(z) = \frac{1}{(1 + e_{-z})}$$ &emsp;&emsp;下图给出了Sigmoid函数在不同坐标尺度下的两条曲线图。当x为0时，Sigmoid函数值为0.5.随着x的增大，对应的Sigmoid值将逼近与1；而随着x的减小，Sigmoid的值将逼近于0.如果横坐标刻度足够大，Sigmoid函数看起来很像一个单位阶跃函数。 &emsp;&emsp;因此，为了实现Lgistic回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值都相加，将这个总和都带入Sigmoid()函数中，进而得到一个范围在0~1之间的数值。大于0.5则被分入1类，小于0.5则被分入0类。所以，Logistic回归也可以被看成是一种概率估计。 &emsp;&emsp;确定了分类器的函数形式之后，现在的问题成了：最佳回归系数是多少？如何确定他的大小？这些问题我们将在下一篇博文中进行讲解，包括基本的梯度上升法和一个改进的随机梯度上升法，这些最优化算法将被用于分类器的训练。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之Logistic回归（3）预测病马死亡率]]></title>
    <url>%2F2017%2F11%2F02%2Fml-6%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch05 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;本节将使用Logistic会归来预测还有疝病的马的存货问题。智力的数据包含368个样本和28个特征。疝病逝描述马胃肠痛的术语，然而这种病不一定来源于马的肠胃问题，其他问题也可能引发该病。 &emsp;&emsp;示例：使用Logistic回归估计马疝病的死亡率 收集数据：给定数据文件。 准备数据：用Python解析文本文件并填充缺失值。 分析数据：可视化并观察数据。 训练算法：使用优化算法，找到最佳的系数。 测试算法：为了量化回归效果，需要观察错误率，根据错误率决定是否回退到训练阶段，通过改变迭代的次数和步长等参数来得到更好的回归系数。 使用算法：实现一个简单的命令行程序来收集马的症状并输出预测结果并非难事，这可以作为留给读者的一道习题。 &emsp;&emsp;另外需要说明的是，除了部分指标主观和难以测量外，该数据还存在一个问题，数据集中有30%的值是缺失的。下面将首先介绍如何处理数据集中的数据缺失问题，然后利用Logistic回归和随机梯度上升算法来预测病马的生死。 准备数据；处理数据中的缺失值&emsp;&emsp;数据中的缺失值是个非常棘手的问题，有很多文献都致力于解决这个问题。下面给出一些可选的做法： 使用可用特征的均值来填补缺失值； 使用特殊值来填补缺失值，如-1； 忽略所有缺失的样本； 使用相似样本的均值添补缺失值； 使用另外的机器学习算法预测缺失值。 &emsp;&emsp;现在，我们对后面用到的数据集进行预处理，使其可以顺利地使用分类算法。在预处理阶段需要做两件事：第一，所有的缺失值必须用一个实数值来替换，因为我们使用的Numpy数组不允许包含缺失值。这里选择实数0来替换所有缺失值，恰好能适用于Lodistic回归。这样做的原因在于，我们需要一个在更新时不会影响系数的值。回归系数的更新公式如下： $$weights = weights + alpha error dataMatrix[ranIndex]$$ &emsp;&emsp;很明显，如果dataMatrix的某特征对应值为0，那么该特征的系数将不做更新，即$weights = weights$。另外，由于sigmoid(0)=0.5对结果的预测不具有任何倾向性，因为上述做法也不会对误差项造成任何影响，完美！ &emsp;&emsp;预处理的第二件事是，如果发现一条数据的类别标签已经缺失，纳闷我们的简单做法就是将该条数据丢弃。这是因为类别标签和特征不同，很难确定采用某个合适的值来替换。采用Logistic回归进行分类时，这种做法是合理的，而如果采用类似kNN的方法就可能不太可行。 &emsp;&emsp;原始数据经过预处理之后保存成两个文件：horseColicTest.txt和horseColicTraining.txt。如果相对原始数据和预处理数据进行比较，可以在http://archive.ics.uci.edu/ml/dataset/Horse+Colic浏览这些数据。 预测算法：用Logistic回归进行分类&emsp;&emsp;使用Logistic回归方法进行分类并不需要做很多工作，所需要做的只是把测试集上每个特征向量乘以最优化方法得来的回归系数，再将该乘积结果求和，最后输入到Sigmoid函数即可。实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990def classifyVector(inX, weights): """ Function： 分类函数 Input： inX：计算得出的矩阵100*1 weights：权重参数矩阵 Output： 分类结果 """ #计算sigmoid值 prob = sigmoid(sum(inX*weights)) #返回分类结果 if prob &gt; 0.5: return 1.0 else: return 0.0def colicTest(): """ Function： 训练和测试函数 Input： 训练集和测试集文本文档 Output： 分类错误率 """ #打开训练集 frTrain = open('horseColicTraining.txt') #打开测试集 frTest = open('horseColicTest.txt') #初始化训练集数据列表 trainingSet = [] #初始化训练集标签列表 trainingLabels = [] #遍历训练集数据 for line in frTrain.readlines(): #切分数据集 currLine = line.strip().split('\t') #初始化临时列表 lineArr = [] #遍历21项数据重新生成列表，因为后面格式要求，这里必须重新生成一下。 for i in range(21): lineArr.append(float(currLine[i])) #添加数据列表 trainingSet.append(lineArr) #添加分类标签 trainingLabels.append(float(currLine[21])) #获得权重参数矩阵 trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, 500) #初始化错误分类计数 errorCount = 0 numTestVec = 0.0 #遍历测试集数据 for line in frTest.readlines(): # numTestVec += 1.0 #切分数据集 currLine =line.strip().split('\t') #初始化临时列表 lineArr = [] #遍历21项数据重新生成列表，因为后面格式要求，这里必须重新生成一下。 for i in range(21): lineArr.append(float(currLine[i])) #如果分类结果和分类标签不符，则错误计数+1 if int(classifyVector(array(lineArr), trainWeights)) != int(currLine[21]): errorCount += 1 #计算分类错误率 errorRate = (float(errorCount)/numTestVec) #打印分类错误率 print("the error rate of this test is: %f" % errorRate) #返回分类错误率 return errorRatedef multiTest(): """ Function： 求均值函数 Input： 无 Output： 十次分类结果的平均值 """ #迭代次数 numTests = 10 #初始错误率和 errorSum = 0.0 #调用十次colicTest()，累加错误率 for k in range(numTests): errorSum += colicTest() #打印平均分类结果 print("after %d iterations the average error rate is: %f" % (numTests, errorSum/float(numTests))) &emsp;&emsp;打开终端，输入命令行进行测试： 1234567891011121314&gt;&gt;&gt; reload(logRegres)&lt;module 'logRegres' from 'E:\\机器学习实战\\mycode\\Ch05\\logRegres.py'&gt;&gt;&gt;&gt; logRegres.multiTest()the error rate of this test is: 0.358209the error rate of this test is: 0.402985the error rate of this test is: 0.388060the error rate of this test is: 0.328358the error rate of this test is: 0.388060the error rate of this test is: 0.313433the error rate of this test is: 0.283582the error rate of this test is: 0.313433the error rate of this test is: 0.298507the error rate of this test is: 0.343284after 10 iterations the average error rate is: 0.341791 &emsp;&emsp;从上面的结果可以看出，10次迭代之后的平均错误率为35%左右。事实上，这个结果并不差，因为哦我们有30%的数据缺失。当然，如果调整colicTest中迭代次数和stocGradAscent1中的步长，平均错误率科一降到20%左右。 &emsp;&emsp;对于这一章的内容，还计划写一篇博文《机器学习实战》之Logistic回归（4）Logisitc回归与最大熵模型，主要是公式推导，预计两周后更新。《机器学习实战》的Python3代码实现还是每周日进行更新，相应章节对应的公式推导和拓展预计有两周延迟。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之k近邻算法（3）识别手写数字]]></title>
    <url>%2F2017%2F11%2F01%2Fml-3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch02 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;在这篇博文里，本渣渣将带领大家一步一步构造出使用k-近邻分类器的手写识别系统。书中提供了数据集，从0到9，如图所示： &emsp;&emsp;这些数字已经经过处理，统一变成32像素*32像素的黑白图像（文本格式）。 &emsp;&emsp;下面我们列出算法流程： (1)收集数据：提供文本文件。 (2)准备数据：编写函数img2vector(),将图像格式装还未分类器实用的向量格式。 (3)分析数据：在Python命令提示符中检擦数据，确保它符合要求。 (4)训练算法：此步骤不适用于k-近邻算法。 (5)测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6)使用算法：没有精力写应用程序了，爱折腾的大神们可以试试，自己以后复习的时候再写写这块。主要就是从图像中提取数字，并完成数字识别。 ##一、准备数据： &emsp;&emsp;世纪图像存储在源代码的两个子目录里：目录trainingDigits中包含了大约2000个例子，每个例子的内容如下图所示，每个数字大约有200个样本；目录testDigits中包含了大约900个测试数据。两组数据没有重叠。 &emsp;&emsp;我们首先需要将图像转换成测试向量：即用一个1 1024的NumPy数组存储32 32的图像信息。 代码实现： 123456789101112131415161718# -*- coding: UTF-8 -*-"""Created on Aug 18, 2017kNN: k Nearest NeighborsInput: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label@author: wordzzzz"""from numpy import *import operatorfrom os import listdir 123456789101112131415161718192021def img2vector(filename): """ Function： 32*32图像转换为1*1024向量 Args： filename：文件名称字符串 Returns： returnVect：转换之后的1*1024向量 """ #初始化要返回的1*1024向量 returnVect = zeros((1, 1024)) #打开文件 fr = open(filename) #读取文件信息 for i in range(32): #循环读取文件的前32行 lineStr = fr.readline() for j in range(32): #将每行的头32个字符存储到要返回的向量中 returnVect[0, 32*i+j] = int(lineStr[j]) #返回要输出的1*1024向量 return returnVect 输出结果： 1234567891011&gt;&gt;&gt; reload(kNN)&gt;&gt;&gt; testVector = kNN.img2vector('testDigits/0_13.txt')&gt;&gt;&gt; testVector[0,0:31]array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])&gt;&gt;&gt; testVector[0,32:63]array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) ##二、测试算法： &emsp;&emsp;在之前的kNN.py代码中加入from os import listdir，然后编写下列测试程序即可测试算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def handwritingClassTest(): """ Function： 手写数字测试程序 Args： 无 Returns： returnVect：转换之后的1*1024向量 """ #初始化手写数字标签列表 hwLabels = [] #获取训练目录信息 trainingFileList = listdir('trainingDigits') #获取训练文件数目 m = len(trainingFileList) #初始化训练矩阵 trainingMat = zeros((m,1024)) #开始提取训练集 for i in range(m): #从文件名解析出分类数字 fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) #存储解析出的分类数字到标签中 hwLabels.append(classNumStr) #载入图像 trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr) #获取测试目录信息 testFileList = listdir('testDigits') #初始化错误计数 errorCount = 0.0 #获取测试文件数目 mTest = len(testFileList) #开始测试 for i in range(mTest): #从文件名解析出分类数字 fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) #载入图像 vectorUnderTest = img2vector('trainingDigits/%s' % fileNameStr) #参数传入分类器进行分类 classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3) #打印输出分类结果和真实结果 print("the classifier came back with: %d, the real answer is: %d" %(classifierResult, classNumStr)) #如果分类结果不等于真实结果，错误计数加一 if (classifierResult != classNumStr): errorCount += 1.0 #输出错误技术 print("\nthe total number of errors is: %d" % errorCount) #输出错误率 print("\nthe total error rate is: %f" % (errorCount/float(mTest))) 输出结果： 1234567891011121314&gt;&gt;&gt; reload(kNN)&gt;&gt;&gt; kNN.handwritingClassTest()the classifier came back with: 0, the real answer is: 0the classifier came back with: 0, the real answer is: 0the classifier came back with: 0, the real answer is: 0······the classifier came back with: 9, the real answer is: 9the classifier came back with: 9, the real answer is: 9the classifier came back with: 9, the real answer is: 9the total number of errors is: 13the total error rate is: 0.013742 &emsp;&emsp;k-近邻算法识别手写数字数据集，错误率为1.2%。依赖于分类算法、数据集和程序设置，分类器的输出结果可能有很大的不同。大家可以自行修改变量hoRatio和变量k的数值，看看检测错误率是否会发生变化。 &emsp;&emsp;实际使用这个算法时，算法的执行效率并不高。因为算法需要为每个测试向量做2000次距离计算，而每个距离计算包括了1024个维度浮点运算，总计执行900次，此外，还需要为测试向量准备2MB的存储空间。以后要讲的k决策树科一节省大量的计算开销。 三、k-近邻算法总结：优点： k-近邻算法是分类数据最简单有效的算法，是基于实例的学习，使用算法时我们必须有接近实际数据的训练样本数据。 缺点： k-近邻算法必须保存全部数据集，并对数据集中的每个数据计算距离值，实际使用时耗时耗存储。 而且，它无法给出任何数据的基础结构信息，所以我们不知道平均实例样本与典型实例样本具有什么特征（概率测量方法处理分类问题时可以解决这个问题）。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之k近邻算法（2）我们约会吧]]></title>
    <url>%2F2017%2F11%2F01%2Fml-2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch02 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;在本篇博文中，本渣渣要通过约会网站给自己找个满意的妹纸，嘿嘿嘿！当然，一切都只是模拟，数据什么都是现成的······ &emsp;&emsp;下面我们列出算法流程： (1)收集数据：提供文本文件。 (2)准备数据：使用Python解析文本文件。 (3)分析数据：使用Matplotlib画二维扩散图。 (4)训练算法：此步骤不适用于k-近邻算法。 (5)测试算法：使用提供的部分数据作为测试样本。测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6)使用算法：产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。 一、准备数据&emsp;&emsp;datingTestSet2.txt中，每个样本数据占据一行，总共有1000行。主要包含以下3种特征： 每年获得的飞行常客里程数 玩视频游戏所耗时间百分比 每周消费的冰淇淋公升数 &emsp;&emsp;在将上述特征数据输入到分类器之前，必须将待处理数据的格式改变为分类器可以接受的格式。在kNN.py中创建名为file2matrix的函数，以此来处理输入格式问题。该函数的输入为文件名字符串，输出为训练样本矩阵和类标签向量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: UTF-8 -*-"""Created on Aug 18, 2017kNN: k Nearest NeighborsInput: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label@author: wordzzzz"""from numpy import *import operatorfrom os import listdirdef file2matrix(filename): """ Function： 从文本文件中解析数据 Args： filename：文件名称字符串 Returns： returnMat：训练样本矩阵 classLabelVector：类标签向量 """ #打开文件 fr = open(filename) #得到文件行数 numberOFLines = len(fr.readlines()) #创建返回的NumPy矩阵 returnMat = zeros((numberOFLines, 3)) #创建返回的向量列表 classLabelVector = [] fr = open(filename) index = 0 for line in fr.readlines(): #使用line.strip()截取掉多有的回车符 line = line.strip() #使用tab字符将上一步得到的整行数据分割成一个元素列表 listFromLine = line.split('\t') #选取前三个元素，存储到特征矩阵中 returnMat[index, :] = listFromLine[0:3] #将列表最后一列存储到向量classLabelVector中 classLabelVector.append(int(listFromLine[-1])) index += 1 #返回训练样本矩阵和类标签向量 return returnMat, classLabelVector &emsp;&emsp;注意我们要打开的文本文件是datingTestSet2.txt，而不是datingTestSet.txt，否则会出现如下报错： 123456&gt;&gt;&gt; datingDataMat, datingLabels = kNN.file2matrix('datingTestSet.txt')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "E:\机器学习实战\mycode\Ch02\kNN.py", line 105, in file2matrix classLabelVector.append(int(listFromLine[-1]))ValueError: invalid literal for int() with base 10: 'largeDoses' 输出结果： 123456789101112&gt;&gt;&gt; import kNN&gt;&gt;&gt; datingDataMat,datingLabels = kNN.file2matrix('datingTestSet2.txt')&gt;&gt;&gt; datingDataMatarray([[ 4.09200000e+04, 8.32697600e+00, 9.53952000e-01], [ 1.44880000e+04, 7.15346900e+00, 1.67390400e+00], [ 2.60520000e+04, 1.44187100e+00, 8.05124000e-01], ..., [ 2.65750000e+04, 1.06501020e+01, 8.66627000e-01], [ 4.81110000e+04, 9.13452800e+00, 7.28045000e-01], [ 4.37570000e+04, 7.88260100e+00, 1.33244600e+00]])&gt;&gt;&gt; datingLabels[0:20][3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3] 二、分析数据&emsp;&emsp;首先我们使用Matplotlib制作原始数据的散点图，在Python命令行环境中输入如下命令：123456&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; fig = plt.figure()&gt;&gt;&gt; ax = fig.add_subplot(111)&gt;&gt;&gt; ax.scatter(datingDataMat[:,1], datingDataMat[:,2])&gt;&gt;&gt; plt.show() &emsp;&emsp;输出效果如图2-3所示。散点图使用datingDataMat数据矩阵中的第二、第三列数据，分别表示特征值“玩视频游戏所耗时间百分比”和“每周所消费的冰淇淋公升数”。 &emsp;&emsp;本渣渣在上图中看不出任何规律，因为没加标签信息。Matplotlib库提供的scatter函数支持个性化标记散点图上的点。重新输入上面的代码，并加上下面这段代码：12&gt;&gt;&gt; ax.scatter(datingDataMat[:,1], datingDataMat[:,2],15.0*array(datingLabels), 15.0*array(datingLabels)) &emsp;&emsp;输出效果如图2-4所示。带有样本分类标签的约会数据散点图虽然能够比较容易地区分数据点从属类别，但依然很难根据这张图得出结论性信息。运行createFirstPlot.py可以直接得到该图。 &emsp;&emsp;createDist2.py则使用数据矩阵中的第一、第二列数据，分别表示特征值“每年获得的飞行常客里程数”和“玩视频游戏所耗时间百分比”，展示效果更好： &emsp;&emsp;表2-3给出了提取的四组数据，如果想要极端样本3和样本4之间的距离，可以使用下面的方法：!$\sqrt{(0-67)^2+(20000-32000)^2+(1.1-0.1)^2} $&emsp;&emsp;本渣渣发现，数字差值最大的特征对计算结果的影响最大。但是三种特征对我们来说是同等重要的，所以，我们需要对数值进行归一化，将取值范围处理为0到1之间（当然-1到1之间也可以）。下面是归一化的代码： 1234567891011121314151617181920212223242526def autoNorm(dataSet): """ Function： 归一化特征值 Args： dataSet：训练验本矩阵 Returns： normDataSet：归一化矩阵 ranges：每一列的差值 minVals：每一列的最小值 """ #求取列的最小值 minVals = dataSet.min(0) #求取列的最大值 maxVals = dataSet.max(0) #最大值与最小值做差 ranges = maxVals - minVals #创建输出矩阵normDataSet normDataSet = zeros(shape(dataSet)) #m设定为矩阵dataSet的行数 m = dataSet.shape[0] #对矩阵dataSet每个元素求差 normDataSet = dataSet - tile(minVals, (m, 1)) #对矩阵dataSet每个元素归一化 normDataSet = normDataSet/tile(ranges, (m, 1)) #返回归一化矩阵、差值向量和最小值向量 return normDataSet, ranges, minVals 输出结果： 12345678910111213&gt;&gt;&gt; normMat, ranges, minVals = kNN.autoNorm(datingDataMat)&gt;&gt;&gt; normMatarray([[ 0.44832535, 0.39805139, 0.56233353], [ 0.15873259, 0.34195467, 0.98724416], [ 0.28542943, 0.06892523, 0.47449629], ..., [ 0.29115949, 0.50910294, 0.51079493], [ 0.52711097, 0.43665451, 0.4290048 ], [ 0.47940793, 0.3768091 , 0.78571804]])&gt;&gt;&gt; rangesarray([ 9.12730000e+04, 2.09193490e+01, 1.69436100e+00])&gt;&gt;&gt; minValsarray([ 0. , 0. , 0.001156]) ##三、测试算法 &emsp;&emsp;机器学习算法一个很重要的工作就是评估算法的正确率，通常我们只提供已有数据的90%作为训练样本来训练分类器，而使用其余的10%数据去测试分类器，检测分类器的正确率。需要注意的是，10%的测试数据应该是随机选择的，由于我们的数据并没有按照特定目的来排序，所以我们可以随意选择10%数据而不影响其随机性。 &emsp;&emsp;代码里我们定义一个计数器变量，每次分类器错误的分类数据，计数器就加1，程序执行完成之后计数器的结果除以数据点总数即是错误率。为了测试分类器效果，在kNN.py文件中创建函数datingClassTest，该函数是自包含的，你可以在任何时候在Python运行环境中使用该函数测试分类器效果。 12345678910111213141516171819202122232425262728293031323334def datingClassTest(): """ Function： 分类器测试代码 Args： 无 Returns： classifierResult：分类器分类结果 datingLabels[i]：真实结果 errorCount：分类误差 """ #测试集比例设定：10% hoRatio = 0.1 #从文本文件中解析数据 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') #归一化特征值 normMat, ranges, minVals = autoNorm(datingDataMat) #计算normMat矩阵行数并赋值给m m = normMat.shape[0] #初始化测试向量个数 numTestVecs = int(m*hoRatio) #初始化错误计数 errorCount = 0.0 #对测试集分类，返回分类结果并打印 for i in range(numTestVecs): #传参给分类器进行分类，每个for循环改变的参数只有第一项的测试数据而已 classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3) #打印当前测试数据的分类结果个真实结果 print("the classfier came back with: %d, the real answer is: %d" % (classifierResult, datingLabels[i])) #如果分类结果不等于真是结果，错误计数加一 if (classifierResult != datingLabels[i]): errorCount += 1.0 #输出测试错误率 print("the total error rate is: %f" % (errorCount/float(numTestVecs))) #输出测试错误数 print(errorCount) 输出结果： 12345678910&gt;&gt;&gt; kNN.datingClassTest()the classfier came back with: 3, the real answer is: 3the classfier came back with: 2, the real answer is: 2the classfier came back with: 1, the real answer is: 1······the classfier came back with: 2, the real answer is: 2the classfier came back with: 1, the real answer is: 1the classfier came back with: 3, the real answer is: 1the total error rate is: 0.0500005.0 &emsp;&emsp;分类器处理约会数据集的错误率为5%，这是一个很不错的结果。依赖于分类算法、数据集和程序设置，分类器的输出结果可能有很大的不同。大家可以自行修改变量hoRatio和变量k的数值，看看检测错误率是否会发生变化。 &emsp;&emsp;这个例子表明我们可以正确的预测分类，错误率仅为5%。我们完全可以输入未知对象的属性信息，由分类软件来帮助让判定某一对象的可交往程度。 四、使用算法&emsp;&emsp;我们把我们的代码封装一下，并加入输入捕捉函数input()进行输入捕捉。该函数允许用户输入文本命令行并返回用户所输入的命令。 1234567891011121314151617181920212223242526def classifyPerson(): """ Function： 约会网站测试函数 Args： percentTats：玩视频游戏消耗时间百分比 ffMiles：每年获得的飞行常客里程数 iceCream：每周消费的冰淇淋公升数 Returns： resultList：可交往程度 """ #建立输出列表 resultList = ['not at all', 'in small doses', 'in large doses'] #读取键盘输入的数值 percentTats = float(input("percentage of time spent playing video games?")) ffMiles = float(input("frequent flier miles earned per year?")) iceCream = float(input("liters of ice cream consumed per week?")) #从文本文件中解析数据 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') #归一化特征值 normMat, ranges, minVals = autoNorm(datingDataMat) #将先前读取的键盘输入填入数组 inArr = array([ffMiles, percentTats, iceCream]) #分类：这里也对输入数据进行了归一化 classifierResult = classify0((inArr - minVals) / ranges, normMat, datingLabels, 3) #打印分类信息 print("You wil probably like this person: ", resultList[classifierResult - 1]) 输出结果： 12345&gt;&gt;&gt; kNN.classifyPerson()percentage of time spent playing video games?10frequent flier miles earned per year?10000liters of ice cream consumed per year?0.5You wil probably like this person: in small doses 五、主要区分函数：详解：raw_input( )和input( )：http://blog.csdn.net/u011475210/article/details/77777482 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习实战》之k近邻算法（1）算法概述]]></title>
    <url>%2F2017%2F11%2F01%2Fml-1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 代码地址：https://github.com/WordZzzz/ML/tree/master/Ch02 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 前言：&emsp;&emsp;本渣渣（WordZzzz直接被舍友叫成了“我的渣”，所以以后我在博客中就以此自居了！），最近在学习Peter Harrington的Machine Learning in Action，一边看书一边用Python3.6实现课本中的算法（原书中使用的是Python2.x）。好记性不如烂笔头，奈何本渣渣连烂笔头都买不起，所以就来这不费笔墨的地方费尽心思写博客。本渣渣记性不是一般的差，在此记下每个算法的学习要点及Python代码实现，一方面方便自己以后复习，另一方面贴出来和大家一起学习，共同进步~~~ 注意：python3.x与python2.x的部分函数库有较大差异，针对这个问题，本渣渣会将代码版本升级中遇到的问题在每篇博文的最后列出来，并加以解释说明，帮助大家区分理解。 原著代码（python2.x）地址：https://www.manning.com/books/machine-learning-in-action本渣渣代码（python3.x）地址：https://github.com/WordZzzz/ML/tree/master/Ch02 &emsp;&emsp;博客中的代码都会在本渣渣的GitHub上贴出，欢迎Watch、Star、Fork。 一、算法介绍：&emsp;&emsp;k-近邻算法（kNN）的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法的中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。&emsp;&emsp;简单的说，k-近邻算法采用测量不同特征值之间的距离方法进行分类。 k-近邻算法： 优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。 使用数据范围：数值型和标称型。 &emsp;&emsp;书上有个电影分类的例子，使用k-近邻算法分类爱情片和工作片。书中给出了6部电影的打斗镜头数和接吻镜头数，如图2-1所示。 &emsp;&emsp;假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？下面我们将使用kNN来解决这个问题。 &emsp;&emsp;首先，我们需要数据，即这个未知电影存在多少个打斗镜头和接吻镜头，图2-1中间问号位置是该电影出现的镜头数图像化的结果，具体数字参见表2-1。 电影名称 打斗镜头 接吻镜头 电影类型 California Man 3 104 爱情片 He is Not Really into Dudes 2 100 爱情片 Beautiful Woman 1 81 爱情片 Kevin Longblade 101 10 动作片 Robo Slayer 3000 99 5 动作片 Amped Ⅱ 98 2 动作片 ？ 18 90 未知型 [表2-1 每部电影的镜头统计及电影评估类型] &emsp;&emsp;计算未知电影和样本集中其他电影的距离，如表2-2所示。我们暂且不关心如何计算得到这些距离值，后面会提供具体的计算方法。 电影名称 与未知电影的距离 California Man 20.5 He is Not Really into Dudes 18.7 Beautiful Woman 19.2 Kevin Longblade 115.3 Robo Slayer 3000 117.4 Amped Ⅱ 9118.9 [表2-2 已知电影与未知电影的距离] &emsp;&emsp;现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到k个距离最近的电影。假定k = 3，则三个最靠近的电影依次是He is Not Really into Dudes、Beautiful Woman、California Man。k-近邻算法按照距离最近的三部电影的类型，决定位置电影的类型，而这三部电影全是爱情片，所以我们判定未知电影为爱情片。 一般流程： 收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：此步骤不适用于k-近邻算法。 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续处理。 二、代码实现与详解：&emsp;&emsp;首先，创建名为kNN.py的Python模块。所有代码都已做出详细注释，所以不再赘述，如有疑问可以在下方评论哦~ 2.1 创建数据集和标签： 代码实现： 12345678910111213141516171819202122232425262728293031323334# -*- coding: UTF-8 -*-&quot;&quot;&quot;Created on Aug 18, 2017kNN: k Nearest NeighborsInput: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label@author: wordzzzz&quot;&quot;&quot;from numpy import *import operatordef createDataSet(): &quot;&quot;&quot; Function： 创建数据集和标签 Args： 无 Returns： group：创建的数据集 labels：创建的标签 &quot;&quot;&quot; #创建数据集 group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) #创建标签 labels = [&apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;] #返回创建的数据集和标签 return group, labels &emsp;&emsp;保存编写好的kNN.py模块，在Windows下打开命令提示符。如果不想在终端通过命令行一步一步敲到当前目录，可以直接在当前文件夹按住shift+右键，这个时候便会出现命令提示符的选项，单击后终端内直接显示当前文件夹。然后输入python，进入python编译开发环境。 输出结果：123456789&gt;&gt;&gt; import kNN&gt;&gt;&gt; group,labels = kNN.createDataSet()&gt;&gt;&gt; grouparray([[ 1. , 1.1], [ 1. , 1. ], [ 0. , 0. ], [ 0. , 0.1]])&gt;&gt;&gt; labels['A', 'A', 'B', 'B'] &emsp;&emsp;向量labels包含了每个数据点的标签信息，labels包含的元素个数等于group矩阵行数。这里我们将数据点(1, 1.1)定义为类A，数据点(0, 0.1)定义为类B。为了说明方便，例子中的数值是任意选择的，并没有给出轴标签，图2-2是带有标签信息的四个数据点。 2.2 实施kNN分类算法： 伪代码：&emsp;&emsp;对未知类别属性的数据集中的每个点依次执行以下操作： (1).计算已知类别数据集中的点与当前点之间的距离； (2).按照距离递增次序排序； (3).选取与当前点距离最小的k个点； (4).确定前k个点所在类别的出现频率； (5).返回前k个点出现频率最高的类别作为当前点的预测分类。 &emsp;&emsp;这里我们使用欧氏距离公式，计算两个向量点xA和xB之间的距离：$$ d = \sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2} $$ &emsp;&emsp;如果特征值有多个，那公式就变成了这个样子：$$ d = \sqrt{\sum_{i=0}^N{(xA_i-xB_i)^2}} $$ 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940def classify0(inX, dataSet, labels, k): &quot;&quot;&quot; Function： 创建数据集和标签 Args： inX：用于分类的输入向量 (1xN) dataSet：输入的训练样本集 (NxM) labels：标签向量 (1xM vector) k：用于比较的近邻数量 (should be an odd number) Returns： sortedClassCount[0][0]：分类结果 &quot;&quot;&quot; #dataSet.shape[0]：求dataSet矩阵的行数 #dataSet.shape[1]：求dataSet矩阵的列数 #dataSet.shape：元组形式输出矩阵行数、列数 dataSetSize = dataSet.shape[0] #tile(A, B)：将A重复B次，其中B可以是int类型也可以是元组类型 #这句话相当于向量inX与矩阵dataSet里面的每组数据做差 diffMat = tile(inX, (dataSetSize, 1)) - dataSet #对求差后的矩阵求平方 sqDiffMat = diffMat**2 #sqDiffMat.sum(axis=0)：对矩阵的每一列求和 #sqDiffMat.sum(axis=1)：对矩阵的每一行求和 #sqDiffMat.sum()：对整个矩阵求和 sqDistances = sqDiffMat.sum(axis=1) #求平方根 distances = sqDistances**0.5 #对上式结果进行排序 sortedDistIndicies = distances.argsort() #创建字典 classCount = &#123;&#125; #给字典赋值 for i in range(k): #字典的key voteIlabel = labels[sortedDistIndicies[i]] #classCount.get(voteIlabel,0)：如果字典键的值中有voteIlabel，则返回0（第二个参数的值） classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #对classCount进行排序，sroted、items以及itermgetter随后讲解@1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) #返回分类结果 return sortedClassCount[0][0] &emsp;&emsp;保存编写好的kNN.py模块，此时如果你不重新加载模块，你的命令提示符里面已经加载过的模块是不会自动更新的。所以我们需要调用imp模块中的reload来重新加载新保存的模块。我们输入两个不同的例子[0.9, 0.9][0.1, 0.1]，得到相应的分类结果并输出。 输出结果：1234567&gt;&gt;&gt; from imp import reload&gt;&gt;&gt; reload(kNN)&gt;&gt;&gt; kNN.classify0([0.9,0.9], group, labels, 3)'A'&gt;&gt;&gt; kNN.classify0([0.1,0.1], group, labels, 3)'B' 三、主要区分函数：详解：1.sorted,sort以及argsort： http://blog.csdn.net/u011475210/article/details/77769245 http://blog.csdn.net/u011475210/article/details/77770751 2.items等： http://blog.csdn.net/u011475210/article/details/77770145 3.itemgetter等： http://blog.csdn.net/u011475210/article/details/77770772 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之十四：YOLO安装与优化加速]]></title>
    <url>%2F2017%2F10%2F14%2Ftx-14%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 编者: WordZzzz &emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 前言&emsp;&emsp;下周甲方要来查看项目进行，我着急忙慌的在刚刷完机的板子上编译YOLO，然而，webcom不好用······记性真是差的不行，赶紧打开markdown，把先前的笔记都整理出来。 &emsp;&emsp;本篇文章分为两个部分，第一部分是YOLO安装，第二部分是YOLO的优化加速。 YOLO安装&emsp;&emsp;YOLO官网：https://pjreddie.com/darknet/yolo/ &emsp;&emsp;不说废话，就是干。 1.获取源码： 12git clone https://github.com/pjreddie/darknetcd darknet 2.修改Makefile &emsp;&emsp;我们打开MakeFile文件： 1vim Makefile &emsp;&emsp;Makefile内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100GPU=0CUDNN=0OPENCV=0OPENMP=0DEBUG=0ARCH= -gencode arch=compute_20,code=[sm_20,sm_21] \ -gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=[sm_50,compute_50] \ -gencode arch=compute_52,code=[sm_52,compute_52]# This is what I use, uncomment if you know your arch and want to specify# ARCH= -gencode arch=compute_52,code=compute_52VPATH=./src/:./examplesSLIB=libdarknet.soALIB=libdarknet.aEXEC=darknetOBJDIR=./obj/CC=gccNVCC=nvcc AR=arARFLAGS=rcsOPTS=-OfastLDFLAGS= -lm -pthread COMMON= -Iinclude/ -Isrc/CFLAGS=-Wall -Wno-unknown-pragmas -Wfatal-errors -fPICifeq ($(OPENMP), 1) CFLAGS+= -fopenmpendififeq ($(DEBUG), 1) OPTS=-O0 -gendifCFLAGS+=$(OPTS)ifeq ($(OPENCV), 1) COMMON+= -DOPENCVCFLAGS+= -DOPENCVLDFLAGS+= `pkg-config --libs opencv` COMMON+= `pkg-config --cflags opencv` endififeq ($(GPU), 1) COMMON+= -DGPU -I/usr/local/cuda/include/CFLAGS+= -DGPULDFLAGS+= -L/usr/local/cuda/lib64 -lcuda -lcudart -lcublas -lcurandendififeq ($(CUDNN), 1) COMMON+= -DCUDNN CFLAGS+= -DCUDNNLDFLAGS+= -lcudnnendifOBJ=gemm.o utils.o cuda.o deconvolutional_layer.o convolutional_layer.o list.o image.o activations.o im2col.o col2im.o blas.o crop_layer.o dropout_layer.o maxpool_layer.o softmax_layer.o data.o matrix.o network.o connected_layer.o cost_layer.o parser.o option_list.o detection_layer.o route_layer.o box.o normalization_layer.o avgpool_layer.o layer.o local_layer.o shortcut_layer.o activation_layer.o rnn_layer.o gru_layer.o crnn_layer.o demo.o batchnorm_layer.o region_layer.o reorg_layer.o tree.o lstm_layer.oEXECOBJA=captcha.o lsd.o super.o voxel.o art.o tag.o cifar.o go.o rnn.o rnn_vid.o compare.o segmenter.o regressor.o classifier.o coco.o dice.o yolo.o detector.o writing.o nightmare.o swag.o darknet.o ifeq ($(GPU), 1) LDFLAGS+= -lstdc++ OBJ+=convolutional_kernels.o deconvolutional_kernels.o activation_kernels.o im2col_kernels.o col2im_kernels.o blas_kernels.o crop_layer_kernels.o dropout_layer_kernels.o maxpool_layer_kernels.o network_kernels.o avgpool_layer_kernels.oendifEXECOBJ = $(addprefix $(OBJDIR), $(EXECOBJA))OBJS = $(addprefix $(OBJDIR), $(OBJ))DEPS = $(wildcard src/*.h) Makefile include/darknet.h#all: obj backup results $(SLIB) $(ALIB) $(EXEC)all: obj results $(SLIB) $(ALIB) $(EXEC)$(EXEC): $(EXECOBJ) $(ALIB) $(CC) $(COMMON) $(CFLAGS) $^ -o $@ $(LDFLAGS) $(ALIB)$(ALIB): $(OBJS) $(AR) $(ARFLAGS) $@ $^$(SLIB): $(OBJS) $(CC) $(CFLAGS) -shared $^ -o $@ $(LDFLAGS)$(OBJDIR)%.o: %.c $(DEPS) $(CC) $(COMMON) $(CFLAGS) -c $&lt; -o $@$(OBJDIR)%.o: %.cu $(DEPS) $(NVCC) $(ARCH) $(COMMON) --compiler-options &quot;$(CFLAGS)&quot; -c $&lt; -o $@obj: mkdir -p objbackup: mkdir -p backupresults: mkdir -p results.PHONY: cleanclean: rm -rf $(OBJS) $(SLIB) $(ALIB) $(EXEC) $(EXECOBJ) &emsp;&emsp;我们只需要关注前几行： 1234567891011GPU=0CUDNN=0OPENCV=0OPENMP=0DEBUG=0ARCH= -gencode arch=compute_20,code=[sm_20,sm_21] \ -gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=[sm_50,compute_50] \ -gencode arch=compute_52,code=[sm_52,compute_52] &emsp;&emsp;前五行的这些类似于宏定义，在make的时候会导致某些程序功能的开启与关闭，0代表关闭，1代表开启。我直接把前四个都打开了。想用GPU，那么前两行就得打开；想用webcom等OpenCV实现的程序，那么就需要打开OPENCV；至于OPENCMP，我只知道它是用来实现多线程优化加速的，所以我干脆也打开了。 TX1计算能力是53，对应的配置： 1234567GPU=1CUDNN=1OPENCV=1OPENMP=1DEBUG=0ARCH= -gencode arch=compute_53,code=[sm_53,sm_53] TX1计算能力是53，对应的配置： 1234567GPU=1CUDNN=1OPENCV=1OPENMP=1DEBUG=0ARCH= -gencode arch=compute_62,code=[sm_62,sm_62] 3.保存Makefile之后，开始编译： 1make 4.下载预训练好的模型： 123wget https://pjreddie.com/media/files/yolo.weightswget https://pjreddie.com/media/files/tiny-yolo-voc.weightswget https://pjreddie.com/media/files/tiny-yolo.weights 5.测试： &emsp;&emsp;我直接用webcom来测试。注意，必须使用支持V4L2的摄像头，板载的摄像头是不支持的，当然，如果你在Makefile里面没打开Opencv，这里是会报错的。 COCO数据集训练的YOLO（干跑3帧左右）： 1./darknet detector demo cfg/coco.data cfg/yolo.cfg yolo.weights COCO数据集训练的TINY-YOLO（干跑15帧左右）： 1./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights COCO数据集训练的TINY-YOLO（干跑15帧左右）： 1./darknet detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg tiny-yolo-voc.weights 注：大家如果想看看不开GPU跑成什么样子，可以加入参数-nogpu。举个栗子： COCO数据集训练的TINY-YOLO（关掉GPU）： 1./darknet -nogpu detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg tiny-yolo-voc.weights 查看GPU使用情况： 1$ sudo ~/tegrastats YOLO的优化加速&emsp;&emsp;大家是不是不满足上面的帧率，别着急，WordZzzz带着你搞优化啊。正经说来，也不算优化，就是调调参数，让代码跑的快点。 修改网络模型输入图像尺寸大小&emsp;&emsp;YOLOv2做了很多优化，其中就有为了提高小物体检测准确率而增加的多尺度训练（这里说的不够专业，后面有时间了专门写篇讲解YOLO的文章）。 &emsp;&emsp;原来的YOLO网络使用固定的448 448的图片作为输入，现在加入anchor boxes后，输入变成了416 416。目前的网络只用到了卷积层和池化层，那么就可以进行动态调整（意思是可检测任意大小图片）。作者希望YOLOv2具有不同尺寸图片的鲁棒性，因此在训练的时候也考虑了这一点。 &emsp;&emsp;不同于固定输入网络的图片尺寸的方法，作者在几次迭代后就会微调网络。没经过10次训练（10 epoch），就会随机选择新的图片尺寸。YOLO网络使用的降采样参数为32，那么就使用32的倍数进行尺度池化{320,352，…，608}。最终最小的尺寸为320 320，最大的尺寸为608 608。接着按照输入尺寸调整网络进行训练。 &emsp;&emsp;这种机制使得网络可以更好地预测不同尺寸的图片，意味着同一个网络可以进行不同分辨率的检测任务，在小尺寸图片上YOLOv2运行更快，在速度和精度上达到了平衡。 &emsp;&emsp;所以，我们可以修改输入尺寸大小，来提高YOLO运行速度。 &emsp;&emsp;随便打开一个cfg下的cfg文件，如“tiny-yolo.cfg”,内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139[net]# Training# batch=64# subdivisions=2# Testingbatch=1subdivisions=1width=416height=416channels=3momentum=0.9decay=0.0005angle=0saturation = 1.5exposure = 1.5hue=.1learning_rate=0.001burn_in=1000max_batches = 500200policy=stepssteps=400000,450000scales=.1,.1[convolutional]batch_normalize=1filters=16size=3stride=1pad=1activation=leaky[maxpool]size=2stride=2[convolutional]batch_normalize=1filters=32size=3stride=1pad=1activation=leaky[maxpool]size=2stride=2[convolutional]batch_normalize=1filters=64size=3stride=1pad=1activation=leaky[maxpool]size=2stride=2[convolutional]batch_normalize=1filters=128size=3stride=1pad=1activation=leaky[maxpool]size=2stride=2[convolutional]batch_normalize=1filters=256size=3stride=1pad=1activation=leaky[maxpool]size=2stride=2[convolutional]batch_normalize=1filters=512size=3stride=1pad=1activation=leaky[maxpool]size=2stride=1[convolutional]batch_normalize=1filters=1024size=3stride=1pad=1activation=leaky###########[convolutional]batch_normalize=1size=3stride=1pad=1filters=512activation=leaky[convolutional]size=1stride=1pad=1filters=425activation=linear[region]anchors = 0.57273, 0.677385, 1.87446, 2.06253, 3.33843, 5.47434, 7.88282, 3.52778, 9.77052, 9.16828bias_match=1classes=80coords=4num=5softmax=1jitter=.2rescore=0object_scale=5noobject_scale=1class_scale=1coord_scale=1absolute=1thresh = .6random=1 &emsp;&emsp;同样的，我们只需要看前面几行就行，把width和height修改成最小尺度： 12width=288height=288 &emsp;&emsp;此时再次使用COCO数据集训练的TINY-YOLO进行测试，帧率可以提高到20左右： 1./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights 修改预览分辨率&emsp;&emsp;可以直接X掉预览窗口，这样，预览窗口减小后，速度也会提升，只不过有时候效果不明显。 &emsp;&emsp;当然，大家也可以修改源码然后重新编译。源码中预览窗口大小的代码在src/demo.c中的第279行。我把预览分辨率改成了1280 * 720，当然你还可以改的更小。改完之后重新编译。 123456789if(!prefix)&#123; cvNamedWindow(&quot;Demo&quot;, CV_WINDOW_NORMAL); if(fullscreen)&#123; cvSetWindowProperty(&quot;Demo&quot;, CV_WND_PROP_FULLSCREEN, CV_WINDOW_FULLSCREEN); &#125; else &#123; cvMoveWindow(&quot;Demo&quot;, 0, 0); cvResizeWindow(&quot;Demo&quot;, 1280, 720); &#125;&#125; 修改摄像头分辨率&emsp;&emsp;一开始就让摄像头采集到的分辨率低点，也是有效果的。 1./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights -w 640 -h 480 &emsp;&emsp;经过上述三步的优化之后，我用COCO数据集，帧率峰值都能到30（TX2，TX1慢5帧左右）。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之十三：使用OpenCV在图像上添加汉字]]></title>
    <url>%2F2017%2F10%2F13%2Ftx-13%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 编者: WordZzzz &emsp;&emsp;各位看客注意了，本章教程无关硬件平台，在ubuntu下具有通用性，别被标题赶跑了哦。我踩过的坑，您就不要再踩了，枪在手，跟我走。有问题欢迎评论区留言~ &emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 前言&emsp;&emsp;同样的，由于项目需要，WordZzzz最近尝试在TX1上实现使用Opencv将解析json后得到的信息添加到图片上，其中包括汉字。然而，事情并没我想象的那么简单，主要还是自己对编码格式这块不太熟悉。下面将分两部分进行介绍。 安装freetype&emsp;&emsp;首先我们要检查一下自己的系统下面有没有freetype这个软件包： 12$ pkg-config --cflags --libs freetype2-I/usr/include/freetype2 -lfreetype &emsp;&emsp;如果有上述第二行的打印信息，那么这部分可以跳过，如果没有，就需要按照下面的步骤进行安装了。 12345678910111213141516#打开终端，添加PPA源:$ sudo add-apt-repository ppa:no1wantdthisname/ppa$ freetype-ppa#安装freetype有两种方式：$ upgrade freetype#或者：$ sudo apt update &amp;&amp; sudo apt install libfreetype6#如果你想卸载，科一进行如下操作：$ sudo apt install ppa-purge &amp;&amp; sudo ppa-purge ppa:no1wantdthisname/ppa UTF-8与GBK的转换ubuntu下系统默认的各种编码格式都是UTF-8，我们想要系统支持GBK，想让程序支持GBK，需要进行如下操作，我采用的方案二。 方案一：iconv函数族&emsp;&emsp;iconv函数族的头文件是iconv.h,使用前需包含。 1#include &lt;iconv.h&gt; &emsp;&emsp;iconv函数族有三个函数,原型如下: (1) iconv_t iconv_open(const char tocode, const char fromcode);此函数说明将要进行哪两种编码的转换,tocode是目标编码,fromcode是原编码,该函数返回一个转换句柄,供以下两个函数使用。 (2) size_t iconv(iconv_t cd,char inbuf,size_t *inbytesleft,char outbuf,size_t *outbytesleft);此函数从inbuf中读取字符,转换后输出到outbuf中,inbytesleft用以记录还未转换的字符数,outbytesleft用以记录输出缓冲的剩余空间。 (3) int iconv_close(iconv_t cd);此函数用于关闭转换句柄,释放资源。 &emsp;&emsp;实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iconv.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; int code_convert(char *from_charset, char *to_charset, char *inbuf, size_t inlen, char *outbuf, size_t outlen) &#123; iconv_t cd; char **pin = &amp;inbuf; char **pout = &amp;outbuf; cd = iconv_open(to_charset, from_charset); if (cd == 0) return -1; memset(outbuf, 0, outlen); if (iconv(cd, pin, &amp;inlen, pout, &amp;outlen) == -1) return -1; iconv_close(cd); *pout = &apos;\0&apos;; return 0; &#125; int u2g(char *inbuf, size_t inlen, char *outbuf, size_t outlen) &#123; return code_convert(&quot;utf-8&quot;, &quot;gb2312&quot;, inbuf, inlen, outbuf, outlen); &#125; int g2u(char *inbuf, size_t inlen, char *outbuf, size_t outlen) &#123; return code_convert(&quot;gb2312&quot;, &quot;utf-8&quot;, inbuf, inlen, outbuf, outlen); &#125; int main(void) &#123; char *s = &quot;中国&quot;; int fd = open(&quot;test.txt&quot;, O_RDWR|O_CREAT, S_IRUSR | S_IWUSR); char buf[10]; u2g(s, strlen(s), buf, sizeof(buf)); write(fd, buf, strlen(buf)); close(fd); fd = open(&quot;test.txt2&quot;, O_RDWR|O_CREAT, S_IRUSR | S_IWUSR); char buf2[10]; g2u(buf, strlen(buf), buf2, sizeof(buf2)); write(fd, buf2, strlen(buf2)); close(fd); return 1; &#125; 方案二：使用mbstowcs和wcstombs&emsp;&emsp;mbstowcs将多字节编码转换为宽字节编码；wcstombs将宽字节编码转换为多字节编码注意，需要系统编码的支持，可以通过locale -a 查看系统支持的。若不支持zh_CN.gbk, 需要安装，在ubuntu上的安装步骤如下： &emsp;&emsp;编辑配置文件： 1$sudo vim /var/lib/locales/supported.d/zh-hans &emsp;&emsp;加入下面几行代码： 1234zh_CN.UTF-8 UTF-8zh_SG.UTF-8 UTF-8zh_CN.GBK GBKzh_CN.GB18030 GB18030 &emsp;&emsp;保存后更新： 1$ sudo locale-gen &emsp;&emsp;查看: 12345678$ locale -aCPOSIX···zh_CN.gb18030zh_CN.gbkzh_CN.utf8zh_SG.utf8 &emsp;&emsp;测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;locale.h&gt; /** * DESCRIPTION: 实现由utf8编码到gbk编码的转换 * * Input: gbkStr,转换后的字符串; srcStr,待转换的字符串; maxGbkStrlen, gbkStr的最 大长度 * Output: gbkStr * Returns: -1,fail;&gt;0,success * */ int utf82gbk(char *gbkStr, const char *srcStr, int maxGbkStrlen) &#123; if (NULL == srcStr) &#123; printf(&quot;Bad Parameter：srcStr\n&quot;); return -1; &#125; //首先先将utf8编码转换为unicode编码 if (NULL == setlocale(LC_ALL, &quot;zh_CN.utf8&quot;)) //设置转换为unicode前的码,当前为utf8编码 &#123; printf(&quot;Bad Parameter：zh_CN.utf8\n&quot;); return -1; &#125; int unicodeLen = mbstowcs(NULL, srcStr, 0); //计算转换后的长度 if (unicodeLen &lt;= 0) &#123; printf(&quot;Can not Transfer!!!\n&quot;); return -1; &#125; wchar_t *unicodeStr = (wchar_t *) calloc(sizeof(wchar_t), unicodeLen + 1); mbstowcs(unicodeStr, srcStr, strlen(srcStr)); //将utf8转换为unicode //将unicode编码转换为gbk编码 if (NULL == setlocale(LC_ALL, &quot;zh_CN.gbk&quot;)) //设置unicode转换后的码,当前为gbk &#123; printf(&quot;Bad Parameter：zh_CN.gbk\n&quot;); return -1; &#125; int gbkLen = wcstombs(NULL, unicodeStr, 0); //计算转换后的长度 if (gbkLen &lt;= 0) &#123; printf(&quot;Can not Transfer!!!\n&quot;); return -1; &#125; else if (gbkLen &gt;= maxGbkStrlen) //判断空间是否足够 &#123; printf(&quot;Dst Str memory not enough\n&quot;); return -1; &#125; wcstombs(gbkStr, unicodeStr, gbkLen); gbkStr[gbkLen] = 0; //添加结束符 free(unicodeStr); return gbkLen; &#125; int main(void) &#123; char *s = &quot;我爱WordZzzz&quot;; int fd = open(&quot;test.txt&quot;, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR); char buf[10]; utf82gbk(buf, s, sizeof(buf)); write(fd, buf, strlen(buf)); close(fd); return 1; &#125; OpenCV的中文支持&emsp;&emsp;OpenCV想要支持中文显示，需要添加额外的文件。网上参考的都是这两个文件，2007年的，历史悠久。 &emsp;&emsp;头文件CvxText.h： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#ifndef OPENCV_CVX_TEXT_2007_08_31_H#define OPENCV_CVX_TEXT_2007_08_31_H/*** \file CvxText.h* \brief OpenCV汉字输出接口** 实现了汉字输出功能。*/#include &lt;ft2build.h&gt;#include FT_FREETYPE_H#include&lt;opencv2/opencv.hpp&gt;/*** \class CvxText* \brief OpenCV中输出汉字** OpenCV中输出汉字。字库提取采用了开源的FreeFype库。由于FreeFype是* GPL版权发布的库，和OpenCV版权并不一致，因此目前还没有合并到OpenCV* 扩展库中。** 显示汉字的时候需要一个汉字字库文件，字库文件系统一般都自带了。* 这里采用的是一个开源的字库：“文泉驿正黑体”。** 关于&quot;OpenCV扩展库&quot;的细节请访问* http://code.google.com/p/opencv-extension-library/** 关于FreeType的细节请访问* http://www.freetype.org/*/class CvxText&#123; // 禁止copy CvxText&amp; operator=(const CvxText&amp;); //================================================================ //================================================================public: /** * 装载字库文件 */ CvxText(const char *freeType); virtual ~CvxText(); //================================================================ //================================================================ /** * 获取字体。目前有些参数尚不支持。 * * \param font 字体类型, 目前不支持 * \param size 字体大小/空白比例/间隔比例/旋转角度 * \param underline 下画线 * \param diaphaneity 透明度 * * \sa setFont, restoreFont */ void getFont(int *type, CvScalar *size = NULL, bool *underline = NULL, float *diaphaneity = NULL); /** * 设置字体。目前有些参数尚不支持。 * * \param font 字体类型, 目前不支持 * \param size 字体大小/空白比例/间隔比例/旋转角度 * \param underline 下画线 * \param diaphaneity 透明度 * * \sa getFont, restoreFont */ void setFont(int *type, CvScalar *size = NULL, bool *underline = NULL, float *diaphaneity = NULL); /** * 恢复原始的字体设置。 * * \sa getFont, setFont */ void restoreFont(); //================================================================ //================================================================ /** * 输出汉字(颜色默认为黑色)。遇到不能输出的字符将停止。 * * \param img 输出的影象 * \param text 文本内容 * \param pos 文本位置 * * \return 返回成功输出的字符长度，失败返回-1。 */ int putText(IplImage *img, const char *text, CvPoint pos); /** * 输出汉字(颜色默认为黑色)。遇到不能输出的字符将停止。 * * \param img 输出的影象 * \param text 文本内容 * \param pos 文本位置 * * \return 返回成功输出的字符长度，失败返回-1。 */ int putText(IplImage *img, const wchar_t *text, CvPoint pos); /** * 输出汉字。遇到不能输出的字符将停止。 * * \param img 输出的影象 * \param text 文本内容 * \param pos 文本位置 * \param color 文本颜色 * * \return 返回成功输出的字符长度，失败返回-1。 */ int putText(IplImage *img, const char *text, CvPoint pos, CvScalar color); /** * 输出汉字。遇到不能输出的字符将停止。 * * \param img 输出的影象 * \param text 文本内容 * \param pos 文本位置 * \param color 文本颜色 * * \return 返回成功输出的字符长度，失败返回-1。 */ int putText(IplImage *img, const wchar_t *text, CvPoint pos, CvScalar color); //================================================================ //================================================================private: // 输出当前字符, 更新m_pos位置 void putWChar(IplImage *img, wchar_t wc, CvPoint &amp;pos, CvScalar color); //================================================================ //================================================================private: FT_Library m_library; // 字库 FT_Face m_face; // 字体 //================================================================ //================================================================ // 默认的字体输出参数 int m_fontType; CvScalar m_fontSize; bool m_fontUnderline; float m_fontDiaphaneity; //================================================================ //================================================================&#125;;#endif // OPENCV_CVX_TEXT_2007_08_31_H &emsp;&emsp;源文件cvText.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217/* * cvText.cpp * * Created on: Sep 20, 2017 * Author: wordzzzz */#include &lt;wchar.h&gt;#include &lt;assert.h&gt;#include &lt;locale.h&gt;#include &lt;ctype.h&gt;#include &quot;CvxText.h&quot;//====================================================================//====================================================================// 打开字库CvxText::CvxText(const char *freeType)&#123; assert(freeType != NULL); // 打开字库文件, 创建一个字体 if (FT_Init_FreeType(&amp;m_library)) throw; if (FT_New_Face(m_library, freeType, 0, &amp;m_face)) throw; // 设置字体输出参数 restoreFont(); // 设置C语言的字符集环境 setlocale(LC_ALL, &quot;&quot;);&#125;// 释放FreeType资源CvxText::~CvxText()&#123; FT_Done_Face(m_face); FT_Done_FreeType(m_library);&#125;// 设置字体参数://// font - 字体类型, 目前不支持// size - 字体大小/空白比例/间隔比例/旋转角度// underline - 下画线// diaphaneity - 透明度void CvxText::getFont(int *type, CvScalar *size, bool *underline, float *diaphaneity)&#123; if (type) *type = m_fontType; if (size) *size = m_fontSize; if (underline) *underline = m_fontUnderline; if (diaphaneity) *diaphaneity = m_fontDiaphaneity;&#125;void CvxText::setFont(int *type, CvScalar *size, bool *underline, float *diaphaneity)&#123; // 参数合法性检查 if (type) &#123; if (type &gt;= 0) m_fontType = *type; &#125; if (size) &#123; m_fontSize.val[0] = fabs(size-&gt;val[0]); m_fontSize.val[1] = fabs(size-&gt;val[1]); m_fontSize.val[2] = fabs(size-&gt;val[2]); m_fontSize.val[3] = fabs(size-&gt;val[3]); &#125; if (underline) &#123; m_fontUnderline = *underline; &#125; if (diaphaneity) &#123; m_fontDiaphaneity = *diaphaneity; &#125; //FT_Set_Pixel_Sizes(m_face, (int)m_fontSize.val[0], 0);&#125;// 恢复原始的字体设置void CvxText::restoreFont()&#123; m_fontType = 0; // 字体类型(不支持) m_fontSize.val[0] = 20; // 字体大小 m_fontSize.val[1] = 0.5; // 空白字符大小比例 m_fontSize.val[2] = 0.1; // 间隔大小比例 m_fontSize.val[3] = 0; // 旋转角度(不支持) m_fontUnderline = false; // 下画线(不支持) m_fontDiaphaneity = 1.0; // 色彩比例(可产生透明效果) // 设置字符大小 FT_Set_Pixel_Sizes(m_face, (int)m_fontSize.val[0], 0);&#125;// 输出函数(颜色默认为黑色)int CvxText::putText(IplImage *img, const char *text, CvPoint pos)&#123; return putText(img, text, pos, CV_RGB(255, 255, 255));&#125;int CvxText::putText(IplImage *img, const wchar_t *text, CvPoint pos)&#123; return putText(img, text, pos, CV_RGB(255, 255, 255));&#125;//int CvxText::putText(IplImage *img, const char *text, CvPoint pos, CvScalar color)&#123; if (img == NULL) return -1; if (text == NULL) return -1; // int i; for (i = 0; text[i] != &apos;\0&apos;; ++i) &#123; wchar_t wc = text[i]; // 解析双字节符号 if (!isascii(wc)) mbtowc(&amp;wc, &amp;text[i++], 2); // 输出当前的字符 putWChar(img, wc, pos, color); &#125; return i;&#125;int CvxText::putText(IplImage *img, const wchar_t *text, CvPoint pos, CvScalar color)&#123; if (img == NULL) return -1; if (text == NULL) return -1; // int i; for (i = 0; text[i] != &apos;\0&apos;; ++i) &#123; // 输出当前的字符 putWChar(img, text[i], pos, color); &#125; return i;&#125;// 输出当前字符, 更新m_pos位置void CvxText::putWChar(IplImage *img, wchar_t wc, CvPoint &amp;pos, CvScalar color)&#123; // 根据unicode生成字体的二值位图 FT_UInt glyph_index = FT_Get_Char_Index(m_face, wc); FT_Load_Glyph(m_face, glyph_index, FT_LOAD_DEFAULT); FT_Render_Glyph(m_face-&gt;glyph, FT_RENDER_MODE_MONO); // FT_GlyphSlot slot = m_face-&gt;glyph; // 行列数 int rows = slot-&gt;bitmap.rows; int cols = slot-&gt;bitmap.width; // for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) &#123; int off = ((img-&gt;origin == 0) ? i : (rows - 1 - i)) * slot-&gt;bitmap.pitch + j / 8; if (slot-&gt;bitmap.buffer[off] &amp; (0xC0 &gt;&gt; (j % 8))) &#123; int r = (img-&gt;origin == 0) ? pos.y - (rows - 1 - i) : pos.y + i;; int c = pos.x + j; if (r &gt;= 0 &amp;&amp; r &lt; img-&gt;height &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; img-&gt;width) &#123; CvScalar scalar = cvGet2D(img, r, c); // 进行色彩融合 float p = m_fontDiaphaneity; for (int k = 0; k &lt; 4; ++k) &#123; scalar.val[k] = scalar.val[k] * (1 - p) + color.val[k] * p; &#125; cvSet2D(img, r, c, scalar); &#125; &#125; &#125; // end for &#125; // end for // 修改下一个字的输出位置 double space = m_fontSize.val[0] * m_fontSize.val[1]; double sep = m_fontSize.val[0] * m_fontSize.val[2]; pos.x += (int)((cols ? cols : space) + sep);&#125; &emsp;&emsp;测试代码： 12345678910111213141516171819202122#include &lt;opencv/highgui.h&gt; #include &lt;assert.h&gt; #include &quot;CvxText.h&quot; using namespace cv; int main(int argc, char *argv[]) &#123; // 打开一幅 IplImage *img = cvLoadImage(&quot;lena.jpg&quot;); // 输出汉字 &#123; CvxText text(&quot;simhei.ttf&quot;); // &quot;zenhei.ttf&quot;为黑体常规 const char *msg = &quot;在OpenCV中输出汉字！&quot;; float p = 0.5; text.setFont(NULL, NULL, NULL, &amp;p); // 透明处理 text.putText(img, msg, cvPoint(100, 150), CV_RGB(255, 0, 0)); &#125; // 定义窗口，并显示影象 cvShowImage(&quot;test&quot;, img); cvWaitKey(-1); cvReleaseImage(&amp;img); return 0; &#125; &emsp;&emsp;代码里面的simhei.tff是字体名称，需要拷贝到你程序的执行目录下，当然也可以直接在代码中写字体的路径。window下一般都有这个字体，ubuntu的话，来windows下拷贝一下就好，windows的的字体目录：C:\Windows\Fonts。 敲重点&emsp;&emsp;如果你的代码的编码格式本身就是GBK，那么你就不需要UTF-8转GBK这个过程，即第二个部分就可以略过；但是，如果你进行第三部分的时候，发现部分汉字能显示，部分不能显示，那就是编码问题，需要调用第二部分的UTF-8转GBK的函数。/font&gt; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之十二：libcurl、RapidJSON安装]]></title>
    <url>%2F2017%2F10%2F12%2Ftx-12%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 编者: WordZzzz &emsp;&emsp;各位看客注意了，本章教程无关硬件平台，在ubuntu下具有通用性，别被标题赶跑了哦。我踩过的坑，您就不要再踩了，枪在手，跟我走。有问题欢迎评论区留言~ &emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 前言&emsp;&emsp;由于项目需要，WordZzzz最近尝试在TX1上解析服务器端传回json信息。先用Python3进行了测试，Python作为一门脚本语言，用来做测试简直棒极了。但是，我们最终还是要把代码移植到linux C上来进行实现。 &emsp;&emsp;虽说大家能看到这篇文章一般都是想直接解决问题的，但是我还是在此啰嗦几句，做个小小的科普。 &emsp;&emsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 JSON建构于两种结构： “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。 再详细点的话，就请进入传送门吧：http://www.json.org/json-zh.html。 &emsp;&emsp;用c在linux下实现json解析，需要两个工具，一个是可以实现http通信的工具，这里WordZzzz用的是libcurl（当然也可以用curl或者wget来模拟http的post和get）；另一个是可以解析json信息的工具，这里WordZzzz用的是腾讯开源的RapidJSON（当然大家也可以尝试json-c等）。 libcurl简介 cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。 libcurl支持的平台有Solaris、NetBSD、FreeBSD、OpenBSD、Darwin、HP-UX、IRIX、AIX、Tru64、Linux、UnixWare、HURD、Windows、Symbian、Amiga、OS/2、BeOS、Mac OS X、Ultrix、QNX、BlackBerry Tablet OS、OpenVMS、RISC OS、Novell NetWare、DOS等。 想要了解更多信息，官网传送门：https://curl.haxx.se/ 安装1.下载libcurl源码： 1$ git clone https://github.com/curl/curl.git 2.配置： 12$ ./buidconf$ ./configure --enable-debug &emsp;&emsp;第一步用于生成configure配置文件，第二步进行配置。可以./configure –help查看其他可选参数。我是默认安装openssl的，所以没有出现找不到openssl库的问题。如果遇到了就装一个，选择默认安装省事，自己指定安装目录比较麻烦。具体查看工程目录下的README。 3.编译&amp;安装： &emsp;&emsp;默认库文件安装在/usr/local/lib 头文件安装在/usr/local/include —&gt;安装要root权限 12$ make$ sudo make install 4.测试代码：&emsp;&emsp;接下来写个测试代码来使用libcurl库(此测试代码下载指定URL的页面)。&emsp;&emsp;测试代码摘自网络，如下：123456789101112131415161718192021222324252627282930313233343536373839404142// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能 #include &lt;stdio.h&gt;; #include &lt;stdlib.h&gt;; #include &lt;unistd.h&gt;; #include &lt;curl/curl.h&gt;; #include &lt;curl/types.h&gt;; #include &lt;curl/easy.h&gt;; FILE *fp; //定义FILE类型指针 //这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的 //完成数据保存功能 size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream) &#123; int written = fwrite(ptr, size, nmemb, (FILE *)fp); return written; &#125; int main(int argc, char *argv[]) &#123; CURL *curl; if (argc != 3) &#123; fprintf(stderr, &quot;usage: %s url filename\n&quot;, argv[0]); exit(-1); &#125; curl_global_init(CURL_GLOBAL_ALL); curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, argv[1]); if((fp = fopen(argv[2],&quot;w&quot;)) == NULL) &#123; curl_easy_cleanup(curl); exit(1); &#125; //CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理 curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_perform(curl); curl_easy_cleanup(curl); exit(0); &#125; 5.查看库链接信息： 12$ pkg-config --cflags --libs libcurl-I/usr/local/include -L/usr/local/lib -lcurl &emsp;&emsp;返回信息如上，其中-I后面的是头文件路径，-L后面的是链接库路径，链接库名称为curl。 6.编译测试代码： &emsp;&emsp;可以直接用nsight进行配置（详情参考我之前的nsight基础教程：http://blog.csdn.net/u011475210/article/details/72853170、nsight进阶教程：http://blog.csdn.net/u011475210/article/details/72860277），也可以直接手写gcc命令进行编译。 1$ gcc -L/usr/local/lib -o test test.c -lcurl 7.编译完成，运行程序： 1$ ./test &emsp;&emsp;程序会将百度首页下载下来，存为index.html。 RapidJSON简介&emsp;&emsp;RapidJSON 是一个 C++ 的 JSON 解析器及生成器。它的灵感来自 RapidXml。 RapidJSON 小而全。它同时支持 SAX 和 DOM 风格的 API。SAX 解析器只有约 500 行代码。 RapidJSON 快。它的性能可与 strlen() 相比。可支持 SSE2/SSE4.2 加速。 RapidJSON 独立。它不依赖于 BOOST 等外部库。它甚至不依赖于 STL。 RapidJSON 对内存友好。在大部分 32/64 位机器上，每个 JSON 值只占 16 字节（除字符串外）。它预设使用一个快速的内存分配器，令分析器可以紧凑地分配内存。 RapidJSON 对 Unicode 友好。它支持 UTF-8、UTF-16、UTF-32 (大端序／小端序)，并内部支持这些编码的检测、校验及转码。例如，RapidJSON 可以在分析一个 UTF-8 文件至 DOM 时，把当中的 JSON 字符串转码至 UTF-16。它也支持代理对（surrogate pair）及 “\u0000”（空字符）。 想要了解更多信息，官网传送门：http://rapidjson.org/zh-cn/ 安装1.cmake：&emsp;&emsp;采用cmake方式进行安装，所以cmake命令得有。 1$ sudo apt-get install cmake 2.下载源码： 1$ git clone https://github.com/Tencent/rapidjson.git 3.编译&amp;安装： 12345$ cd rapidjson/$ mkdir build$ cd build$ cmake ..$ sudo make install 4.查看库链接信息： 12$ pkg-config --cflags --libs RapidJSON-I/usr/local/include &emsp;&emsp;可以发现只有头文件信息，我们只需要调用头文件而不需要链接库，所以很方便。 5.官方例程： 12345678910111213141516171819202122// rapidjson/example/simpledom/simpledom.cpp`#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/writer.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &lt;iostream&gt;using namespace rapidjson;int main() &#123; // 1. 把 JSON 解析至 DOM。 const char* json = &quot;&#123;\&quot;project\&quot;:\&quot;rapidjson\&quot;,\&quot;stars\&quot;:10&#125;&quot;; Document d; d.Parse(json); // 2. 利用 DOM 作出修改。 Value&amp; s = d[&quot;stars&quot;]; s.SetInt(s.GetInt() + 1); // 3. 把 DOM 转换（stringify）成 JSON。 StringBuffer buffer; Writer&lt;StringBuffer&gt; writer(buffer); d.Accept(writer); // Output &#123;&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11&#125; std::cout &lt;&lt; buffer.GetString() &lt;&lt; std::endl; return 0;&#125; &emsp;&emsp;注意此例子并没有处理潜在错误。 6.编译例程： 1$ g++ -o simpledom simpledom.cpp 7.运行： 1$ ./simpledom &emsp;&emsp;图解过程： &emsp;&emsp;输出结果： 1&#123;&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>libcurl</tag>
        <tag>RapidJSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之十一：TCP IP文件传输]]></title>
    <url>%2F2017%2F10%2F11%2Ftx-11%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面：本篇博文设计的内容是TCP/IP文件传输，只是简单的实现文档、图片等二进制文件的传输，并将大包进行分包发送，不涉及select等机制。 一、服务端程序： 12345678910111213141516171819202122232425/* * common.h * * Created on: Aug 11, 2017 * Author: wordzzzz */#ifndef COMMON_H_#define COMMON_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 6000#define LISTENQ 20#define BUFFSIZE 4096#define FILE_NAME_MAX_SIZE 512#endif /* COMMON_H_ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* * fileserver.c * * Created on: Aug 11, 2017 * Author: wordzzzz */#include &quot;common.h&quot;int main(int argc, char **argv[])&#123; //Create socket int sockfd,connfd; struct sockaddr_in svraddr,clientaddr; bzero(&amp;svraddr,sizeof(svraddr)); bzero(&amp;clientaddr,sizeof(clientaddr)); svraddr.sin_family=AF_INET; svraddr.sin_addr.s_addr=htonl(INADDR_ANY); svraddr.sin_port=htons(PORT); sockfd=socket(AF_INET,SOCK_STREAM,0); if(sockfd&lt;0) &#123; perror(&quot;socket&quot;); exit(1); &#125; //bind if(bind(sockfd,(struct sockaddr*)&amp;svraddr,sizeof(svraddr))&lt;0) &#123; perror(&quot;bind&quot;); exit(1); &#125; //listen if(listen(sockfd,LISTENQ)&lt;0) &#123; perror(&quot;listen&quot;); exit(1); &#125; while(1) &#123; socklen_t clientaddrlen=sizeof(clientaddr); //accept connfd=accept(sockfd,(struct sockaddr*)&amp;clientaddr,&amp;clientaddrlen); if(connfd&lt;0) &#123; perror(&quot;connect&quot;); exit(1); &#125; //recv file imformation char buff[BUFFSIZE]; char filename[FILE_NAME_MAX_SIZE]; int count; bzero(buff,BUFFSIZE); count=recv(connfd,buff,BUFFSIZE,0); if(count&lt;0) &#123; perror(&quot;recv&quot;); exit(1); &#125; strncpy(filename,buff,strlen(buff)&gt;FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:strlen(buff)); printf(&quot;Preparing recv file : %s\n&quot;,filename); //recv file FILE *fd=fopen(filename,&quot;wb+&quot;); if(NULL==fd) &#123; perror(&quot;open&quot;); exit(1); &#125; bzero(buff,BUFFSIZE); int length=0; while(length=recv(connfd,buff,BUFFSIZE,0)) &#123; if(length&lt;0) &#123; perror(&quot;recv&quot;); exit(1); &#125; int writelen=fwrite(buff,sizeof(char),length,fd); if(writelen&lt;length) &#123; perror(&quot;write&quot;); exit(1); &#125; bzero(buff,BUFFSIZE); &#125; printf(&quot;Receieved file:%s finished!\n&quot;,filename); fclose(fd); close(connfd); &#125; close(sockfd); return 0;&#125; 二、客户端程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * fileclient.c * * Created on: Aug 11, 2017 * Author: wordzzzz */#include &quot;common.h&quot;int main(int argc, char **argv[])&#123; int clientfd; if(argc!=3) &#123; fprintf(stderr,&quot;Usage:./fileclient &lt;IP_Address&gt; &lt;filename&gt;\n&quot;); exit(1); &#125; //Input the file name char filename[FILE_NAME_MAX_SIZE]; bzero(filename,FILE_NAME_MAX_SIZE); strcpy(filename, argv[2]); struct sockaddr_in clientaddr; bzero(&amp;clientaddr,sizeof(clientaddr)); clientaddr.sin_family=AF_INET; clientaddr.sin_addr.s_addr=htons(INADDR_ANY); clientaddr.sin_port=htons(0); clientfd=socket(AF_INET,SOCK_STREAM,0); if(clientfd&lt;0) &#123; perror(&quot;socket&quot;); exit(1); &#125; //bind if(bind(clientfd,(struct sockaddr*)&amp;clientaddr,sizeof(clientaddr))&lt;0) &#123; perror(&quot;bind&quot;); exit(1); &#125; struct sockaddr_in svraddr; bzero(&amp;svraddr,sizeof(svraddr)); if(inet_aton(argv[1],&amp;svraddr.sin_addr)==0) &#123; perror(&quot;inet_aton&quot;); exit(1); &#125; svraddr.sin_family=AF_INET; svraddr.sin_port=htons(PORT); socklen_t svraddrlen=sizeof(svraddr); if(connect(clientfd,(struct sockaddr*)&amp;svraddr,svraddrlen)&lt;0) &#123; perror(&quot;connect&quot;); exit(1); &#125; //send file imformation char buff[BUFFSIZE]; int count; bzero(buff,BUFFSIZE); strncpy(buff,filename,strlen(filename)&gt;FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:strlen(filename)); count=send(clientfd,buff,BUFFSIZE,0); if(count&lt;0) &#123; perror(&quot;Send file information&quot;); exit(1); &#125; //read file FILE *fd=fopen(filename,&quot;rb&quot;); if(fd==NULL) &#123; printf(&quot;File :%s not found!\n&quot;,filename); &#125; else &#123; bzero(buff,BUFFSIZE); int file_block_length=0; while((file_block_length=fread(buff,sizeof(char),BUFFSIZE,fd))&gt;0) &#123; printf(&quot;file_block_length:%d\n&quot;,file_block_length); if(send(clientfd,buff,file_block_length,0)&lt;0) &#123; perror(&quot;Send&quot;); exit(1); &#125; bzero(buff,BUFFSIZE); &#125; fclose(fd); printf(&quot;Transfer file finished !\n&quot;); &#125; close(clientfd); return 0;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>TCP IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之十：V4L2+OpenCV2.4.13实现预览、拍照功能]]></title>
    <url>%2F2017%2F10%2F10%2Ftx-10%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面：本篇博文主要用来讲解上篇博文中关于V4L2框架的程序部分，并在其基础上实现预览和拍照功能的实现.其中，预览分辨率640480，用键盘检测来改变标志位，当标志位改变时进行拍照，拍照分辨率19201080，随后自动切换回预览模式，肉眼基本看不出切换卡顿。 一、V4L2框架：V4L2程序是基于标准的V4L2框架来写的，大部分程序注释都已给出，如果还有什么不清楚的地方，可以评论、私信或自行查阅V4L2开发手册。 下图是标准V4L2程序流程图。 博客中的程序，在标准V4L2程序的基础上进一步进行了封装，主要是为了实现拍照与预览模式的切换。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * v4l2cap.h * * Created on: Jul 26, 2017 * Author: wordzzzz */#ifndef V4L2CAP_H_#define V4L2CAP_H_#include &quot;include.h&quot;#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))#define TRUE 1#define FALSE 0class V4L2Capture &#123;public: V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap); virtual ~V4L2Capture(); int openDevice(); int closeDevice(); int initDevice(); int initDeviceCap(); int startCapture(); int stopCapture(); int freeBuffers(); int getFrame(void **,size_t *); int backFrame(); int pre2cap(); int cap2pre(); int preBegin(); int preEnd(); int initBuffers(); struct cam_buffer &#123; void* start; unsigned int length; &#125;; char *devName; int widthCap; int heightCap; int width; int height; int fd_cam; cam_buffer *buffers; unsigned int n_buffers; int frameIndex;&#125;;#endif /* V4L2CAP_H_ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380/* * v4l2cap.cpp * * Created on: Jul 26, 2017 * Author: wordzzzz */#include &quot;v4l2cap.h&quot;V4L2Capture::V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap) &#123; // TODO Auto-generated constructor stub this-&gt;devName = devName; this-&gt;fd_cam = -1; this-&gt;buffers = NULL; this-&gt;n_buffers = 0; this-&gt;frameIndex = -1; this-&gt;width=width; this-&gt;height=height; this-&gt;widthCap=width_cap; this-&gt;heightCap=height_cap;&#125;V4L2Capture::~V4L2Capture() &#123; // TODO Auto-generated destructor stub&#125;/**********打开设备**********/int V4L2Capture::openDevice() &#123; /*设备的打开*/ printf(&quot;video dev : %s\n&quot;, devName); fd_cam = open(devName, O_RDWR); if (fd_cam &lt; 0) &#123; perror(&quot;Can&apos;t open video device&quot;); &#125; return TRUE;&#125;/**********关闭设备**********/int V4L2Capture::closeDevice() &#123; if (fd_cam &gt; 0) &#123; int ret = 0; if ((ret = close(fd_cam)) &lt; 0) &#123; perror(&quot;Can&apos;t close video device&quot;); &#125; return TRUE; &#125; else &#123; return FALSE; &#125;&#125;/**********初始化设备（预览模式）**********/int V4L2Capture::initDevice() &#123; int ret; struct v4l2_capability cam_cap; //显示设备信息 struct v4l2_cropcap cam_cropcap; //设置摄像头的捕捉能力 struct v4l2_fmtdesc cam_fmtdesc; //查询所有支持的格式：VIDIOC_ENUM_FMT struct v4l2_crop cam_crop; //图像的缩放 struct v4l2_format cam_format; //设置摄像头的视频制式、帧格式等 /* 使用IOCTL命令VIDIOC_QUERYCAP，获取摄像头的基本信息*/ ret = ioctl(fd_cam, VIDIOC_QUERYCAP, &amp;cam_cap); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get device information: VIDIOCGCAP&quot;); &#125; printf( &quot;Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\n&quot;, cam_cap.driver, cam_cap.card, cam_cap.bus_info, (cam_cap.version &gt;&gt; 16) &amp; 0XFF, (cam_cap.version &gt;&gt; 8) &amp; 0XFF, cam_cap.version &amp; 0XFF); /* 使用IOCTL命令VIDIOC_ENUM_FMT，获取摄像头所有支持的格式*/ cam_fmtdesc.index = 0; cam_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; printf(&quot;Support format:\n&quot;); while (ioctl(fd_cam, VIDIOC_ENUM_FMT, &amp;cam_fmtdesc) != -1) &#123; printf(&quot;\t%d.%s\n&quot;, cam_fmtdesc.index + 1, cam_fmtdesc.description); cam_fmtdesc.index++; &#125; /* 使用IOCTL命令VIDIOC_CROPCAP，获取摄像头的捕捉能力*/ cam_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (0 == ioctl(fd_cam, VIDIOC_CROPCAP, &amp;cam_cropcap)) &#123; printf(&quot;Default rec:\n\tleft:%d\n\ttop:%d\n\twidth:%d\n\theight:%d\n&quot;, cam_cropcap.defrect.left, cam_cropcap.defrect.top, cam_cropcap.defrect.width, cam_cropcap.defrect.height); /* 使用IOCTL命令VIDIOC_S_CROP，获取摄像头的窗口取景参数*/ cam_crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_crop.c = cam_cropcap.defrect; //默认取景窗口大小 if (-1 == ioctl(fd_cam, VIDIOC_S_CROP, &amp;cam_crop)) &#123; //printf(&quot;Can&apos;t set crop para\n&quot;); &#125; &#125; else &#123; printf(&quot;Can&apos;t set cropcap para\n&quot;); &#125; /* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_format.fmt.pix.width = width; cam_format.fmt.pix.height = height; cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //要和摄像头支持的类型对应 cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED; ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t set frame information&quot;); &#125; /* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get frame information&quot;); &#125; printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;, cam_format.fmt.pix.width, cam_format.fmt.pix.height); return TRUE;&#125;/**********初始化设备（拍照模式）**********/int V4L2Capture::initDeviceCap() &#123; int ret; struct v4l2_format cam_format; //设置摄像头的视频制式、帧格式等 /* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_format.fmt.pix.width = widthCap; cam_format.fmt.pix.height = heightCap; cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //要和摄像头支持的类型对应 cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED; ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t set frame information&quot;); &#125; /* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get frame information&quot;); &#125; printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;, cam_format.fmt.pix.width, cam_format.fmt.pix.height); return TRUE;&#125;/**********申请缓存**********/int V4L2Capture::initBuffers() &#123; int ret; /* 使用IOCTL命令VIDIOC_REQBUFS，申请帧缓冲*/ struct v4l2_requestbuffers req; CLEAR(req); req.count = 4; req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; req.memory = V4L2_MEMORY_MMAP; ret = ioctl(fd_cam, VIDIOC_REQBUFS, &amp;req); if (ret &lt; 0) &#123; perror(&quot;Request frame buffers failed&quot;); &#125; if (req.count &lt; 2) &#123; perror(&quot;Request frame buffers while insufficient buffer memory&quot;); &#125; buffers = (struct cam_buffer*) calloc(req.count, sizeof(*buffers)); if (!buffers) &#123; perror(&quot;Out of memory&quot;); &#125; for (n_buffers = 0; n_buffers &lt; req.count; n_buffers++) &#123; struct v4l2_buffer buf; CLEAR(buf); // 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小 buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffers; ret = ioctl(fd_cam, VIDIOC_QUERYBUF, &amp;buf); if (ret &lt; 0) &#123; printf(&quot;VIDIOC_QUERYBUF %d failed\n&quot;, n_buffers); return FALSE; &#125; buffers[n_buffers].length = buf.length; //printf(&quot;buf.length= %d\n&quot;,buf.length); // 映射内存 buffers[n_buffers].start = mmap( NULL, // start anywhere buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_cam, buf.m.offset); if (MAP_FAILED == buffers[n_buffers].start) &#123; printf(&quot;mmap buffer%d failed\n&quot;, n_buffers); return FALSE; &#125; &#125; return TRUE;&#125;/**********释放缓存**********/int V4L2Capture::freeBuffers() &#123; unsigned int i; for (i = 0; i &lt; n_buffers; ++i) &#123; if (-1 == munmap(buffers[i].start, buffers[i].length)) &#123; printf(&quot;munmap buffer%d failed\n&quot;, i); return FALSE; &#125; &#125; free(buffers); return TRUE;&#125;/**********开始采集**********/int V4L2Capture::startCapture() &#123; unsigned int i; for (i = 0; i &lt; n_buffers; i++) &#123; struct v4l2_buffer buf; CLEAR(buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = i; if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;buf)) &#123; printf(&quot;VIDIOC_QBUF buffer%d failed\n&quot;, i); return FALSE; &#125; &#125; enum v4l2_buf_type type; type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (-1 == ioctl(fd_cam, VIDIOC_STREAMON, &amp;type)) &#123; printf(&quot;VIDIOC_STREAMON error&quot;); return FALSE; &#125; return TRUE;&#125;/**********停止采集**********/int V4L2Capture::stopCapture() &#123; enum v4l2_buf_type type; type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (-1 == ioctl(fd_cam, VIDIOC_STREAMOFF, &amp;type)) &#123; printf(&quot;VIDIOC_STREAMOFF error\n&quot;); return FALSE; &#125; return TRUE;&#125;/**********获取图像**********/int V4L2Capture::getFrame(void **frame_buf, size_t* len) &#123; struct v4l2_buffer queue_buf; CLEAR(queue_buf); queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; queue_buf.memory = V4L2_MEMORY_MMAP; if (-1 == ioctl(fd_cam, VIDIOC_DQBUF, &amp;queue_buf)) &#123; printf(&quot;VIDIOC_DQBUF error\n&quot;); return FALSE; &#125; //printf(&quot;queue_buf.index=%d\n&quot;,queue_buf.index); //pthread_rwlock_wrlock(&amp;rwlock); *frame_buf = buffers[queue_buf.index].start; *len = buffers[queue_buf.index].length; frameIndex = queue_buf.index; //pthread_rwlock_unlock(&amp;rwlock); return TRUE;&#125;/**********返回队列**********/int V4L2Capture::backFrame() &#123; if (frameIndex != -1) &#123; struct v4l2_buffer queue_buf; CLEAR(queue_buf); queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; queue_buf.memory = V4L2_MEMORY_MMAP; queue_buf.index = frameIndex; if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;queue_buf)) &#123; printf(&quot;VIDIOC_QBUF error\n&quot;); return FALSE; &#125; return TRUE; &#125; return FALSE;&#125;/**********预览切换至拍照**********/int V4L2Capture::pre2cap() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initDeviceCap() == FALSE)&#123; printf(&quot;InitDeviceCap fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; return TRUE;&#125;/**********拍照切换至预览**********/int V4L2Capture::cap2pre() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initDevice() == FALSE)&#123; printf(&quot;InitDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; return TRUE;&#125;/**********预览开启**********/int V4L2Capture::preBegin() &#123; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; printf(&quot;first~~\n&quot;); if(V4L2Capture::initDevice() == FALSE)&#123; printf(&quot;InitDevice fail~~\n&quot;); exit(1); &#125; printf(&quot;second~~\n&quot;); if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; printf(&quot;third~~\n&quot;); if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; printf(&quot;fourth~~\n&quot;); return TRUE;&#125;/**********预览结束**********/int V4L2Capture::preEnd() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; return TRUE;&#125; 二、键盘检测：主要实现的功能是通过模拟kbhit功能，实现在线程中完成对键盘的检测功能（检测到‘c’时标志位置1）。12345678910111213141516171819202122232425262728/* * pthread.h * * Created on: Jul 27, 2017 * Author: wordzzzz */#ifndef PTHREAD_H_#define PTHREAD_H_#include &quot;include.h&quot;static __inlineint tty_reset(void);static __inlineint tty_set(void);static __inlineint kbhit(void);void *thread(void *arg);static struct termios ori_attr, cur_attr;extern uchar flag;#endif /* PTHREAD_H_ */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * pthread.cpp * * Created on: Jul 27, 2017 * Author: wordzzzz */#include &quot;thread.h&quot;static __inlineint tty_reset(void)&#123; if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;ori_attr) != 0) return -1; return 0;&#125;static __inlineint tty_set(void)&#123; if ( tcgetattr(STDIN_FILENO, &amp;ori_attr) ) return -1; memcpy(&amp;cur_attr, &amp;ori_attr, sizeof(cur_attr) ); cur_attr.c_lflag &amp;= ~ICANON;// cur_attr.c_lflag |= ECHO; cur_attr.c_lflag &amp;= ~ECHO; cur_attr.c_cc[VMIN] = 1; cur_attr.c_cc[VTIME] = 0; if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;cur_attr) != 0) return -1; return 0;&#125;static __inlineint kbhit(void)&#123; fd_set rfds; struct timeval tv; int retval; /* Watch stdin (fd 0) to see when it has input. */ FD_ZERO(&amp;rfds); FD_SET(0, &amp;rfds); /* Wait up to five seconds. */ tv.tv_sec = 0; tv.tv_usec = 0; retval = select(1, &amp;rfds, NULL, NULL, &amp;tv); /* Don&apos;t rely on the value of tv now! */ if (retval == -1) &#123; perror(&quot;select()&quot;); return 0; &#125; else if (retval) return 1; /* FD_ISSET(0, &amp;rfds) will be true. */ else return 0; return 0;&#125;void *thread(void *arg)&#123; int tty_set_flag; tty_set_flag = tty_set(); while(1) &#123; if( kbhit() ) &#123; const int key = getchar(); printf(&quot;%c pressed\n&quot;, key); //检测到&apos;c&apos;则标志位置1 if(key == &apos;c&apos;) flag=1; //检测到&apos;q&apos;则退出程序 if(key == &apos;q&apos;) exit(0); break; &#125; else &#123;// fprintf(stderr, &quot;&lt;no key detected&gt;\n&quot;); &#125; &#125; if(tty_set_flag == 0) tty_reset(); return 0;&#125; 三、主函数：include.h里面包含我们所有用到的头文件。 12345678910111213141516171819202122232425262728293031323334353637/* * include.h * * Created on: Jul 26, 2017 * Author: wordzzzz */#ifndef INCLUDE_H_#define INCLUDE_H_extern &quot;C&quot; &#123;#include &lt;unistd.h&gt;#include &lt;error.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;termios.h&gt;#include &lt;linux/videodev2.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#125;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace std;#endif /* INCLUDE_H_ */ 主函数主要实现预览模式的开启、键盘检测线程开启，预览和拍照模式的切换等功能，总体程序比较简单。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* * main.cpp * * Created on: Jul 26, 2017 * Author: wordzzzz */#include &quot;include.h&quot;#include &quot;v4l2cap.h&quot;#include &quot;thread.h&quot;#define IMAGEWIDTH_CAP 1920 //拍照分辨率#define IMAGEHEIGHT_CAP 1080//拍照分辨率#define IMAGEWIDTH 640 //预览分辨率#define IMAGEHEIGHT 480 //预览分辨率#define TRUE 1#define FALSE 0uchar flag;int main()&#123; IplImage* img,* img_cap; CvMat cvmat,cvmat_cap; double t; flag=0; unsigned char *frame = NULL; unsigned long frameSize = 0; string videoDev=&quot;/dev/video1&quot;;//制定设备号 V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()), IMAGEWIDTH, IMAGEHEIGHT, IMAGEWIDTH_CAP, IMAGEHEIGHT_CAP); vcap-&gt;preBegin();//预览模式开启 cvNamedWindow(&quot;one&quot;,CV_WINDOW_AUTOSIZE);//创建显示窗口 pthread_t id; printf(&quot;Main thread id is %d \n&quot;,pthread_self()); if(!pthread_create(&amp;id,NULL,thread,NULL)) &#123; printf(&quot;succeed!\n&quot;); &#125; else &#123;printf(&quot;Fail to Create Thread&quot;); return -1; &#125; while(1)&#123; //如果flag为1，则抓取一张照片 if(flag == 1)&#123; vcap-&gt;pre2cap(); //预览模式切换至拍照模式 //这里多获取几次图像队列，以便得到更高的图像质量（刚打开设备时图像模糊） vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);vcap-&gt;backFrame(); vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);vcap-&gt;backFrame(); vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize); cvmat_cap = cvMat(IMAGEHEIGHT_CAP,IMAGEWIDTH_CAP,CV_8UC3,frame);//CV_8UC3 img_cap = cvDecodeImage(&amp;cvmat_cap,1);//OpenCV图像解码 if(!img_cap) printf(&quot;No img_cap\n&quot;); cvSaveImage(&quot;cap.jpg&quot;,img_cap); //保存图片 cvReleaseImage(&amp;img_cap); //释放img_cap vcap-&gt;backFrame(); //返回队列 vcap-&gt;cap2pre(); //拍照模式切换至预览模式 flag = 0; &#125; t = (double)cvGetTickCount(); vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize); cvmat = cvMat(IMAGEHEIGHT,IMAGEWIDTH,CV_8UC3,frame);//CV_8UC3 img = cvDecodeImage(&amp;cvmat,1); //OpenCV图像解码 if(!img) printf(&quot;No img\n&quot;); cvShowImage(&quot;one&quot;,img); //显示图片 cvReleaseImage(&amp;img); //释放img vcap-&gt;backFrame(); //返回队列 cvWaitKey(1); //没有这句话图像无法显示 t=(double)cvGetTickCount()-t; printf(&quot;used time is %gms\n&quot;,(t/(cvGetTickFrequency()*1000))); &#125; pthread_exit(0); //退出键盘检测线程 vcap-&gt;preEnd(); //预览模式结束 return 0;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>OpenCV</tag>
        <tag>V4L2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之九：USB摄像头MJPEG格式图像采集]]></title>
    <url>%2F2017%2F10%2F09%2Ftx-9%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面：NVIDIA Jetson TX1开发套件包括一个CSI接口的500W摄像头，其官方多媒体例程基于此摄像头详细介绍了图像采集与编解码的种种操作。整个多媒体例程是基于gstreamer框架来写的，如果大家只是想把摄像头用起来，大可不必研究gstreamer框架，直接看接口就行。 由于项目需求，考虑到接线问题，我们放弃了CSI接口的摄像头，转而采用USB摄像头。而且最新的官方例程已经给出了基于V4L2的USB摄像头图像采集与编码例程。（12_camera_v4l2_cuda_video_encode）。 本博客将介绍三种在TX1上实现USB摄像头图像采集与显示的方法，分别基于gstreamer、ffmpeg和V4L2来实现USB摄像头的图像实时采集与显示。博主在项目中实现拍照和预览模式切换，最终采用的是V4L2+OpenCV2.4.13的方案，因为博主对V4L2比较熟悉，而对于gstreamer和ffmpeg只接触到了皮毛，对其理解也不是很到位。 注意：博主所用的USB摄像头输出图像格式为mjpeg，所以所有的程序中都是以jpeg为例进行编写的，如果想改成YUYV格式的，只需要改一下format设置，并把相应的解码程序去掉即可。 一、Gstreamer： 博主只是直接把测试好的gstreamer命令行写入到程序中，并不能对数据流做更多的操作，在多次尝试无果后放弃······ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * main.cpp * * Created on: May 31, 2017 * Author: wordzzzz */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;errno.h&gt;using namespace std;int main(int argc, char **argv)&#123; //花括号内输入测试号的命令行即可 char cmd_cap[] = &#123;&quot;gst-launch-1.0 v4l2src device= /dev/video1 ! &apos;image/jpeg, width=640, height=480&apos; ! jpegdec ! xvimagesink -e &amp;&quot;&#125;; char *cmdstring = cmd_cap; if(*argv[1] == &apos;1&apos;) cmdstring = cmd_cap; int status; if(NULL == cmdstring) //如果cmdstring为空趁早闪退吧，尽管system()函数也能处理空指针 &#123; return 0; &#125; status = system(cmdstring); if(status &lt; 0) &#123; printf(&quot;cmd: %s\t error: %s&quot;, cmdstring, strerror(errno)); // 这里务必要把errno信息输出或 return 0; &#125; if(WIFEXITED(status)) &#123; printf(&quot;normal termination, exit status = %d\n&quot;, WEXITSTATUS(status)); //取得cmdstring执行结果 &#125; else if(WIFSIGNALED(status)) &#123; printf(&quot;abnormal termination,signal number =%d\n&quot;, WTERMSIG(status)); //如果cmdstring被信号中断，取得信号值 &#125; else if(WIFSTOPPED(status)) &#123; printf(&quot;process stopped, signal number =%d\n&quot;, WSTOPSIG(status)); //如果cmdstring被信号暂停执行，取得信号值 &#125;&#125; 二、Ffmpeg：ffmpeg程序参考雷神博客，并在其基础上进行修改，ffmpeg编解码+SDL多线程定时刷新显示，程序详解还是看雷神的吧，打开传送门：http://blog.csdn.net/leixiaohua1020/article/details/38868499 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/* * ffm_cap.cpp * * Created on: Jul 19, 2017 * Author: wordzzzz */#include &lt;stdio.h&gt;#define __STDC_CONSTANT_MACROS//Linux...#ifdef __cplusplusextern &quot;C&quot;&#123;#endif#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libavdevice/avdevice.h&gt;#include &lt;SDL/SDL.h&gt;#ifdef __cplusplus&#125;;#endif//Output YUV420P#define OUTPUT_YUV420P 0//&apos;1&apos; Use Dshow//&apos;0&apos; Use VFW#define USE_DSHOW 0//Refresh Event#define SFM_REFRESH_EVENT (SDL_USEREVENT + 1)#define SFM_BREAK_EVENT (SDL_USEREVENT + 2)int thread_exit=0;//SDL线程40ms刷新一次int sfp_refresh_thread(void *opaque)&#123; thread_exit=0; while (!thread_exit) &#123; SDL_Event event; event.type = SFM_REFRESH_EVENT; SDL_PushEvent(&amp;event); SDL_Delay(40); &#125; thread_exit=0; //Break SDL_Event event; event.type = SFM_BREAK_EVENT; SDL_PushEvent(&amp;event); return 0;&#125;int main(int argc, char* argv[])&#123; AVFormatContext *pFormatCtx; int i, videoindex; AVCodecContext *pCodecCtx; AVCodec *pCodec; av_register_all(); avformat_network_init(); pFormatCtx = avformat_alloc_context(); //Open File //char filepath[]=&quot;src01_480x272_22.h265&quot;; //avformat_open_input(&amp;pFormatCtx,filepath,NULL,NULL) //Register Device avdevice_register_all(); //Linux：参数设置 AVDictionary* options = NULL; av_dict_set(&amp;options, &quot;input_format&quot;, &quot;mjpeg&quot;, 0); //输入格式 av_dict_set(&amp;options, &quot;framerate&quot;, &quot;30&quot;, 0); //帧率 av_dict_set(&amp;options, &quot;video_size&quot;, &quot;1280x720&quot;, 0);//图像像素 AVInputFormat *ifmt=av_find_input_format(&quot;video4linux2&quot;); if(avformat_open_input(&amp;pFormatCtx,&quot;/dev/video1&quot;,ifmt,&amp;options)!=0)&#123; printf(&quot;Couldn&apos;t open input stream.\n&quot;); return -1; &#125; av_dict_free(&amp;options); if(avformat_find_stream_info(pFormatCtx,NULL)&lt;0) &#123; printf(&quot;Couldn&apos;t find stream information.\n&quot;); return -1; &#125; videoindex=-1; for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) &#123; videoindex=i; break; &#125; if(videoindex==-1) &#123; printf(&quot;Couldn&apos;t find a video stream.\n&quot;); return -1; &#125; pCodecCtx=pFormatCtx-&gt;streams[videoindex]-&gt;codec; pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id); if(pCodec==NULL) &#123; printf(&quot;Codec not found.\n&quot;); return -1; &#125; if(avcodec_open2(pCodecCtx, pCodec,NULL)&lt;0) &#123; printf(&quot;Could not open codec.\n&quot;); return -1; &#125; printf(&quot;pCodecCtx-&gt;codec_id %d\n&quot;, pCodecCtx-&gt;codec_id); printf(&quot;pCodecCtx-&gt;width %d\n&quot;, pCodecCtx-&gt;width); printf(&quot;pCodecCtx-&gt;height %d\n&quot;, pCodecCtx-&gt;height); printf(&quot;pCodecCtx-&gt;pix_fmt %d\n&quot;, pCodecCtx-&gt;pix_fmt); AVFrame *pFrame,*pFrameYUV; pFrame=av_frame_alloc(); pFrameYUV=av_frame_alloc(); //unsigned char *out_buffer=(unsigned char *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height)); //avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //SDL---------------------------- if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; printf( &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError()); return -1; &#125; int screen_w=0,screen_h=0; SDL_Surface *screen; screen_w = pCodecCtx-&gt;width; screen_h = pCodecCtx-&gt;height; screen = SDL_SetVideoMode(screen_w, screen_h, 0,0); if(!screen) &#123; printf(&quot;SDL: could not set video mode - exiting:%s\n&quot;,SDL_GetError()); return -1; &#125; SDL_Overlay *bmp; bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,SDL_YV12_OVERLAY, screen); SDL_Rect rect; rect.x = 0; rect.y = 0; rect.w = screen_w; rect.h = screen_h; //SDL End------------------------ int ret, got_picture; AVPacket *packet=(AVPacket *)av_malloc(sizeof(AVPacket));#if OUTPUT_YUV420P FILE *fp_yuv=fopen(&quot;output.yuv&quot;,&quot;wb+&quot;);#endif struct SwsContext *img_convert_ctx; img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUVJ420P, SWS_BICUBIC, NULL, NULL, NULL); //------------------------------ SDL_Thread *video_tid = SDL_CreateThread(sfp_refresh_thread,NULL); // SDL_WM_SetCaption(&quot;Simplest FFmpeg Read Camera&quot;,NULL); //Event Loop SDL_Event event; for (;;) &#123; //Wait SDL_WaitEvent(&amp;event); if(event.type==SFM_REFRESH_EVENT)&#123; //------------------------------ if(av_read_frame(pFormatCtx, packet)&gt;=0)&#123; printf(&quot;packet-&gt;stream_index = %d\n&quot;, packet-&gt;stream_index); if(packet-&gt;stream_index==videoindex)&#123; printf(&quot;videoindex = %d\n&quot;, videoindex); ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if(ret &lt; 0)&#123; printf(&quot;Decode Error.\n&quot;); return -1; &#125; if(got_picture)&#123; SDL_LockYUVOverlay(bmp); pFrameYUV-&gt;data[0]=bmp-&gt;pixels[0]; pFrameYUV-&gt;data[1]=bmp-&gt;pixels[2]; pFrameYUV-&gt;data[2]=bmp-&gt;pixels[1]; pFrameYUV-&gt;linesize[0]=bmp-&gt;pitches[0]; pFrameYUV-&gt;linesize[1]=bmp-&gt;pitches[2]; pFrameYUV-&gt;linesize[2]=bmp-&gt;pitches[1]; sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);#if OUTPUT_YUV420P int y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv); //Y fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv); //U fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv); //V#endif SDL_UnlockYUVOverlay(bmp); SDL_DisplayYUVOverlay(bmp, &amp;rect); &#125; &#125; av_free_packet(packet); &#125;else&#123; //Exit Thread thread_exit=1; &#125; &#125;else if(event.type==SDL_QUIT)&#123; thread_exit=1; &#125;else if(event.type==SFM_BREAK_EVENT)&#123; break; &#125; &#125; sws_freeContext(img_convert_ctx);#if OUTPUT_YUV420P fclose(fp_yuv);#endif SDL_Quit(); //av_free(out_buffer); av_free(pFrameYUV); avcodec_close(pCodecCtx); avformat_close_input(&amp;pFormatCtx); return 0;&#125; 三、V4L2+OpenCV2.4.13： 这里贴出自己的代码，其中V4L2各功能函数是按照标准的V4L2框架进行编写的。本篇博客只贴出摄像头图像采集程序代码，下一篇将针对拍照+预览程序进行代码讲解：12345678910111213141516171819202122232425262728293031323334353637/* * include.h * * Created on: Jul 26, 2017 * Author: wordzzzz */#ifndef INCLUDE_H_#define INCLUDE_H_extern &quot;C&quot; &#123;#include &lt;unistd.h&gt;#include &lt;error.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;termios.h&gt;#include &lt;linux/videodev2.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#125;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace std;#endif /* INCLUDE_H_ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380/* * v4l2cap.cpp * * Created on: Jul 26, 2017 * Author: wordzzzz */#include &quot;v4l2cap.h&quot;V4L2Capture::V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap) &#123; // TODO Auto-generated constructor stub this-&gt;devName = devName; this-&gt;fd_cam = -1; this-&gt;buffers = NULL; this-&gt;n_buffers = 0; this-&gt;frameIndex = -1; this-&gt;width=width; this-&gt;height=height; this-&gt;widthCap=width_cap; this-&gt;heightCap=height_cap;&#125;V4L2Capture::~V4L2Capture() &#123; // TODO Auto-generated destructor stub&#125;/**********打开设备**********/int V4L2Capture::openDevice() &#123; /*设备的打开*/ printf(&quot;video dev : %s\n&quot;, devName); fd_cam = open(devName, O_RDWR); if (fd_cam &lt; 0) &#123; perror(&quot;Can&apos;t open video device&quot;); &#125; return TRUE;&#125;/**********关闭设备**********/int V4L2Capture::closeDevice() &#123; if (fd_cam &gt; 0) &#123; int ret = 0; if ((ret = close(fd_cam)) &lt; 0) &#123; perror(&quot;Can&apos;t close video device&quot;); &#125; return TRUE; &#125; else &#123; return FALSE; &#125;&#125;/**********初始化设备（预览模式）**********/int V4L2Capture::initDevice() &#123; int ret; struct v4l2_capability cam_cap; //显示设备信息 struct v4l2_cropcap cam_cropcap; //设置摄像头的捕捉能力 struct v4l2_fmtdesc cam_fmtdesc; //查询所有支持的格式：VIDIOC_ENUM_FMT struct v4l2_crop cam_crop; //图像的缩放 struct v4l2_format cam_format; //设置摄像头的视频制式、帧格式等 /* 使用IOCTL命令VIDIOC_QUERYCAP，获取摄像头的基本信息*/ ret = ioctl(fd_cam, VIDIOC_QUERYCAP, &amp;cam_cap); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get device information: VIDIOCGCAP&quot;); &#125; printf( &quot;Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\n&quot;, cam_cap.driver, cam_cap.card, cam_cap.bus_info, (cam_cap.version &gt;&gt; 16) &amp; 0XFF, (cam_cap.version &gt;&gt; 8) &amp; 0XFF, cam_cap.version &amp; 0XFF); /* 使用IOCTL命令VIDIOC_ENUM_FMT，获取摄像头所有支持的格式*/ cam_fmtdesc.index = 0; cam_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; printf(&quot;Support format:\n&quot;); while (ioctl(fd_cam, VIDIOC_ENUM_FMT, &amp;cam_fmtdesc) != -1) &#123; printf(&quot;\t%d.%s\n&quot;, cam_fmtdesc.index + 1, cam_fmtdesc.description); cam_fmtdesc.index++; &#125; /* 使用IOCTL命令VIDIOC_CROPCAP，获取摄像头的捕捉能力*/ cam_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (0 == ioctl(fd_cam, VIDIOC_CROPCAP, &amp;cam_cropcap)) &#123; printf(&quot;Default rec:\n\tleft:%d\n\ttop:%d\n\twidth:%d\n\theight:%d\n&quot;, cam_cropcap.defrect.left, cam_cropcap.defrect.top, cam_cropcap.defrect.width, cam_cropcap.defrect.height); /* 使用IOCTL命令VIDIOC_S_CROP，获取摄像头的窗口取景参数*/ cam_crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_crop.c = cam_cropcap.defrect; //默认取景窗口大小 if (-1 == ioctl(fd_cam, VIDIOC_S_CROP, &amp;cam_crop)) &#123; //printf(&quot;Can&apos;t set crop para\n&quot;); &#125; &#125; else &#123; printf(&quot;Can&apos;t set cropcap para\n&quot;); &#125; /* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_format.fmt.pix.width = width; cam_format.fmt.pix.height = height; cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //要和摄像头支持的类型对应 cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED; ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t set frame information&quot;); &#125; /* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get frame information&quot;); &#125; printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;, cam_format.fmt.pix.width, cam_format.fmt.pix.height); return TRUE;&#125;/**********初始化设备（拍照模式）**********/int V4L2Capture::initDeviceCap() &#123; int ret; struct v4l2_format cam_format; //设置摄像头的视频制式、帧格式等 /* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam_format.fmt.pix.width = widthCap; cam_format.fmt.pix.height = heightCap; cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //要和摄像头支持的类型对应 cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED; ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t set frame information&quot;); &#125; /* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/ cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format); if (ret &lt; 0) &#123; perror(&quot;Can&apos;t get frame information&quot;); &#125; printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;, cam_format.fmt.pix.width, cam_format.fmt.pix.height); return TRUE;&#125;/**********申请缓存**********/int V4L2Capture::initBuffers() &#123; int ret; /* 使用IOCTL命令VIDIOC_REQBUFS，申请帧缓冲*/ struct v4l2_requestbuffers req; CLEAR(req); req.count = 4; req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; req.memory = V4L2_MEMORY_MMAP; ret = ioctl(fd_cam, VIDIOC_REQBUFS, &amp;req); if (ret &lt; 0) &#123; perror(&quot;Request frame buffers failed&quot;); &#125; if (req.count &lt; 2) &#123; perror(&quot;Request frame buffers while insufficient buffer memory&quot;); &#125; buffers = (struct cam_buffer*) calloc(req.count, sizeof(*buffers)); if (!buffers) &#123; perror(&quot;Out of memory&quot;); &#125; for (n_buffers = 0; n_buffers &lt; req.count; n_buffers++) &#123; struct v4l2_buffer buf; CLEAR(buf); // 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小 buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffers; ret = ioctl(fd_cam, VIDIOC_QUERYBUF, &amp;buf); if (ret &lt; 0) &#123; printf(&quot;VIDIOC_QUERYBUF %d failed\n&quot;, n_buffers); return FALSE; &#125; buffers[n_buffers].length = buf.length; //printf(&quot;buf.length= %d\n&quot;,buf.length); // 映射内存 buffers[n_buffers].start = mmap( NULL, // start anywhere buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_cam, buf.m.offset); if (MAP_FAILED == buffers[n_buffers].start) &#123; printf(&quot;mmap buffer%d failed\n&quot;, n_buffers); return FALSE; &#125; &#125; return TRUE;&#125;/**********释放缓存**********/int V4L2Capture::freeBuffers() &#123; unsigned int i; for (i = 0; i &lt; n_buffers; ++i) &#123; if (-1 == munmap(buffers[i].start, buffers[i].length)) &#123; printf(&quot;munmap buffer%d failed\n&quot;, i); return FALSE; &#125; &#125; free(buffers); return TRUE;&#125;/**********开始采集**********/int V4L2Capture::startCapture() &#123; unsigned int i; for (i = 0; i &lt; n_buffers; i++) &#123; struct v4l2_buffer buf; CLEAR(buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = i; if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;buf)) &#123; printf(&quot;VIDIOC_QBUF buffer%d failed\n&quot;, i); return FALSE; &#125; &#125; enum v4l2_buf_type type; type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (-1 == ioctl(fd_cam, VIDIOC_STREAMON, &amp;type)) &#123; printf(&quot;VIDIOC_STREAMON error&quot;); return FALSE; &#125; return TRUE;&#125;/**********停止采集**********/int V4L2Capture::stopCapture() &#123; enum v4l2_buf_type type; type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (-1 == ioctl(fd_cam, VIDIOC_STREAMOFF, &amp;type)) &#123; printf(&quot;VIDIOC_STREAMOFF error\n&quot;); return FALSE; &#125; return TRUE;&#125;/**********获取图像**********/int V4L2Capture::getFrame(void **frame_buf, size_t* len) &#123; struct v4l2_buffer queue_buf; CLEAR(queue_buf); queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; queue_buf.memory = V4L2_MEMORY_MMAP; if (-1 == ioctl(fd_cam, VIDIOC_DQBUF, &amp;queue_buf)) &#123; printf(&quot;VIDIOC_DQBUF error\n&quot;); return FALSE; &#125; //printf(&quot;queue_buf.index=%d\n&quot;,queue_buf.index); //pthread_rwlock_wrlock(&amp;rwlock); *frame_buf = buffers[queue_buf.index].start; *len = buffers[queue_buf.index].length; frameIndex = queue_buf.index; //pthread_rwlock_unlock(&amp;rwlock); return TRUE;&#125;/**********返回队列**********/int V4L2Capture::backFrame() &#123; if (frameIndex != -1) &#123; struct v4l2_buffer queue_buf; CLEAR(queue_buf); queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; queue_buf.memory = V4L2_MEMORY_MMAP; queue_buf.index = frameIndex; if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;queue_buf)) &#123; printf(&quot;VIDIOC_QBUF error\n&quot;); return FALSE; &#125; return TRUE; &#125; return FALSE;&#125;/**********预览切换至拍照**********/int V4L2Capture::pre2cap() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initDeviceCap() == FALSE)&#123; printf(&quot;InitDeviceCap fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; return TRUE;&#125;/**********拍照切换至预览**********/int V4L2Capture::cap2pre() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initDevice() == FALSE)&#123; printf(&quot;InitDevice fail~~\n&quot;); exit(1); &#125; if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; return TRUE;&#125;/**********预览开启**********/int V4L2Capture::preBegin() &#123; if(V4L2Capture::openDevice() == FALSE)&#123; printf(&quot;OpenDevice fail~~\n&quot;); exit(1); &#125; printf(&quot;first~~\n&quot;); if(V4L2Capture::initDevice() == FALSE)&#123; printf(&quot;InitDevice fail~~\n&quot;); exit(1); &#125; printf(&quot;second~~\n&quot;); if(V4L2Capture::initBuffers() == FALSE)&#123; printf(&quot;InitBuffers fail~~\n&quot;); exit(2); &#125; printf(&quot;third~~\n&quot;); if(V4L2Capture::startCapture() == FALSE)&#123; printf(&quot;StartCapture fail~~\n&quot;); exit(2); &#125; printf(&quot;fourth~~\n&quot;); return TRUE;&#125;/**********预览结束**********/int V4L2Capture::preEnd() &#123; if(V4L2Capture::stopCapture() == FALSE)&#123; printf(&quot;StopCapture fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::freeBuffers() == FALSE)&#123; printf(&quot;FreeBuffers fail~~\n&quot;); exit(2); &#125; if(V4L2Capture::closeDevice() == FALSE)&#123; printf(&quot;CloseDevice fail~~\n&quot;); exit(1); &#125; return TRUE;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * v4l2cap.h * * Created on: Jul 26, 2017 * Author: wordzzzz */#ifndef V4L2CAP_H_#define V4L2CAP_H_#include &quot;include.h&quot;#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))#define TRUE 1#define FALSE 0class V4L2Capture &#123;public: V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap); virtual ~V4L2Capture(); int openDevice(); int closeDevice(); int initDevice(); int initDeviceCap(); int startCapture(); int stopCapture(); int freeBuffers(); int getFrame(void **,size_t *); int backFrame(); int pre2cap(); int cap2pre(); int preBegin(); int preEnd(); int initBuffers(); struct cam_buffer &#123; void* start; unsigned int length; &#125;; char *devName; int widthCap; int heightCap; int width; int height; int fd_cam; cam_buffer *buffers; unsigned int n_buffers; int frameIndex;&#125;;#endif /* V4L2CAP_H_ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * main.cpp * * Created on: Jul 26, 2017 * Author: wordzzzz */#include &quot;include.h&quot;#include &quot;v4l2cap.h&quot;#define IMAGEWIDTH 640#define IMAGEHEIGHT 480#define TRUE 1#define FALSE 0int main()&#123; IplImage* img,* img_cap; CvMat cvmat,cvmat_cap; double t; unsigned char *frame = NULL; unsigned long frameSize = 0; string videoDev=&quot;/dev/video1&quot;; V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()), IMAGEWIDTH, IMAGEHEIGHT, IMAGEWIDTH_CAP, IMAGEHEIGHT_CAP); vcap-&gt;preBegin(); //预览模式开启 cvNamedWindow(&quot;one&quot;,CV_WINDOW_AUTOSIZE); //创建显示窗口 while(1)&#123; t = (double)cvGetTickCount(); vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);//获取图像队列 cvmat = cvMat(IMAGEHEIGHT,IMAGEWIDTH,CV_8UC3,frame);//CV_8UC3 img = cvDecodeImage(&amp;cvmat,1); //OpenCV解码 if(!img) printf(&quot;No img\n&quot;); cvShowImage(&quot;one&quot;,img); //显示图像 cvReleaseImage(&amp;img); //循环外释放也可以 vcap-&gt;backFrame(); //返回图像队列 cvWaitKey(1); //不写这句话将无法显示图像 t=(double)cvGetTickCount()-t; printf(&quot;used time is %gms\n&quot;,(t/(cvGetTickFrequency()*1000))); &#125; vcap-&gt;preEnd(); //预览结束 return 0;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>USB摄像头</tag>
        <tag>MJPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之八：Qt安装与配置]]></title>
    <url>%2F2017%2F10%2F08%2Ftx-8%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面：很多朋友私下问我如何在NVIDIA TX1上安装和配置Qt，所以我就自己试着配置了一把，现在贴出了分享给大家。这篇文章是关于安装QT 5.5.1支持的Qt Creator 3.3.1 版本。 一、安装Qt 1.安装Qt Creator，打开终端执行如下命令：1$ sudo apt-get install qt5-default qtcreator -y 2.安装Qt示例和文档：1$ sudo apt-get install qt5-doc qt5-doc-html qtbase5-doc-html qtbase5-examples -y 二、配置Qt 1.搜索Qt并打开应用程序，当然也可以用命令行直接打开： 2.Tools-&gt;Options-&gt;Build &amp; Run-&gt;Compilers，单击add选择添加GCC编译器，GCC编译器默认路径为/usr/bin/gcc，添加完路径之后还要修改开发平台，如图所示： 3.切换到Kit下，添加开发套件。名称可以随便写，需要注意的是必须先配置上一步的GCC，这一步才能直接添加GCC，否则就会像Desktop套件一样报错： 三、测试Qt示例 1.打开示例，随便选一个都可以，在这里我选择的是看起来比较酷炫的图标排列例程： 2.工程路径和打开例程方式，这里我们默认即可： 3.F5构建项目，然后运行结果如图所示： 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之七：FFMPEG安装与测试]]></title>
    <url>%2F2017%2F10%2F07%2Ftx-7%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 纪念雷神雷神在中国视音频领域影响深远，值此纪念日，缅怀雷神。 ——分割线—— 前言：本人需要在NVIDIA TX1上通过USB摄像头实现拍照和预览功能，奈何自己买的USB摄像头的YUYV格式只有640*480这么一种分辨率，JPEG格式下的分辨率倒是很多。现在TX1上面的多媒体例程已经更新到第12个：12_camera_v4l2_cuda。但是本人不才，还是没有在nvcc中找到与V4L2中的MJPEG对应的format格式，期间还搞过一段时间的Gstreamer，但是只能单独实现预览或者拍照功能，再往深了就不会写了，资料太少了。挣扎许久之后还是放弃了，转战Ffmpeg。其实Gstreamer和Ffmpeg这两者挺像的，都是先用命令行测试之后再码代码，但是Gstreamer包括晦涩难懂的OBJECT编程，最起码我学起来很吃力，以后有精力了再尝试吧。 一、Ffmpeg安装：1.安装依赖：12345sudo apt-get updatesudo apt-get -y install autoconf automake build-essential libass-dev libfreetype6-dev \ libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev \ libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-devsudo apt-get -y install yasm nasm libx264-dev libx265-dev libmp3lame-dev libopus-dev libvpx-dev 2.安装无法自动更新的libfdk-aac：123456789mkdir ~/ffmpeg_sourcescd ~/ffmpeg_sourceswget -O fdk-aac.tar.gz https://github.com/mstorsjo/fdk-aac/tarball/mastertar xzvf fdk-aac.tar.gzcd mstorsjo-fdk-aac*autoreconf -fiv./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-sharedmakemake install 3.安装：1234567891011121314151617181920212223242526cd ~/ffmpeg_sourceswget http://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2tar xjvf ffmpeg-snapshot.tar.bz2cd ffmpegPATH=&quot;$HOME/bin:$PATH&quot; PKG_CONFIG_PATH=&quot;$HOME/ffmpeg_build/lib/pkgconfig&quot; ./configure \ --prefix=&quot;$HOME/ffmpeg_build&quot; \ --pkg-config-flags=&quot;--static&quot; \ --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \ --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \ --bindir=&quot;$HOME/bin&quot; \ --enable-gpl \ --enable-libass \ --enable-libfdk-aac \ --enable-libfreetype \ --enable-libmp3lame \ --enable-libopus \ --enable-libtheora \ --enable-libvorbis \ --enable-libvpx \ --enable-libx264 \ --enable-libx265 \ --enable-nonfree \ --enable-sharedPATH=&quot;$HOME/bin:$PATH&quot; makemake installhash -r 二、SDL安装：先简单再介绍一下SDL：SDL是Simple DirectMedia Layer（简易直控媒体层）的缩写。它是一个跨平台的多媒体库，以用于直接控制底层的多媒体硬件的接口。主要用在开发游戏上！ Ubuntu的新得立已经包含SDL库，所以通过几个简单的命令就可以安装，比windows还傻瓜！1sudo apt-get install libsdl1.2-dev 附加包：1234567sudo apt-get install libsdl-image1.2-devsudo apt-get install libsdl-mixer1.2-devsudo apt-get install libsdl-ttf2.0-devsudo apt-get install libsdl-gfx1.2-dev 三、测试：这里用雷神的代码进行测试，Ffmpeg+SDL实现摄像头采集与显示。先参考先前的博客在主机上用Nsight新建工程，然后进行配置，具体配置如下： 代码如下，代码原文链接：http://blog.csdn.net/leixiaohua1020/article/details/39702113123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;stdio.h&gt;#define __STDC_CONSTANT_MACROS#ifdef _WIN32//Windowsextern &quot;C&quot;&#123;#include &quot;libavcodec/avcodec.h&quot;#include &quot;libavformat/avformat.h&quot;#include &quot;libswscale/swscale.h&quot;#include &quot;libavdevice/avdevice.h&quot;#include &quot;SDL/SDL.h&quot;&#125;;#else//Linux...#ifdef __cplusplusextern &quot;C&quot;&#123;#endif#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libavdevice/avdevice.h&gt;#include &lt;SDL/SDL.h&gt;#ifdef __cplusplus&#125;;#endif#endif//Output YUV420P #define OUTPUT_YUV420P 0//&apos;1&apos; Use Dshow //&apos;0&apos; Use VFW#define USE_DSHOW 0//Refresh Event#define SFM_REFRESH_EVENT (SDL_USEREVENT + 1)#define SFM_BREAK_EVENT (SDL_USEREVENT + 2)int thread_exit=0;int sfp_refresh_thread(void *opaque)&#123; thread_exit=0; while (!thread_exit) &#123; SDL_Event event; event.type = SFM_REFRESH_EVENT; SDL_PushEvent(&amp;event); SDL_Delay(40); &#125; thread_exit=0; //Break SDL_Event event; event.type = SFM_BREAK_EVENT; SDL_PushEvent(&amp;event); return 0;&#125;//Show Dshow Devicevoid show_dshow_device()&#123; AVFormatContext *pFormatCtx = avformat_alloc_context(); AVDictionary* options = NULL; av_dict_set(&amp;options,&quot;list_devices&quot;,&quot;true&quot;,0); AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;); printf(&quot;========Device Info=============\n&quot;); avformat_open_input(&amp;pFormatCtx,&quot;video=dummy&quot;,iformat,&amp;options); printf(&quot;================================\n&quot;);&#125;//Show Dshow Device Optionvoid show_dshow_device_option()&#123; AVFormatContext *pFormatCtx = avformat_alloc_context(); AVDictionary* options = NULL; av_dict_set(&amp;options,&quot;list_options&quot;,&quot;true&quot;,0); AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;); printf(&quot;========Device Option Info======\n&quot;); avformat_open_input(&amp;pFormatCtx,&quot;video=Integrated Camera&quot;,iformat,&amp;options); printf(&quot;================================\n&quot;);&#125;//Show VFW Devicevoid show_vfw_device()&#123; AVFormatContext *pFormatCtx = avformat_alloc_context(); AVInputFormat *iformat = av_find_input_format(&quot;vfwcap&quot;); printf(&quot;========VFW Device Info======\n&quot;); avformat_open_input(&amp;pFormatCtx,&quot;list&quot;,iformat,NULL); printf(&quot;=============================\n&quot;);&#125;//Show AVFoundation Devicevoid show_avfoundation_device()&#123; AVFormatContext *pFormatCtx = avformat_alloc_context(); AVDictionary* options = NULL; av_dict_set(&amp;options,&quot;list_devices&quot;,&quot;true&quot;,0); AVInputFormat *iformat = av_find_input_format(&quot;avfoundation&quot;); printf(&quot;==AVFoundation Device Info===\n&quot;); avformat_open_input(&amp;pFormatCtx,&quot;&quot;,iformat,&amp;options); printf(&quot;=============================\n&quot;);&#125;int main(int argc, char* argv[])&#123; AVFormatContext *pFormatCtx; int i, videoindex; AVCodecContext *pCodecCtx; AVCodec *pCodec; av_register_all(); avformat_network_init(); pFormatCtx = avformat_alloc_context(); //Open File //char filepath[]=&quot;src01_480x272_22.h265&quot;; //avformat_open_input(&amp;pFormatCtx,filepath,NULL,NULL) //Register Device avdevice_register_all();//Windows#ifdef _WIN32 //Show Dshow Device show_dshow_device(); //Show Device Options show_dshow_device_option(); //Show VFW Options show_vfw_device();#if USE_DSHOW AVInputFormat *ifmt=av_find_input_format(&quot;dshow&quot;); //Set own video device&apos;s name if(avformat_open_input(&amp;pFormatCtx,&quot;video=Integrated Camera&quot;,ifmt,NULL)!=0)&#123; printf(&quot;Couldn&apos;t open input stream.\n&quot;); return -1; &#125;#else AVInputFormat *ifmt=av_find_input_format(&quot;vfwcap&quot;); if(avformat_open_input(&amp;pFormatCtx,&quot;0&quot;,ifmt,NULL)!=0)&#123; printf(&quot;Couldn&apos;t open input stream.\n&quot;); return -1; &#125;#endif#elif defined linux //Linux AVInputFormat *ifmt=av_find_input_format(&quot;video4linux2&quot;); if(avformat_open_input(&amp;pFormatCtx,&quot;/dev/video0&quot;,ifmt,NULL)!=0)&#123; printf(&quot;Couldn&apos;t open input stream.\n&quot;); return -1; &#125;#else show_avfoundation_device(); //Mac AVInputFormat *ifmt=av_find_input_format(&quot;avfoundation&quot;); //Avfoundation //[video]:[audio] if(avformat_open_input(&amp;pFormatCtx,&quot;0&quot;,ifmt,NULL)!=0)&#123; printf(&quot;Couldn&apos;t open input stream.\n&quot;); return -1; &#125;#endif if(avformat_find_stream_info(pFormatCtx,NULL)&lt;0) &#123; printf(&quot;Couldn&apos;t find stream information.\n&quot;); return -1; &#125; videoindex=-1; for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) &#123; videoindex=i; break; &#125; if(videoindex==-1) &#123; printf(&quot;Couldn&apos;t find a video stream.\n&quot;); return -1; &#125; pCodecCtx=pFormatCtx-&gt;streams[videoindex]-&gt;codec; pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id); if(pCodec==NULL) &#123; printf(&quot;Codec not found.\n&quot;); return -1; &#125; if(avcodec_open2(pCodecCtx, pCodec,NULL)&lt;0) &#123; printf(&quot;Could not open codec.\n&quot;); return -1; &#125; AVFrame *pFrame,*pFrameYUV; pFrame=av_frame_alloc(); pFrameYUV=av_frame_alloc(); //unsigned char *out_buffer=(unsigned char *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height)); //avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //SDL---------------------------- if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; printf( &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError()); return -1; &#125; int screen_w=0,screen_h=0; SDL_Surface *screen; screen_w = pCodecCtx-&gt;width; screen_h = pCodecCtx-&gt;height; screen = SDL_SetVideoMode(screen_w, screen_h, 0,0); if(!screen) &#123; printf(&quot;SDL: could not set video mode - exiting:%s\n&quot;,SDL_GetError()); return -1; &#125; SDL_Overlay *bmp; bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,SDL_YV12_OVERLAY, screen); SDL_Rect rect; rect.x = 0; rect.y = 0; rect.w = screen_w; rect.h = screen_h; //SDL End------------------------ int ret, got_picture; AVPacket *packet=(AVPacket *)av_malloc(sizeof(AVPacket));#if OUTPUT_YUV420P FILE *fp_yuv=fopen(&quot;output.yuv&quot;,&quot;wb+&quot;); #endif struct SwsContext *img_convert_ctx; img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); //------------------------------ SDL_Thread *video_tid = SDL_CreateThread(sfp_refresh_thread,NULL); // SDL_WM_SetCaption(&quot;Simplest FFmpeg Read Camera&quot;,NULL); //Event Loop SDL_Event event; for (;;) &#123; //Wait SDL_WaitEvent(&amp;event); if(event.type==SFM_REFRESH_EVENT)&#123; //------------------------------ if(av_read_frame(pFormatCtx, packet)&gt;=0)&#123; if(packet-&gt;stream_index==videoindex)&#123; ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if(ret &lt; 0)&#123; printf(&quot;Decode Error.\n&quot;); return -1; &#125; if(got_picture)&#123; SDL_LockYUVOverlay(bmp); pFrameYUV-&gt;data[0]=bmp-&gt;pixels[0]; pFrameYUV-&gt;data[1]=bmp-&gt;pixels[2]; pFrameYUV-&gt;data[2]=bmp-&gt;pixels[1]; pFrameYUV-&gt;linesize[0]=bmp-&gt;pitches[0]; pFrameYUV-&gt;linesize[1]=bmp-&gt;pitches[2]; pFrameYUV-&gt;linesize[2]=bmp-&gt;pitches[1]; sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);#if OUTPUT_YUV420P int y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv); //Y fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv); //U fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv); //V #endif SDL_UnlockYUVOverlay(bmp); SDL_DisplayYUVOverlay(bmp, &amp;rect); &#125; &#125; av_free_packet(packet); &#125;else&#123; //Exit Thread thread_exit=1; &#125; &#125;else if(event.type==SDL_QUIT)&#123; thread_exit=1; &#125;else if(event.type==SFM_BREAK_EVENT)&#123; break; &#125; &#125; sws_freeContext(img_convert_ctx);#if OUTPUT_YUV420P fclose(fp_yuv);#endif SDL_Quit(); //av_free(out_buffer); av_free(pFrameYUV); avcodec_close(pCodecCtx); avformat_close_input(&amp;pFormatCtx); return 0;&#125; 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>FFMPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之六：SSD安装与测试]]></title>
    <url>%2F2017%2F10%2F06%2Ftx-6%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面：本博文原打算以SSD为例，介绍如何在NVIDIA Jetson TX1上安装SSD，并进行图片检测。 安装过程： 1.用以下命令安装依赖包:123456$ sudo add-apt-repository universe$ sudo add-apt-repository multiverse$ sudo apt-get update$ sudo apt-get install libboost-all-dev libprotobuf-dev libleveldb-dev libsnappy-dev$ sudo apt-get install libhdf5-serial-dev protobuf-compiler libgflags-dev libgoogle-glog-dev$ sudo apt-get install liblmdb-dev libblas-dev libatlas-base-dev libopenblas-dev 2.下载SSD源码安装包从如下网站：SSD：https://github.com/weiliu89/caffe.git1$ git clone https://github.com/weiliu89/caffe.git 3.设置路径并解压：a.如果是从官网下载的zip压缩包，则进行如下操作：123$ mkdir -pv $HOME/Work/caffe$ cp caffe-ssd.zip $HOME/Work/caffe/$ cd $HOME/Work/caffe/ &amp;&amp; unzip caffe-ssd.zip b.如果是git获得的，则进行如下操作：1$ mv caffe $HOME/Work/caffe/caffe-ssd 无论进行a操作还是b操作，最好都进行一下版本切换：12$ cd ~/Work/caffe/caffe-ssd$ git checkout ssd 4.安装python依赖：1234$ cd ../python$ sudo apt-get install python-pip python-numpy$ sudo pip install --upgrade pip$ for req in $(cat requirements.txt); do pip install $req; done requirements.txt内容如下：1234567891011121314151617Cython&gt;=0.19.2numpy&gt;=1.7.1scipy&gt;=0.13.2scikit-image&gt;=0.9.3matplotlib&gt;=1.3.1ipython&gt;=3.0.0h5py&gt;=2.2.0leveldb&gt;=0.191networkx&gt;=1.8.1nose&gt;=1.3.0pandas&gt;=0.12.0python-dateutil&gt;=2.6.0protobuf&gt;=2.5.0python-gflags&gt;=2.0pyyaml&gt;=3.10Pillow&gt;=2.3.0six&gt;=1.1.0 5.编译SSD源码: 1$ cd $HOME/Work/caffe/caffe-ssd 12$ cp Makefile.config.example Makefile.config$ vi Makefile.config 去掉下面该行代码的注释：1USE_CUDNN := 1 重点来了，在Makefile.config中找到下面这几行：1234567CUDA_ARCH := -gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=sm_50 \ -gencode arch=compute_52,code=sm_52 \ -gencode arch=compute_60,code=sm_60 \ -gencode arch=compute_61,code=sm_61 \ -gencode arch=compute_61,code=compute_61 更改为：1CUDA_ARCH := -gencode arch=compute_53,code=sm_53 这里的后缀数字53是TX1的计算能力，在其他平台上编译CAFFE也是同样的道理，要把计算能力改成对应的值，否则有可能会报错。关于计算能力如何确定，CUDA例程里面有测试程序，跑一下就可以输出GPU性能指标。 声明下面这两行路径，保存后退出：12INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/aarch64-linux-gnu/hdf5/serial 1$ make -j4 完成后在build/lib目录下会出现库文件libcaffe.so。123$ make all -j4$ make runtest -j4(此部分报错，可以不跑)$ make pycaffe -j4 环境变量配置：1.在终端执行如下指令：1$ sudo vim ~/.bashrc 2.在最后一行添加caffe的python路径1export PYTHONPATH=$HOME/Work/caffe/caffe-ssd/python:$PYTHONPATH 然后加上之前声明的环境变量，这样就不用每次make或者运行的时候再次声明环境变量了。123export TEGRA_ARMABI=aarch64-linux-gnuexport DISPLAY=:0export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-ssd/build/lib:/usr/local/cuda/lib64 3.source环境变量，在终端执行如下命令：1$ source ~/.bashrc 测试：1.使用jupyter或者ipython打开notebook：1$ jupyter notebook 2.修改caffe路径，需要在下图的标记位置写上自己的caffe路径： 3.下载VGG训练模型，直接从官网下载即可，然后解压到models下。并确认下图中标记框中路径是否正确： 4.置信度，通过调节置信度阈值，来控制在检测结果中需要显示的显示框： 5.测试结果： 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之五：CAFFE安装与NVIDIA多媒体例程测试]]></title>
    <url>%2F2017%2F10%2F05%2Ftx-5%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 写在前面的前面：之前就已经在实验室的深度学习服务器上安装过CAFFE/SSD，由于当时深度学习服务器管理不佳，多人混用造成好多依赖环境删删减减，经常会出现今天装的CAFFE/SSD明天就不能用的情况，所以难免多折腾几次。因此，博主对他们的安装还是颇有研究的。大家用NVIDIA Jetson TX1，无非就是看上了它的计算能力，能跑深度学习框架。由于NVIDIA Jetson TX1容量有限，所以建议大家需要哪个就安装哪个。偏向于学习，就安装纯版本的CAFFE，偏向于应用测试，就安装各个基于CAFFE的升级版，比如SSD。 写在前面：本博文原打算以CAFFE/SSD为例，介绍如何在NVIDIA Jetson TX1上安装CAFFE/SSD，但是最近自己又安装了一遍，发现本博文的步骤不全面，导致python大部分依赖环境都没装上，这样的结果就是jupyter notebook这种工具用不了。所以本篇博文在此只介绍CAFFE安装和基于CAFFE的NVIDIA多媒体例程测试。 安装过程： 1.用以下命令安装依赖包:123456$ sudo add-apt-repository universe$ sudo add-apt-repository multiverse$ sudo apt-get update$ sudo apt-get install libboost-all-dev libprotobuf-dev libleveldb-dev libsnappy-dev$ sudo apt-get install libhdf5-serial-dev protobuf-compiler libgflags-dev libgoogle-glog-dev$ sudo apt-get install liblmdb-dev libblas-dev libatlas-base-dev 2.下载CAFFE源码安装包从如下网站： CAFFE：https://github.com/BVLC/caffe.git1$ git clone https://github.com/BVLC/caffe.git 3设置路径并解压：a.如果在步骤2中选择自己从网页手动下载zip文件，则进行如下操作：CAFFE:123$ mkdir -pv $HOME/Work/caffe$ cp caffe-master.zip $HOME/Work/caffe/$ cd $HOME/Work/caffe/ &amp;&amp; unzip caffe-master.zip b.如果在步骤2中直接git得到caffe文件，则进行如下操作：1$ mv caffe $HOME/Work/caffe/caffe-master 4.编译CAFFE源码:CAFFE:1$ cd $HOME/Work/caffe/caffe-master 12$ cp Makefile.config.example Makefile.config$ vi Makefile.config 去掉下面该行代码的注释：1USE_CUDNN := 1 重点来了，在Makefile.config中找到下面这几行：1234567CUDA_ARCH := -gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=sm_50 \ -gencode arch=compute_52,code=sm_52 \ -gencode arch=compute_60,code=sm_60 \ -gencode arch=compute_61,code=sm_61 \ -gencode arch=compute_61,code=compute_61 更改为：1CUDA_ARCH := -gencode arch=compute_53,code=sm_53 这里的后缀数字53是TX1的计算能力，在其他平台上编译CAFFE也是同样的道理，要把计算能力改成对应的值，否则有可能会报错。关于计算能力如何确定，CUDA例程里面有测试程序，跑一下就可以输出GPU性能指标。 声明下面这两行路径，保存后退出：12INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/aarch64-linux-gnu/hdf5/serial 1$ make -j4 完成后在build/lib目录下会出现库文件libcaffe.so。123$ make all -j4$ make runtest -j4$ make pycaffe -j4 5.编译opencv用户库这个库是CAFFE所必需的。而且只能在目标板上编译。1$ cd ~/tegra_multimedia_api/samples/11_camera_object_identification/opencv_consumer_lib 检查并确保正确设置makefile以下变量：12CUDA_DIR:=/usr/local/cudaCAFFE_DIR:=$HOME/Work/caffe/caffe-master 编译：1$ make 完成后当前目录下会出现库文件 libopencv_consumer.so 通过下面的命令下载CAFFE模型二进制文件：1234$ sudo apt-get install python-pip$ sudo pip install pyyaml$ cd $HOME/Work/caffe/caffe-master$ ./scripts/download_model_binary.py models/bvlc_reference_caffenet/ 用下面的命令获得ImageNet标签文件：1$ ./data/ilsvrc12/get_ilsvrc_aux.sh 使用下列命令生成和运行示例：1234567891011$ cd ~/tegra_multimedia_api/samples/11_camera_object_identification$ export TEGRA_ARMABI=aarch64-linux-gnu$ export DISPLAY=:0$ make$ export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-master/build/lib:/usr/local/cuda/lib64$ ./camera_caffe -width 1920 -height 1080 \ -lib opencv_consumer_lib/libopencv_consumer.so \ -model $HOME/Work/caffe/caffe-master/models/bvlc_reference_caffenet/deploy.prototxt \ -trained $HOME/Work/caffe/caffe-master/models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel \ -mean $HOME/Work/caffe/caffe-master/data/ilsvrc12/imagenet_mean.binaryproto \ -label $HOME/Work/caffe/caffe-master/data/ilsvrc12/synset_words.txt 8、环境变量设置1.在终端执行如下指令：1sudo vim ~/.bashrc 2.在最后一行添加caffe的python路径1export PYTHONPATH=$HOME/Work/caffe/caffe-master/python:$PYTHONPATH 然后加上之前声明的环境变量，这样就不用每次make或者运行的时候再次声明环境变量了。123export TEGRA_ARMABI=aarch64-linux-gnuexport DISPLAY=:0export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-master/build/lib:/usr/local/cuda/lib64 3.source环境变量，在终端执行如下命令：1source ~/.bashrc 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>CAFFE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之四：Nsight Eclipse Edition进阶]]></title>
    <url>%2F2017%2F10%2F04%2Ftx-4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz &#160;&#160;&#160;&#160;上一篇博文简单介绍了如何使用Nsight Eclipse Edition来导入CUDA例程并构建应用程序到NVIDIA Jetson TX1开发板上。本篇博文将继续介绍Nsight Eclipse Edition的进阶使用，通过OpenCV测试程序和GStreamer测试程序，分别介绍如何添加库链接和库路径到工程文件中，全是干货。友情提示，记得打开开发板并接入到局域网哦~ 1. OpenCV测试程序 &#160;&#160;&#160;&#160;JetPack3.0为TX1预装的OpenCV版本为OpenCV2.4.13，环境变量都已配置好，所以我们无需在开发套件上进行任何操作。 1.新建CUDA C++工程，如下图所示： 2.填入工程名称，工程类型为空工程，工具链为CUDA Toolkit 8.0，单击Next： 3.基础设置，这里我们之前已经说过了，对于TX1，全部选5.3。当然按默认的2.0一般也不会报错： 4.目标系统，默认的是主机。如果你之前设置过，这次你只需要单击下拉条就会出现之前的设置，选中就好。我在这里还是重复一遍操作吧，单击Manage： 5.上一步骤之后出现远程连接对话框，填入开发板IP地址和用户名，其他的默认就好，然后单击Finish退出： 6.把Local System关掉，然后选择远程连接的工程路径、工具箱路径和CPU类型地，选完后单击Finish。7、8、9会分别对这三项进行详细说明： 7.Project Path：在步骤6中单击Project Path后面的Browse，出现下图所示对话框，里面显示的是远程连接的开发套件的文件目录，可以进行简单的新建删除等功能。这里我们选择好自己的工程路径。中间可能会出现链接提示，有时还会让你填写TX1的密码，大家乖乖填上就好： 8.Toolkit：在步骤6中单击Tookit后面的Manage，弹出下图所示对话框，第一次打开的话里面的Toolkit path 是空的。我们不需要自己去找工具箱的路径，只需要单击Detect，系统就会帮我们自动填写上工具箱路径。中间可能会出现链接提示，有时还会让你填写TX1的密码，大家乖乖填上就好： 9.CPU Architecture：下拉菜单中有很多类型，我们的TX1对应的是AArch64： 10.对新建的工程添加源文件： 11.因为我们例程用的是OpenCV的hpp头文件，所以源文件最好也写成C++的源文件。填入文件名，选择默认的C++源文件模板： 12.测试代码如下： 1234567891011121314151617181920212223/* * test_opencv.cpp * * Created on: Jun 3, 2017 * Author: wordzzzz */#include &quot;opencv2/highgui/highgui.hpp&quot;int main()&#123; cv::Mat img(512, 512, CV_8UC3, cv::Scalar(0)); cv::putText(img, &quot;Hello, OpenCV on Jetson!&quot;, cv::Point(10, img.rows / 2), cv::FONT_HERSHEY_DUPLEX, 1.0, CV_RGB(118, 185, 0), 2); cv::imshow(&quot;Hello!&quot;, img); cv::waitKey();&#125; 13.查看库链接。前面已经说到，JetPack3.0已经预装了OpenCV2.4.13，各种环境变量都已设置好，具体信息我们可以通过如下命令在TX1上进行查看：1pkg-config --cflags --libs opencv &#160;&#160;&#160;&#160;查看结果如下图所示： 12ubuntu@tegra-ubuntu:~$ pkg-config --cflags --libs opencv-I/usr/include/opencv -L/usr/local/cuda-8.0/lib64 -lopencv_calib3d -lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_gpu -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lopencv_objdetect -lopencv_photo -lopencv_stitching -lopencv_superres -lopencv_ts -lopencv_video -lopencv_videostab -lopencv_detection_based_tracker -lopencv_esm_panorama -lopencv_facedetect -lopencv_imuvstab -lopencv_tegra -lopencv_vstab -lcufft -lnpps -lnppi -lnppc -lcudart -latomic -ltbb -lrt -lpthread -lm -ldl 14.打开性能设置，即在工程右键，然后选择Properties： 15.重点来了：添加库链接。 &#160;&#160;&#160;&#160;如果你在第12步直接构建上述代码，肯定会出错，因为我们现在所有的设置，都是在为我们的工程文件编写编译命令。熟悉g++/gcc的朋友们可能会有印象，就是我们直接用g++/gcc编译文件的时候，如果用到哪个链接库，一般都是在后面加上-l这种链接的，否则会找不到相应的库链接。 16.经过上述步骤后再CTR+B进行构建，我们可以看到构建命令包括了我们添加的库链接，没有报错表明构建成功： 2. Gstreamer测试程序 1.新建项目，过程不再赘述，然后添加源文件，这次我们用C模板，而不是C++。 1234567891011121314151617181920212223242526272829303132333435/* * basic-tutorial-1.c * * Created on: Jun 1, 2017 * Author: wordzzzz */#include &lt;gst/gst.h&gt;int main(int argc, char *argv[]) &#123; GstElement *pipeline; GstBus *bus; GstMessage *msg; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Build the pipeline */ pipeline = gst_parse_launch (&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;, NULL); /* Start playing */ gst_element_set_state (pipeline, GST_STATE_PLAYING); /* Wait until error or EOS */ bus = gst_element_get_bus (pipeline); msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS); /* Free resources */ if (msg != NULL) gst_message_unref (msg); gst_object_unref (bus); gst_element_set_state (pipeline, GST_STATE_NULL); gst_object_unref (pipeline); return 0;&#125; 2.添加头文件路径和库链接：此处比OpenCV多了头文件路径的添加，因为gstremer-1.0的头文件路径貌似没有加入到环境变量中。 &#160;&#160;&#160;&#160;上图中添加的路径，切记是TX1上的路径，而不是虚拟机里的路径。之前用过QT进行过交叉编译，感觉被洗脑了。Nsight的构建，是通过你的设置产生的编译命令，直接在TX1上进行编译的，而不是先生成在虚拟机里再拷贝到TX1上。所以你只要保证你添加的头文件路径和库路径能在TX1上找到就行，没必要把TX1上的库都拷过来，这样反而会出错。 3.CTRL+B构建后在TX1上运行，会有视频播放出来。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Nsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之三：Nsight Eclipse Edition基础]]></title>
    <url>%2F2017%2F10%2F03%2Ftx-3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz &#160;&#160;&#160;&#160;Nsight Eclipse Edition是专为NVIDIA定制的Eclipse开发环境，主要区别是在菜单中加入了CUDA工程的建立、CUDAToolKit和NVIDIA的NVCC编译器等开发工具，方便开发者开发基于CUDA强大计算能力的各种工程项目。&#160;&#160;&#160;&#160;根据上个教程安装完JetPcak3.0的各个功能模块之后，就可以在桌面的搜索框找出Nsight Eclipse Edition这个软件： &#160;&#160;&#160;&#160;本次教程以CUDA自带例程oceanFFT为例，介绍Nsight Eclips Edition的简单使用。 1.双击Nsight软件，弹出对话框，选择工作空间，即工作文件存放路径。确定后点击OK： 2.File-&gt;New-&gt;CUDA C/C++ Project，新建CUDA工程： 3.Project name：命名工程名称，Project type：提取CUDA例程，选定后点击Next： 4.选取CUDA例程，这里我们选择oceanFFT，选定后点击Next： 5.基础设置默认即可，当然，对于TX1的PTX和GPU，标准的选择还是5.3，而不是2.0，选定后点击Next： 6.选择链接，点击Management，创建新的链接，链接内容如第7步所示： 7.输入IP和用户名，通过SSH登陆，填完后点击Finish： 8.选择Project Path、Toolkit和CPU类型，选定后点击Next： 9.编译版本默认即可，选定后点击Next： 10.工程文件： 11.Ctrl+B,构建： 12.在TX1上找到相应目录，运行相应二进制文件，运行效果如下： &#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍Nsight进阶开发。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Nsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之二：刷机与开发前准备]]></title>
    <url>%2F2017%2F10%2F02%2Ftx-2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 虚拟机系统：Ubuntu14.04 编者: WordZzzz 1. JetPack3.0下载与安装 本人PC端使用虚拟机安装Ubuntu14.04系统进行开发，需要有效联网。 1.首先在自己的home目录下创建Jetson文件夹： 12$ mkdir ~/Jetson$ cd ~/Jetson 2.下载可执行文件到新建的Jetson文件夹下：https://developer.nvidia.com/embedded/downloads 3.在虚拟机上运行安装脚本： 12$ chmod +x ./JetPack-L4T-&lt;version&gt;-linux-x64.run$ ./JetPack-L4T-&lt;version&gt;-linux-x64.run 之后出现如下图所示，单击Next： 之后会显示安装路径，单击Next： 4.接下来是开发板选型，这里我选TX1，单击Next： 5.输入root用户密码： 6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（ps：一般默认即可，只安装Jetpack不刷机的话就把下面的Target-Jetson TX1的Action一栏全部改为no action；由于我的已经安装完毕，所以Action一栏都是no action）： 7.接受所选组件的许可协议，全部同意并单击Next： 8.报错的话就按提示安装依赖库后再进行Jetpack安装： 9.安装完成后如下图所示，单机Next： 10.点击Finish即可完成安装，最好不要勾选移除安装包： 2. 刷机&#160;&#160;&#160;&#160;刷机过程需要重复上述1-5步，并且在第6步中Target-Jetson TX1的Action一栏改为需要的各个软件安装版本。所以刷机从第6步开始介绍.6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（一般默认即可）： 7.接受所选组件的许可协议，全部同意并单击Next： 8.该组件管理器将继续安装。一旦主机的安装步骤完成后，单击下一步按钮继续安装目标组件。 9.a.如果在6中取消选择Flash OS的组件管理器（即不烧写系统，只烧写某些组件），将需要输入IP地址，用户名和密码来建立ssh连接到目标设备： 9.b.如果在6中选择Flash OS的组件管理器，需要选择适合的特定环境中的网络布局： 10.a.如果选择了通过路由器/交换机设备访问互联网的布局，你会被要求选择哪个接口用于上网。 10.b.如果您选择的设备通过主机IP获得通过指定DHCP服务器主机和访问互联网上的布局，您必须选择哪个接口是用于上网，并且将被用于目标接口。 11.烧写确认，单击Next： 12.之后会弹出POST窗口来引导你开启USB强制恢复模式： &#160;&#160;&#160;&#160;TX1与主机使用usb连接，开启USB强制恢复模式（关机情况下，按一下POWER键，再长按REC键的同时点按RESET键，两秒后松开REC键）此时虚拟机会弹出NVIDIA设备： 可以lsusb确认一下： 13.在POST窗口中回车，开始安装： 14.系统安装完成后板子会重启。如果TX1重启后出现了Ubuntu的GUI界面，说明系统已经安装完成。重启完之后POST窗口会提示你输入IP地址，这里如果输入正确，等待十分钟左右就会进入下一个界面；如果失败，最好查看一下TX1现在的IP。接下来就需要安装CUDA、OpenCV等组件。在按Enter继续安装之前，需要确保TX1已经连网外网，如果校园网需要登录网关这样的，先将网关登录好再继续，因为安装组件的时候，需要安装一些依赖库，需要有外网的情况下才能进行。按Enter继续后，会出现提示信息，确定TX1的IP地址，手动输入TX1的IP地址后，按回车继续，稍等一会儿，会出现如下对话框（和9a里的一样，如果执行的9a而不是9b，这里就不会再出现确认信息）： 15.一路NEXT，再次进入POST界面，此时使用SSH远程服务，无需下载线。 16.安装完之后，程序自动关闭POST，回到如下界面，点击FINISH完成安装。 3. 测试Jetpack自动编译所有例程，CUDA例程可以在以下目录中找到：1&lt;JetPack_Install_Dir&gt; / NVIDIA_CUDA- &lt;版本&gt; _samples 可以通过重新编译运行示例：1SMS=53 EXTRA_LDFLAGS=--unresolved-symbols=ignore-in-shared-libs TARGET_ARCH=aarch64 make 运行：CUDA的例程编译后的二进制文件目录：1/home/ubuntu/NVIDIA_CUDA-&lt;version&gt;_Samples/bin/aarch64/linux/release/ 命令行运行或双击运行：例如，当您运行oceanFFT样品，将显示如下画面。 4. 开发前准备工作 更新源： &#160;&#160;&#160;&#160;因为默认源会找不到我们下述要用的一些依赖库和安装包，所以需要加入国内源，本例中采用的是中科大的源。值得注意的是，如果你之后回头来刷固件，一定还要把源换回来，否则有可能会安装失败。所以我们先做一下备份： 12sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo vim /etc/apt/sources.list 在sources.list中将被#注释掉的源全部打开，随后在底部添加新的源： 123456deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiverse 保存文件后，进行更新：12sudo apt-get updatesudo apt-get upgrade 浏览器安装： &#160;&#160;&#160;&#160;直接能上外网的请忽略此步骤。 &#160;&#160;&#160;&#160;由于身在校内，且实验室网络连接都是交换机模式，每一台设备连接外网时都需要登陆，所以就涉及到浏览器的安装。当然，大家也可以直接用PYTHON写个登陆脚本也是可以的。 &#160;&#160;&#160;&#160;NVIDIA Jetson TX1自带系统没有浏览器是个很尴尬的事情。我们尝试了两款浏览器，分别是Epiphany和Firefox。前者相对稳定，但是用一段时间之后就再也不能跳转至校园网登陆界面；后者经常闪退，但是至少还给我输入账号密码的机会。最后我们选择的是Firefox。 &#160;&#160;&#160;&#160;安装浏览器也需要联网，so，还得先用WiFi连接一下个人热点。 安装Epiphany： 1sudo apt-get install epiphany-browser 安装Firefox： 1sudo apt-get install firefox-browser 输入法安装： &#160;&#160;&#160;&#160;命令行操作一般不需要使用输入法，但是如果我们想在GUI上进行一些操作，比如上网查资料等，输入法还是得有的。 安装google输入法： 12sudo apt-get install ibus-googlepinyinsudo reboot now &#160;&#160;&#160;&#160;安装完后重启系统，随后在GUI界面右上角找到文本输入设置(Text Entry Settings)，在里面将自己新下载的google输入法添加进去即可，操作和WINDOWS下添加输入法一样，故不在此赘述。 lrzsz安装： &#160;&#160;&#160;&#160;NVIDIA Jetson TX1的SSH服务（端口号：22）已经配好，所以我们可以直接使用Xshell或者其他支持SSH远程登陆的客户端软件通过SSH服务来连接TX1，从而方便多人在WINDOWS上远程操控TX1。当然，Xshell是不支持图形界面的，如果想远程登录图形界面，可以配置一下vncserver，但是会消耗资源，个人不建议使用。 &#160;&#160;&#160;&#160;远程登录难免涉及到文件传输，文件传输有两种方法，大文件最好用FTP来传输，推荐使用File Zilla；小文件Xshell自己就可以搞定，需要在TX1上安装lrzsz。 安装lrzsz： 1sudo apt-get install lrzsz sz发送TX1文件到本地： 1sz filename rz发送本地文件到服务器： 1rz &#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何使用Nsight进行程序开发。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BING: Binarized Normed Gradients for Objectness Estimation at 300fps]]></title>
    <url>%2F2017%2F10%2F01%2Fbing-1%2F</url>
    <content type="text"><![CDATA[BING: Binarized Normed Gradients for Objectness Estimation at 300fps基于二值化赋范梯度特征的一般对象估计 摘要： &emsp;&emsp;训练通用对象度量来生成一小组候选对象窗口，已经显示出加速了经典的滑动窗口对象检测范式。我们观察到，通过观察梯度的标准，可以通过将其对应的图像窗口适当地调整到小的固定尺寸来区分具有良好定义的闭合边界的通用对象。基于这个观察和计算复杂度，我们建议将窗口大小调整为8*8并使用赋范梯度作为简单的64D特征来描述，用于明确地训练通用的对象度量。 &emsp;&emsp;我们进一步展示了这种特征的二值化版本，即二值化赋范梯度（BING），它可以用于高效的对象估计，这只需要少量的原子操作（例如加法，按位移动等）。对有挑战性的PASCAL VOC 2007数据集的实验表明，我们的方法有效生成一小组类别无关的高质量对象窗口（单个笔记本电脑CPU上的300fps），通过使用1,000个建议窗口，产生96.2％的对象检测率（DR）。通过增加建议窗口和颜色空间的数量来计算BING特征，我们的性能可以进一步提高到99.5％的DR。 &emsp;&emsp;作为计算机视觉中最重要的领域之一，近年来，对象检测取得了长足的进步。然而，大多数最先进的检测器仍然需要每个类别的特定分类器以滑动窗口方式评估许多图像窗口[17,25]。为了减少每个分类器需要考虑的窗口数量，训练类别通用的对象度量最近变得流行[2,3,21,22,48,49,57]。对象通常表示为反映图像窗口覆盖任何类别的对象的可能性的值[3]。通用对象度量在预过滤过程中具有很大的潜力，可以显着改善：i）通过减少搜索空间来提高计算效率，以及ii）通过允许在测试期间使用强分类器来提高检测精度。然而，设计好的通用对象度量方法是困难的，需要： 具备很好的检测率，找到所有前景对象； 提出少量建议，用于减少对象检测的计算时间； 达到很高的计算效率，很容易拓展到其他实时以及大规模的应用程序中； 具备很好的通用性，方便用于各个类别的检测器中，这样可以减少计算量 &emsp;&emsp;据我们所知，暂时还没有任何方法可以同时满足以上全部要求。 &emsp;&emsp;认知心理学[47,54]和神经生物学[20,38]的研究表明，人们在识别物体之前具有很强的感知对象能力。 基于观察到的人类反应时间和估计的生物信号传播时间，人类注意理论假设人类视觉系统仅处理图像的一部分，而对图像的其余部分几乎视而不见。这进一步表明，在识别对象之前，在人类视觉系统中有简单的机制来选择可能的对象位置。 &emsp;&emsp;在本文中，我们提出了一个非常简单而又强大的特征“BING”，通过使用对象状态分数来帮助搜索对象。我们的工作动机是基于物体是具有明确的封闭边界和中心的独立事物[3，26，32]的事实。我们观察到，当查看赋范梯度（见图1和图3）时，将其相应的图像窗口大小调整为小的固定大小（例如8 8）后，具有明确定义的闭合边界的通用对象具有惊人的强相关性）。因此，为了有效地量化图像窗口的目标，我们将其大小调整为8 8，并使用梯度的范数作为一个简单的64D特征，用于在级联SVM框架中学习通用对象度量。我们进一步展示了NG功能的二值化版本，即二值化规范梯度（BING）功能，可以用于图像窗口的有效对象估计，只需要几个原子CPU操作（即加法，按位移动等） ）。 大部分现存的先进方法，一般采用复杂的分类特征，而且需要采用加速方法以至于计算时间是可控的，相对于此，BING特征是简单朴素的。 &emsp;&emsp;我们已经在PASCAL VOC2007数据集上，广义的评价了我们的方法。实验结果表明，我们的方法有效（在单个笔记本电脑CPU上为300fps）生成一小组数据驱动，类别无关，高品质的对象窗口，通过使用1000个窗口（约为整个滑动窗口的0.2%），产生96.2％的检测率（DR）。将目标窗口数量增加到5000个，估计3个不同颜色空间的对象，我们的方法可以达到99.5％的DR。在[3,22,48]之后，我们也验证了我们的方法的泛化能力。当我们对6个物体类别的对象度量进行训练时，对其他14个不可见的类别进行测试，我们观察到与标准设置类似的高性能（见图3）。与大多数流行的替代方案相比[3,22,48]，BING功能使我们能够使用较小的提议来实现更好的DR，而且能够预测不可见的类别，更简单，更快1000倍。这满足了良好的目标检测器的上述要求。我们的源代码将与论文一起发布。 2.相关工作 &emsp;&emsp;能够在识别物体之前感知物体与自下而上的视觉注意（显着性）密切相关。根据显著性定义，我们将相关研究大致分为三类：固定点预测、显著性对象检测，对象提案生成。 &emsp;&emsp;固定点预测：该模型旨在预测人眼运动的显着性[4,37]。 灵感来自神经生物学研究关于早期灵长类动物视觉系统，Itti等人[36]提出了显着检测的第一个计算模型之一，其估计了多尺度图像特征中的中心包围的差异。Ma和Zhang[42]提出了一种模糊增长模型来分析局部对比度显着性。Harel等人[29]提出了将中心包围的特征图归一化以突出显眼部分。虽然固定点预测模型已经取得了显着的发展，但预测结果倾向于突出边缘和角落而不是整个对象。因此，这些模型不适合生成用于检测目的的对象提案。 &emsp;&emsp;显著性对象检测：该模型尝试检测场景中最引人注意的对象，然后对该对象的整个范围进行细分[5,40]。Liu等人[41]将CRF框架中的局部，区域和全局显着性检测结合起来。 Achanta等人[1]使用频率调节方法的局部显着区域。 Cheng等[11,14]提出了一种基于区域对比分析和迭代图分割的显著性对象检测和分割方法。最近的研究还试图在基于滤波的框架[46]中生成高质量的显着性图，使用有效的数据表示[12]或考虑分层结构[55]。对于简单图像的这种显著性物体分割在图像场景分析[15,58]，内容感知图像编辑[13,56,60]中取得了巨大的成功，并且可以用作处理大量互联网图像或构建的便宜工具通过自动选择好的结果[10,11]，可以很好的应用[7,8,16,31,34,35]。然而，这些方法不太可能用于呈现许多对象的复杂图像，并且它们很少占主导地位（例如VOC[23]）。 &emsp;&emsp;对象提案生成：该方法通过提出少量（例如1,000个）类别无关的提案，并不作出决定，将覆盖图像中的所有对象[3,22,48]。生成粗略分割[6,21]作为对象提案已被证明是减少针对特定分类器的搜索空间的有效方法，同时允许使用强分类器来提高准确性。然而，这两种方法在计算上是昂贵的，每个图像需要2-7分钟。 Alexe等人[3]提出了一种提示集成方法，以更有效地获得更好的预测性能。张等人[57]提出了一种具有定向梯度特征的级联排序SVM方法，用于有效的提案生成。 Uijlings等人[48]提出了一种选择性搜索方法来获得更高的预测性能。我们提出一种简单而直观的方法，通常可以比其他方法更好地实现检测性能，并且比最流行的替代品快了1000倍[3,22,48]（见第4节）。 &emsp;&emsp;另外，对于一个有效的滑动窗口对象检测方法，保证计算量可控是非常重要的[43,51]。Lampert等人[39]提出了一个优雅的分支定界方法用于检测。但是，这些方法只能用于加速分类器，而且是用户已经提供了一个好的边框。一些其他有效的分类器[17]和近似核方法[43,51]也已经被提出。这些方法旨在减小估计单个窗口的计算量，自然也能结合对象性建议进而减小损失。 3.方法 &emsp;&emsp;灵感来自人类视觉系统的能力，在识别物体之前有效地感知对象[20,38,47,54]，我们引入了梯度（NG）特征（第3.1节）的简单64D范数，以及其二进制近似 ，即二值化赋范梯度（BING）特征（第3.3节），以有效捕获图像窗口的对象性。 &emsp;&emsp;为了找到图像中的一般对象，我们扫描一个定义好的量化窗口（依据尺度或者是纵横比）。每一个窗口通过一个线性模型 $w ∈ R64$ 获得得分 $$s_l = &lt; w,g_l &gt;(1)$$ $$l = &lt; i,x,y &gt;(2)$$ $s_l$ 代表过滤器得分， $g_l$ 代表NG特征， $l$ 表示坐标， $i$ 表示尺度， $(x,y)$ 表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 100），一些尺度（例如:10 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）： $$o_l = v_i · s_l + t_i (3)$$ 其中 $v_i，t_i∈ R$ ，针对不同尺度 $i$ 的窗口，得到不同的独立学习系数。使用校准函数（3）是非常快的，通常只需要在最终的建议窗口重排之后进行。 3.1 梯度幅值（NG）和对象状态 对象是具有明确界限的边界和中心的独立事物[3,26,32]。当将与现实世界对象相对应的窗口大小调整为小的固定大小（例如8 8，由于计算原因而选择，将在第3.3节中进行说明）时，相应图像梯度的范数（即幅度）将成为良好的辨别特征，因为封闭边界在这种抽象视图中可能存在的小变化。如图1所示，虽然游轮和人在颜色，形状，质地，照明等方面有很大的差异，但它们在赋范梯度空间中具有明显的相关性。为了有效地预测对象实例的存在，利用这一观察，我们首先将输入图像的大小调整为不同的量化尺寸，并计算出每个调整大小的图像的规范梯度。这些调整大小的规范梯度图的8 8个区域的值被定义为其对应窗口的64D规范梯度（NG）特征。 我们的NG特征，作为图像窗口的密集和紧凑的对象特征，具有以下几个优点。 首先，无论物体的位置，尺度和纵横比如何变化，由于该特征的归一化支持区域，其对应的NG特征将保持大致不变。 换句话说，NG特征对于位置，比例和纵横比的变化不敏感，这对于检测任意类别的对象非常有用。而这些不敏感的属性就是一个很好的对象建议生成方法。 其次，NG特征的密集紧凑表示使得计算和验证非常有效，因此具有很大的实际应用潜力。 Figure 1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。” 将这种优势引入NG特征的成本是丧失描述能力。 幸运的是，所产生的误报将由后续的类别特定检测器处理。 在第4节，我们显示我们的方法产生了一小组高质量的提案，涵盖了具有挑战性的VOC2007数据集中的96.2％的真实对象窗口。3.2 objectness度量 为了学习图像窗口的对象度量，我们遵循两级SVM的总体思路[57]。- 使用线性SVM学习式（1）中的单个模型w [24]。 真实对象窗口和随机采样背景窗口的NG特征分别用作正和负训练样本。- 在（3）中使用线性SVM学习 $v_i$ 和 $t_i$ [24]，我们评估（1）在尺寸 $i$ 上训练图像，并将所选择的（NMS）提案作为训练样本，将它们的过滤分数作为1D特征，并使用训练图像注释检查其标签（有关评估标准，请参阅第4节）。- 讨论：如图1d所示，学习的线性模型w（参见实验设置的第4节）看起来类似于假设为灵长类动物的生物似然结构的多尺寸中心包围模式[27,38,54]。 沿着边界的大的权重有利于将物体（中心）与其背景（包围）分开的边界。 与手动设计的中心环绕模式[36]相比，我们学到的w捕获更复杂更自然的前景。 比如，低层面的对象相对于高层面的部分要更加阻塞。也就表示模型w中会给予低层次的对象更低的置信度。 3.3 二值化梯度幅值(BING) 为了能够利用二值化近似模型[28,59]中的优点，我们提出了一个NG特征的加速版，二值化赋范梯度，加速特征提取和测试过程。我们学习的线性模型w∈R64可以通过算法1近似表示为一系列基向量的组合 $ w ≈ \sum_{j=1}^{N_w} \beta_j \alpha_j$ 。 其中 $N_w$ 表示基向量的个数， $\alpha_j∈{ -1,1 }^{64}$ 表示基向量， $\beta_j∈R$ 表示校准系数。 $\alpha_j$ 可以进一步表示为二值向量和它的补： $\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$ , 其中 $\alpha_j^+∈{ 0,1 }^{64}$ ,由 $α$ 二值化之后得到的 $b$ 可以被直接用于测试，而且只需要按位与和字节统计操作[28] $$&lt; w,b &gt; ≈ \sum_{j=1}^{N_w}\beta_j(2&lt; \alpha_j^+,b&gt;-|b|) (4)$$ 关键过程就是如何二值化以及有效的计算NG特征。我们近似采用梯度幅值（以及转化为01字节）的前Ng位来作二值化。因此，64维 NG特征 $g_l$ 值可以通过前Ng位二值化梯度幅值(BING)近似表示为： $$gl≈ \sum{k=1}^{Ng}2^{8-k}b{k,l} (5)$$ Figure 2 变量说明：BING特征 $b{x,y}$ ,它的最后一行是 $r{x,y}$ ，最后一个元素 $b_{x,y}$ 。注意出现在式(2)和式(5)中的下标 $i, x, y, l, k,$ 这些是定位整个向量而不是向量元素的索引。我们可以用一个简单的原子变量(INT64和BYTE)表示BING特征和它的最后一行，这样能够更有效的进行特征计算。 注意：这些BING特征拥有不同的权重，依据它原本不同的字节位。获取8 8的BING特征一般需要遍历64位，依据8 8 BING特征的两个特征，我们提出了一个快速的特征计算方法，能够只使用一些简单的原子操作（按位或和按位移动）避免循环计算。 第一，BING特征 $b{x,y}$ 以及它的最后一行 $r{x,y}$ 可以存储在一个简单的INT64和一个BYTE变量中；第二，相邻的BING特征以及他们的行之间拥有一个简单的累积关系。如图2，将 $r{x-1,y}$ 按位移动1位，这1位将自动进位到 $r{x,y}$ ，插入 $b{x,y}$ 的过程可以用按位或来实现。同样，将 $b{x-1,y}$ 按位移动8位，这8位将自动进位到 $b{x,y}$ ，自动插入 $r{x,y}$ 。 我们的BING特征有效的利用了整体图像之间的累积性质[52]。与之前的方法在任意矩形范围内计算一些值不同的是，我们采用一些原子操作在一个固定8 * 8大小范围内计算一系列二进制模式。 一个图像窗口对应的BING特征 $b_{k,l}$ 的过滤器得分,见式(1),可以表示为： $$sl≈ \sum{j=1}^{N_w}\betaj\sum{k=1}^{Ng}C{j,k} (6)$$ 其中， $C_{j,k} = 2^{8-k}(2&lt; \alphaj^+,b{k,l}&gt;-|b_{k,l}|)$ 可以通过一些快速的按位操作以及SSE指令操作计算得到。 实现细节：我们使用一维的标识[-1,0,1]，来定义水平方向和垂直方向上的图像梯度 $g_x$ 和 $g_y$ ，当计算梯度幅值是采用 $min(|g_x|+|g_y|,255)$ ,然后将其存入一个BYTE中。 4.实验评估 我们在VOC2007数据集上实验评估了我们的方法，使用的是DR和WIN的评估标准，与3个现存最先进的方法建议质量、通用性以及效率上做了对比。正如[3,48]，一系列高检测率的粗糙集对于有效对象检测是足够了的，，而且它允许使用复杂的特征和补充线索来得到比传统方法更好的质量和更高的效率。在对比试验中，我们采用的对应作者公布的实现方式和建议的参数设置。 Figure 3 不同方法关于#WIN和DR的权衡曲线。我们的方法使用1000建议窗口，达到了96.2%DR，使用5000个建议窗口可以达到99.5DR.其他三个方法我们采用了相同的评估标准，可以看出来优于一些其他的方法[6,21,25,30,50]，显著性测量[33，36]，特征点检测[44]以及HOG检测[17]. 建议质量对比：参照[3,48,57]，我们在数据集VOC2007上采用DR-WIN评估测试集，该数据集包含4952张20个类别的带有边框注释图像。数量巨大，种类繁多，视角、尺度、位置、阻塞、光照等都有不同，这些特点非常符合我们识别所有对象的要求。图3展示了数据统计对比，对比的方法有：OBN[3]，SEL[48]，以及CSVM[57]。正如[48]，通过收集不同参数设置下的结果，可以增加建议窗口的离散度，也能提高检测率DR，当然也需要提高建议窗口的数量（#WIN）。SEL[48]组合了80个不同参数设置的结果，达到了99.1%的DR和使用了10000多个建议窗口。我们的方法达到99.5%的DR，但只需要5000个建议窗口，而且仅仅收集了3个颜色空间的结果（RGB，HSV，GRAY）。如同DR-#WIN数据分析展示的那样，我们简单的方法在总体上达到了更好的效果，速率上比最流行的的方法[3,22,48]提升了3个数量级（见表格1），我们举例阐述了一些不同复杂度下的结果，如图4. 通用性测试：参照[3]，为了证明我们的方法具有通用性，采用包含未训练类别的对象图像进行测试。我们采用6个类别的对象训练我们的方法，通过剩下的14个类别进行测试。图3中，训练和测试是通过BING和BING-generic表示的。正如我们看到了那样，两个曲线基本一致，证明了我们方法的通用性。 最近的工作[18]能够在20秒内检测100000对象类别，主要采用的是减低传统多类别计算复杂度从O(LC)到O(L),L表示推荐窗口的数量，C表示分类器的数量。我们的方法可以得到任意类别（训练过的以及未训练的）的高质量的推荐窗口，可以通过减小L来显著减少计算复杂度。 计算时间：见表1，我们的方法可以在300fps的视频中，提供高效率的提供高质量的对象窗口，其他的方法对一张图片都需要几秒。这些方法通常是作为现存最先进的算法，而且很难大幅度的提升速度。我们在2501张图片上的训练需要很少的时间（包括加载XML文件，总共20S），而现有的先进的方法[6,21]测试一张图片通常需要多于2分钟. Table 1 在VOC2007上的平均计算时间 如表2，通过采用二进制近似的方法学习线性过滤器和BING特征提取，计算每个图像窗口的得分只需要一些原子操作。 Table 2 用于计算不同阶段每个图像窗口的对象的平均原子操作数：计算规范梯度，提取BING特征，并获得对象分数。 在每个标准化的尺度和纵横比下，定位的数量相当于O（N），N代表图像中的像素数.因此，在所有尺寸和纵横比的图像中，计算得分的复杂度也是O(N)。在每一个潜在的位置上，提取BING特征和计算得分可以利用它邻近的2个位置(例如：左和上)。这意味着空间复杂度也是O(N)。我们在同一个Intel i7-3940XM CPU上，对比其他基准方法[3,2，，48,57]的运行时间。 如表3，我们可以进一步意识到，不同的近似对结果质量的影响，通过对比我们在其他试验中采用Nw=2，Ng=4. Table 3 在不同近似层下的，平均检测结果（DR，使用1000个建议窗口），控制（Nw和Ng），N/A表示没有近似。 Figure 4 在VOC2007上的真实的测试样例。 5.结论以及将来的工作 我们呈现了一个非常简单，快速而且高质量的objectness方法，通过采用BING特征，计算任意尺度和纵横比的图像窗口中，我们仅仅需要一些原子操作（加，按位等）。通过最广泛的基准（VOC2007）和DR-#WIN评估标准进行结果评价，结果表明，与其他现存先进方法[3,22,48]相比，我们的方法不仅表现突出，而且速度上提升了3个数量级。 局限性： 与其他objectness方法[3,57]和滑动窗口[17,25]一样，我们都预测了一系列的对象矩形边框，因此，也有相似的局限性，对于一些类别的对象，一个矩形框并不能很好的集中实体，以便用来进行区域分割[6,21,33,45]，例如蛇。 进一步的工作：由于我们的方法具备高质量以及高效率的特性，所以它很适合实时多类别的对象检测和大规模图像收集应用程序（如：ImageNet[19]）。由于使用的简单的二进制操作，而且空间效率高，使得我们的方法可以在普通的设备上运行[28,59]。 我们的加速策略主要是减少窗口数量，这个可以通过其他的加速技术（通常旨在减少分类时间）来实现。将我们的方法和[18]的方法的进行组合将是很有趣的这样能够在一个机器上实时检测数以千计类别的对象。我们的方法解决了基于对象检测方法[53]的效率屏障，使得能够进行实时的高质量的对象检测。 通过使用简单的BING特征，我们能够使用一小部分（1000）的建议窗口得到涵盖几乎（96.2%）所有的对象区域。引入新的线索进一步降低建议窗口的数量，以便维持高效率的对象检测，以及在更多的应用程序[9]上使用BING特征，将是很值得研究的。]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Jetson TX1 系列开发教程之一：开箱测试]]></title>
    <url>%2F2017%2F10%2F01%2Ftx-1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 嵌入式平台：NVIDIA Jetson TX1 嵌入式系统：Ubuntu16.04 编者: WordZzzz 1. 概述 &#160;&#160;&#160;&#160;NVIDIA的Jetson TX1是嵌入式系统级模块（SoM），具有四核ARM Cortex-A57，4GB LPDDR4和集成的256核Maxwell GPU。 &#160;&#160;&#160;&#160;对于部署计算机视觉和深度学习而言非常有用，Jetson TX1运行Linux(定制Ubuntu)，并提供1TFLOPS的FP16计算性能，功耗为10瓦。 &#160;&#160;&#160;&#160;Jetson TX1可作为模块，开发套件和兼容的生态系统产品。更多详细信息可以登录NVIDIA官网（此处有链接）进行了解，也可通过Wikipedia（此处有链接）进行TX1模组参数的快速预览。 2. 基本参数 处理组件： 四核ARM Cortex-A57 256核Maxwell GPU 4GB LPDDR4 16GB eMMC H.264 / H.265编码器和解码器 双ISP（图像服务处理器） 端口和外设： HDMI 2.0 802.11ac WiFi，蓝牙4.0 USB3，USB2 千兆以太网 12路MIPI CSI 2.0 4车道PCIe gen 2.0 SATA，2x SD卡 3x UART，3x SPI，4x I2C 构成因素： 400针Samtec板对板连接器 尺寸：50x87mm （1.96“x 3.42”） 质量：45克 热转印板（TTP），-25C至85C工作温度 5.5-19.6VDC输入功率（消耗10-15W，典型负载下） 软件支持： JetPack 2.3 Linux4Tegra R24.2 (L4T) for ARM (Ubuntu 16.04 aarch64) CUDA Toolkit 8 cuDNN v5.1 TensorRT 1.0 VisionWorks 1.5 OpenCV4Tegra 2.4.13 OpenGL 4.4 OpenGL ES 3.1 Vulkan V4L2 media controller support gstreamer / OpenMAX Tegra System Profiler (TSP) Tegra Graphics Debugger PerfKit 4.5.1 3. 开箱测试 &#160;&#160;&#160;&#160;小五千大洋买回来的宝贝，拿到手还有点小激动（图片来自我的partner：Jack Cui）： &#160;&#160;&#160;&#160;包装很高大上，下面来介绍一下开发套件的内容：TX1开发套件（含TX1模组）、一个19V电源适配器（尴尬的是没有插座线）、两个天线（用于TX1模组的WiFi和蓝牙）、Micro USB线和USB-OTG线。 &#160;&#160;&#160;&#160;光有上面这些开发套件包含的东西是不能正常使用的，你还需要下面这些设备： 电源适配器插头： 2K显示屏：（开发套件原装系统默认分辨率为2K）。 &#160;&#160;&#160;&#160;这里有点尴尬，除非你能保证你可以在没有显示器的情况下就能输入命令行修改分辨率（想办法调出命令行然后输入：xrandr -s 1208x720），否则还是找一块2K显示屏来吧。 鼠键套装： 4.调出桌面： 123cd ~/NVIDIA-INSTALLsudo ./install.shsudo reboot now &#160;&#160;&#160;&#160;重启电脑之后，我们就可以看到ubuntu系统的桌面了。Jetson TX1出厂时默认的系统以及各依赖工具版本比较老旧，所以我们需要进行刷机来部署最新版本的JetPack。 &#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何进行刷机。&#160;&#160;&#160;&#160;下周日更新。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：sorted()函数及列表中的sort()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 一、sort，sorted函数介绍： &emsp;&emsp;Sort函数是list列表中的函数，而sorted可以对list或者iterator进行排序。 &emsp;&emsp;下面我们使用help来查看他们的用法及功能：sort： 12345&gt;&gt;&gt; help(list.sort)Help on method_descriptor:sort(...) L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* sorted：Python3.x:12345678&gt;&gt;&gt; help(sorted)Help on built-in function sorted in module builtins:sorted(iterable, /, *, key=None, reverse=False) Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. Python2.x: 12345&gt;&gt;&gt; help(sorted)Help on built-in function sorted in module __builtin__:sorted(...) sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list &emsp;&emsp;好吧，Python3.x和Python2.x的sorted函数有点不太一样，少了cmp参数。下面本渣渣主要基于Python2.x的sorted函数进行讲解，Python3.x直接忽略cmp这个参数即可，为了保证代码通用性，不建议大家在今后的编程中使用cmp参数。 二、sort和sorted的比较： &emsp;&emsp;用sort函数对列表排序时会影响列表本身，而sorted不会。举例： 123456789&gt;&gt;&gt; a = [1,2,1,4,3,5]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 1, 2, 3, 4, 5]&gt;&gt;&gt; a = [1,2,1,4,3,5]&gt;&gt;&gt; sorted(a)[1, 1, 2, 3, 4, 5]&gt;&gt;&gt; a[1, 2, 1, 4, 3, 5] &emsp;&emsp;Python2.x的sorted函数：sorted(iterable，cmp，key，reverse）参数： iterable可以是list或者iterator； cmp是带两个参数的比较函数； key 是带一个参数的函数； reverse为False或者True； 举例说明:（1）用cmp函数排序: 12345&gt;&gt;&gt; list1 = [('david', 90), ('mary',90), ('sara',80),('lily',95)]&gt;&gt;&gt; sorted(list1,cmp = lambda x,y: cmp(x[0],y[0]))[('david', 90), ('lily', 95), ('mary', 90), ('sara', 80)]&gt;&gt;&gt; sorted(list1,cmp = lambda x,y: cmp(x[1],y[1]))[('sara', 80), ('david', 90), ('mary', 90), ('lily', 95)] （2）用key函数排序: 12345&gt;&gt;&gt; list1 = [('david', 90), ('mary',90), ('sara',80),('lily',95)]&gt;&gt;&gt; sorted(list1,key = lambda list1: list1[0])[('david', 90), ('lily', 95), ('mary', 90), ('sara', 80)]&gt;&gt;&gt; sorted(list1,key = lambda list1: list1[1])[('sara', 80), ('david', 90), ('mary', 90), ('lily', 95)] （3）用reverse排序: 12&gt;&gt;&gt; sorted(list1,reverse = True)[('sara', 80), ('mary', 90), ('lily', 95), ('david', 90)] （4）用operator.itemgetter函数排序: 12345&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted(list1, key=itemgetter(1))[('sara', 80), ('david', 90), ('mary', 90), ('lily', 95)]&gt;&gt;&gt; sorted(list1, key=itemgetter(0))[('david', 90), ('lily', 95), ('mary', 90), ('sara', 80)] &emsp;&emsp;介绍operator.itemgetter函数: 12345&gt;&gt;&gt; import operator&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = operator.itemgetter(0)&gt;&gt;&gt; b(a)1 &emsp;&emsp;operator.itemgetter函数获取的不是值，而是定义了一个函数。 （5）多级排序: 12&gt;&gt;&gt; sorted(list1, key=itemgetter(0,1))[('david', 90), ('lily', 95), ('mary', 90), ('sara', 80)] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>sort</tag>
        <tag>sorted</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 搭建Python开发环境 码代码 美如画]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-7%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：Sublime Text 3 Build 3143 编&emsp;&emsp;者：WordZzzz 前言&emsp;&emsp;Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的 Vim ，浮肿沉重的 Eclipse ， VS ，即便体积轻巧迅速启动的 Editplus 、 Notepad++ ，在 Sublime Text 面前也略显失色，无疑这款性感无比的编辑器是 Coding 和 Writing 最佳的选择，没有之一。 &emsp;&emsp;Sublime Text 3 的功能实在是太强大了，搭配各种 package ，码代码、美如画。对于 Sublime Text 3 的介绍网上一大堆，博主就不再这里赘述了。本篇博文主要是记录一下博主如何在 Sublime Text 3 下优雅的编写、编译、运行 python 代码。 安装&emsp;&emsp;WordZzzz使用的版本是 Sublime Text Build 3143 ，大家自行下载后直接安装即可，安装完之后需要 License 来激活我们的软件。 &emsp;&emsp;直接将下面的 License 复制过去就好，亲测可用： 12345678910111213—– BEGIN LICENSE —– TwitterInc 200 User License EA7E-890007 1D77F72E 390CDD93 4DCBA022 FAF60790 61AA12C0 A37081C5 D0316412 4584D136 94D7F7D4 95BC8C1C 527DA828 560BB037 D1EDDD8C AE7B379F 50C9D69D B35179EF 2FE898C4 8E4277A8 555CE714 E1FB0E43 D5D52613 C3D12E98 BC49967F 7652EED2 9D2D2E61 67610860 6D338B72 5CF95C69 E36B85CC 84991F19 7575D828 470A92AB —— END LICENSE —— 配置Package Control&emsp;&emsp;按 Ctrl+` 调出 console ，粘贴以下代码到底部命令行并回车： 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) &emsp;&emsp;重启 Sublime Text 3。如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功。按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 &emsp;&emsp;下面介绍几个比较实用的 package 。 SideBarEnhancements&emsp;&emsp;SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率。诸如 “New file” 和 “Duplicate” 这样的选项对于 ST3 来说实在是太重要了，而且仅凭 “Delete” 这一个功能就让这个插件值得下载。这个功能将你会在你删除文件的时候把它放入回收站。虽然这个功能乍一看没什么用，但是当你没有使用这样的功能而彻底删除了一个文件的时候，除非你用了版本管理软件，否则你将很难恢复这个文件。 Anaconda&emsp;&emsp;Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如： Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。 Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。 McCabe code complexity checker 让你可以在特定的文件中使用 McCabe complexity checker. Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) &emsp;&emsp;但是，刚安装完之后，打开一个 python 文档，所有代码都会被白色细线框中，如图所示； &emsp;&emsp;强迫症的我看着好难受，决心要搞一搞这东西。后来发现在 Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – Default 下修改 linting behaviour 选项即可，我这里改成了只有在保存的时候linting工作。 12345678/* Sets the linting behaviour for anaconda: &quot;always&quot; - Linting works always even while you are writing (in the background) &quot;load-save&quot; - Linting works in file load and save only &quot;save-only&quot; - Linting works in file save only*/&quot;anaconda_linting_behaviour&quot;: &quot;save-only&quot;, SublimeREPL&emsp;&emsp;这可能是对程序员来说最有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ，Python，Ruby， Scala 和 Haskell 等等）。 &emsp;&emsp;在 Sublime &gt; Tools &gt; SublimeREPL 下我们可以看到 SublimeREPL 支持运行的所有语言。 &emsp;&emsp;下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Default.sublime-commands 文件，从中我们可以看到 SublimeREPL 所支持的 python 的各种运行方式。 1234567891011121314151617181920212223242526272829303132333435363738[ &#123; &quot;caption&quot;: &quot;SublimeREPL: Python&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, &#123; &quot;caption&quot;: &quot;SublimeREPL: Python - PDB current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python_pdb&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, &#123; &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python_run&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, &#123; &quot;command&quot;: &quot;python_virtualenv_repl&quot;, &quot;caption&quot;: &quot;SublimeREPL: Python - virtualenv&quot; &#125;, &#123; &quot;caption&quot;: &quot;SublimeREPL: Python - IPython&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python_ipython&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;] &emsp;&emsp;接下来配置快捷键，打开 Sublime &gt; Preferences &gt; Key Building ，在右侧栏（ User 部分）添加下面的代码。下面的代码用 F5 来执行当前 Python 脚本，用 F4 来实现切换至 Python 命令行窗口。 12345678910111213[ &#123;&quot;keys&quot;:[&quot;f5&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python_run&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125; , &#123;&quot;keys&quot;:[&quot;f4&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;] &emsp;&emsp;当然，如果你电脑里面安装了两个版本的 Python ，而你想指定使用某个版本，则需要修改下面的代码。下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Main.sublime-menu 文件，主要修改 “cmd” 后面跟着的 python 命令。比如我电脑里 python2.7 的执行程序命名是 python.exe ，而 python3.6 的执行程序命名为 python3.exe ，我想要使用 python3 ，所以把所有 “cmd” 后面跟着的命令都改为 “python3” 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[ &#123; &quot;id&quot;: &quot;tools&quot;, &quot;children&quot;: [&#123; &quot;caption&quot;: &quot;SublimeREPL&quot;, &quot;mnemonic&quot;: &quot;R&quot;, &quot;id&quot;: &quot;SublimeREPL&quot;, &quot;children&quot;: [ &#123;&quot;caption&quot;: &quot;Python&quot;, &quot;id&quot;: &quot;Python&quot;, &quot;children&quot;:[ &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python&quot;, &quot;id&quot;: &quot;repl_python&quot;, &quot;mnemonic&quot;: &quot;P&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;], &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python&quot;, &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125; &#125; &#125;, &#123;&quot;command&quot;: &quot;python_virtualenv_repl&quot;, &quot;id&quot;: &quot;python_virtualenv_repl&quot;, &quot;caption&quot;: &quot;Python - virtualenv&quot;&#125;, &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python - PDB current file&quot;, &quot;id&quot;: &quot;repl_python_pdb&quot;, &quot;mnemonic&quot;: &quot;D&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;, &quot;-m&quot;, &quot;pdb&quot;, &quot;$file_basename&quot;], &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python&quot;, &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125; &#125; &#125;, &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python - RUN current file&quot;, &quot;id&quot;: &quot;repl_python_run&quot;, &quot;mnemonic&quot;: &quot;R&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;], &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python&quot;, &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125; &#125; &#125;, &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python - IPython&quot;, &quot;id&quot;: &quot;repl_python_ipython&quot;, &quot;mnemonic&quot;: &quot;I&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;autocomplete_server&quot;: true, &quot;cmd&quot;: &#123; &quot;osx&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;], &quot;linux&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;], &quot;windows&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;] &#125;, &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python&quot;, &quot;extend_env&quot;: &#123; &quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;, &quot;SUBLIMEREPL_EDITOR&quot;: &quot;$editor&quot; &#125; &#125; &#125; ]&#125; ] &#125;] &#125;] &emsp;&emsp;别忘了， Sublime Text 3 也有自己的 build 功能，即也支持 python 等语言的代码构建（ ctrl + b ）。同样的，我们如何添加不同的 python 版本到我们的构建系统呢？很简单，Sublime &gt; Tools &gt; Build System &gt; New Build System，分别添加如下代码之后，再分别保存为 python2.sublime-build 和 python3.sublime-build ，这样，当我们再次打开 Sublime &gt; Tools &gt; Build System 之后，就会发现我们新添加的 python2 和 python3 构建系统了。 12345&#123; &quot;cmd&quot;: [&quot;D:/Program Files/Python/Python27/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;&#125; 12345&#123; &quot;cmd&quot;: [&quot;D:/Program Files/Python/Python36/python3.exe&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;&#125; SublimeTmpl&emsp;&emsp;快速生成文件模板 &emsp;&emsp;，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。 &emsp;&emsp;SublimeTmpl默认的快捷键: 123456ctrl+alt+h htmlctrl+alt+j javascriptctrl+alt+c cssctrl+alt+p phpctrl+alt+r rubyctrl+alt+shift+p python &emsp;&emsp;这里我想修改一下python模板，所以就需要进行如下操作：Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl &gt; Settings – User 添加如下代码。然后 ctrl+alt+shift+p 来新建一个模板试试看。 123456789&#123; &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot; &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;, &quot;attr&quot;: &#123; &quot;author&quot;: &quot;WordZzzz&quot;, &quot;email&quot;: &quot;wordzzzz@foxmail.com&quot;, &quot;link&quot;: &quot;http://blog.csdn.net/u011475210&quot; &#125; &#125; &emsp;&emsp;快捷键也是可以更改的，全部在 Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl 的设置中。 &emsp;&emsp;如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就不详细介绍了，请各位自己折腾哈~ 快捷键 跳转到任意内容 (“cmd+p”) 用来快速查找和打开文件。你仅仅只需要工程中文件的一部分路径或者文件名你就可以很容易的打开这个文件。这在一个大型的 Django 工程中显得非常方便。 跳转到指定行 (“ctrl+g”) 让你在当前文件中跳转到指定行数。 跳转到标志 (“cmd+r”) 可以列出当前文件中所有的函数或者类，让你更方便查找。你可以通过输入关键字来查找你所需要的函数或者类。 跳转到行首 (cmd+left-arrow-key) 与 跳转到行尾 (cmd+right-arrow-key) 删除当前行(ctrl+shift+k) 多重编辑 是我迄今为止最喜欢的快捷键选定一个单词，点击 “cmd+d”来选择同样的单词，再次点击 “cmd+d”*继续选择下一个单词…或者 “cmd+单击”来指定多个你想要同时修改的地方。 块编辑 (option+left-mouse-click) 用于选择一整块的内容。通常在整理 CSV 文件的时候用于删除空白内容。 自定义命令&emsp;&emsp;你可以很容易地使用 Python 来编辑你自己的自定义命令和快捷键组合。例如： 拷贝当前文件路径到剪贴板 – 链接 关闭除当前活动标签页以外的所有其他标签页 – 链接 &emsp;&emsp;通过文件选项打开你的 Package 文件夹(Sublime &gt; Preferences &gt; Browse Packages)，然后打开 User 文件夹，接下来将上述的 Python 文件添加到 “/Sublime Text 3/Packages/User” 文件夹中。 &emsp;&emsp;最后请在 Key Bindings – User file (Sublime Text &gt; Preferences &gt; Package Settings &gt; AdvancedNewFile &gt; Key Bindings – User) 文件中完成快捷键绑定。 123456789101112[ // Copy file name &#123; &quot;keys&quot;: [&quot;cmd+shift+c&quot;], &quot;command&quot;: &quot;copy_path_to_clipboard&quot; &#125;, // Close all other tabs &#123; &quot;keys&quot;: [&quot;cmd+alt+w&quot;], &quot;command&quot;: &quot;close_tabs&quot; &#125;] 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：字典中的items()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-6%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz 一、Python2.x中items()： &emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息： 12345&gt;&gt;&gt; help(dict.items)Help on method_descriptor:items(...) D.items() -&gt; list of D's (key, value) pairs, as 2-tuples 12345&gt;&gt;&gt; help(dict.iteritems)Help on method_descriptor:iteritems(...) D.iteritems() -&gt; an iterator over the (key, value) items of D 12345&gt;&gt;&gt; help(dict.viewitems)Help on method_descriptor:viewitems(...) D.viewitems() -&gt; a set-like object providing a view on D's items &emsp;&emsp;在Python2.x中，items( )用于 返回一个字典的拷贝列表【Returns a copy of the list of all items (key/value pairs) in D】，占额外的内存。 &emsp;&emsp;iteritems() 用于返回本身字典列表操作后的迭代【Returns an iterator on all items(key/value pairs) in D】，不占用额外的内存。 1234567&gt;&gt;&gt; d=&#123;1:'one',2:'two',3:'three'&#125;&gt;&gt;&gt; type(d.items())&lt;type 'list'&gt;&gt;&gt;&gt; type(d.iteritems())&lt;type 'dictionary-itemiterator'&gt;&gt;&gt;&gt; type(d.viewitems())&lt;type 'dict_items'&gt; 二、Python3.x中items()： 12345&gt;&gt;&gt; help(dict.items)Help on method_descriptor:items(...) D.items() -&gt; a set-like object providing a view on D's items &emsp;&emsp;Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。 123&gt;&gt;&gt; d=&#123;1:'one',2:'two',3:'three'&#125;&gt;&gt;&gt; type(d.items())&lt;class 'dict_items'&gt; 简单的例子： 123456d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59, 'Paul': 74 &#125;sum = 0for key, value in d.items(): sum = sum + value print(key, ':' ,value)print('平均分为:' ,sum /len(d)) 输出结果：123456D:\Users\WordZzzz\Desktop&gt;python3 test.pyAdam : 95Lisa : 85Bart : 59Paul : 74平均分为: 78.25 关于python3.x中items具体的应用，可以通过下面的传送门到达机器学习实战中找到： 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>items</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：operator模块中的itemgetter()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz &emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息： 123456789101112131415161718192021222324252627&gt;&gt;&gt; import operator&gt;&gt;&gt; help(operator.itemgetter)Help on class itemgetter in module operator:class itemgetter(builtins.object) | itemgetter(item, ...) --&gt; itemgetter object | | Return a callable object that fetches the given item(s) from its operand. | After f = itemgetter(2), the call f(r) returns r[2]. | After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) | | Methods defined here: | | __call__(self, /, *args, **kwargs) | Call self as a function. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | __reduce__(...) | Return state information for pickling | | __repr__(self, /) | Return repr(self). &emsp;&emsp;operator.itemgetter函数operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号），下面看例子。 1234567a = [1,2,3] &gt;&gt;&gt; b=operator.itemgetter(1) //定义函数b，获取对象的第1个域的值&gt;&gt;&gt; b(a) 2 &gt;&gt;&gt; b=operator.itemgetter(1,0) //定义函数b，获取对象的第1个域和第0个的值&gt;&gt;&gt; b(a) (2, 1) &emsp;&emsp;要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>itemgetter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：string中的split()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-5%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz Python2.x中split()函数：&emsp;&emsp;老规矩，help！ 1234567891011&gt;&gt;&gt; help(str.split)Help on method_descriptor:split(...) S.split([sep [,maxsplit]]) -&gt; list of strings Return a list of the words in the string S, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result. &emsp;&emsp;可以看出，在Python2.x中，split()返回的是字符串列表。 Python3.x中split()函数：&emsp;&emsp;同样，help！ 1234567891011&gt;&gt;&gt; help(str.split)Help on method_descriptor:split(...) S.split(sep=None, maxsplit=-1) -&gt; list of strings Return a list of the words in S, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result. &emsp;&emsp;啊哦，在Python3.x中，split()返回的也是字符串列表。 样例：1234567&gt;&gt;&gt; str = "this is string example....wow!!!"&gt;&gt;&gt; print (str.split( ))['this', 'is', 'string', 'example....wow!!!']&gt;&gt;&gt; print (str.split('i',1))['th', 's is string example....wow!!!']&gt;&gt;&gt; print (str.split('w'))['this is string example....', 'o', '!!!'] 加入正则表达式： 123456789101112&gt;&gt;&gt; mySent='This book is the best book on Python or M.L. I have ever laid eyes upon'&gt;&gt;&gt; mySent.split() #不带参数切分['This', 'book', 'is', 'the', 'best', 'book', 'on', 'Python', 'or', 'M.L.', 'I', 'have', 'ever', 'laid', 'eyes', 'upon']&gt;&gt;&gt; import re&gt;&gt;&gt; regEx = re.compile('\\W') #正则表达式，定义分隔符是除单词、数字外的任意字符串&gt;&gt;&gt; listOfTokens = regEx.split(mySent) #根据正则表达式的规则进行切分&gt;&gt;&gt; listOfTokens['This', 'book', 'is', 'the', 'best', 'book', 'on', 'Python', 'or', 'M', 'L', '', 'I', 'have', 'ever', 'laid', 'eyes', 'upon']&gt;&gt;&gt; [tok for tok in listOfTokens if len(tok) &gt; 0] #去掉空格['This', 'book', 'is', 'the', 'best', 'book', 'on', 'Python', 'or', 'M', 'L', 'I', 'have', 'ever', 'laid', 'eyes', 'upon']&gt;&gt;&gt; [tok.lower() for tok in listOfTokens if len(tok) &gt; 2] #全部小写，去掉长度小于3的单词['this', 'book', 'the', 'best', 'book', 'python', 'have', 'ever', 'laid', 'eyes', 'upon'] 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>split</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：numpy模块中的argsort()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz &emsp;&emsp;argsort函数是Numpy模块中的函数： 1234567891011&gt;&gt;&gt; import numpy&gt;&gt;&gt; help(numpy.argsort)Help on function argsort in module numpy.core.fromnumeric:argsort(a, axis=-1, kind='quicksort', order=None)Returns the indices that would sort an array.Perform an indirect sort along the given axis using the algorithm specifiedby the `kind` keyword. It returns an array of indices of the same shape as`a` that index data along the given axis in sorted order. &emsp;&emsp;从中可以看出argsort函数返回的是数组值从小到大的索引值 Examples： One dimensional array:一维数组123&gt;&gt;&gt; x = np.array([3, 1, 2])&gt;&gt;&gt; np.argsort(x)array([1, 2, 0]) Two-dimensional array:二维数组123456789101112&gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])&gt;&gt;&gt; xarray([[0, 3],[2, 2]])&gt;&gt;&gt; np.argsort(x, axis=0) #按列排序array([[0, 1],[1, 0]])&gt;&gt;&gt; np.argsort(x, axis=1) #按行排序array([[0, 1],[0, 1]]) Examples： 12345678910&gt;&gt;&gt; x = np.array([3, 1, 2])&gt;&gt;&gt; np.argsort(x) #按升序排列array([1, 2, 0])&gt;&gt;&gt; np.argsort(-x) #按降序排列array([0, 2, 1])&gt;&gt;&gt; x[np.argsort(x)] #通过索引值排序后的数组array([1, 2, 3])&gt;&gt;&gt; x[np.argsort(-x)]array([3, 2, 1]) 另一种方式实现按降序排序： 12345&gt;&gt;&gt; a = x[np.argsort(x)]&gt;&gt;&gt; aarray([1, 2, 3])&gt;&gt;&gt; a[::-1]array([3, 2, 1]) 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>argsort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3：input()函数]]></title>
    <url>%2F2017%2F10%2F01%2Fpy-1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：python-3.6.2-amd64 编&emsp;&emsp;者：WordZzzz Python2.x中range()函数：&emsp;&emsp;老规矩，help！ 123456789101112&gt;&gt;&gt; help(range)Help on built-in function range in module __builtin__:range(...) range(stop) -&gt; list of integers range(start, stop[, step]) -&gt; list of integers Return a list containing an arithmetic progression of integers. range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0. When step is given, it specifies the increment (or decrement). For example, range(4) returns [0, 1, 2, 3]. The end point is omitted! These are exactly the valid indices for a list of 4 elements. &emsp;&emsp;可以看出，在Python2.x中，range()返回的是可以用来迭代的列表。 Python3.x中range()函数：&emsp;&emsp;同样，help！ 123456789101112&gt;&gt;&gt; help(range)Help on class range in module builtins:class range(object) | range(stop) -&gt; range object | range(start, stop[, step]) -&gt; range object | | Return an object that produces a sequence of integers from start (inclusive) | to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. | start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. | These are exactly the valid indices for a list of 4 elements. | When step is given, it specifies the increment (or decrement). &emsp;&emsp;啊哦，在Python3.x中，range()返回的是一个range对象。 样例对比：Python2.x： 12&gt;&gt;&gt; range(1,10)[1, 2, 3, 4, 5, 6, 7, 8, 9] Python3.x： 1234&gt;&gt;&gt; range(1,10)range(1, 10)&gt;&gt;&gt; list(range(1,10))[1, 2, 3, 4, 5, 6, 7, 8, 9] &emsp;&emsp;通过list强制类型转换，可以在Python3.x中实现Python2.x中的range函数一样的效果。 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVPR2014 Objectness BING 源码详解]]></title>
    <url>%2F2017%2F10%2F01%2Fbing-2%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：VS2013+OpenCV2.4.13 编者: WordZzzz 一、样本生成：1.正样本&emsp;&emsp;算法首先对每张图像上可能的所有标注框采样,生成不同尺度（该尺度在一定经验值范围内）的样本位置，并计算新生成的正样本与原始样本重叠率，保留重叠率超过50%的，重新归一化到8 8大小，计算新生成的有效正样本的梯度特征，并在水平方向翻转，最终保存新生成样本8 8的梯度特征与该特征的水平翻转特征作为xP. 2.负样本&emsp;&emsp;固定100次随机产生100个备选的负样本窗口，筛选出与每张图片中，与所有目标的重叠率都小于50%的负样本窗，并将该窗口内保存图像作为负样本。 3.尺度处理&emsp;&emsp;在筛选有效正样本时，同时保存了水平，垂直尺度系数，但是实际保存的尺度是归一化映射后的值，即(h - min) * num + w - min + 1,其中h,w表示筛选出的有效正样本相对原始目标的垂直，水平尺度系数，实际上，还是保存的尺度系数，只是在数据结构上，采用哈希映射存储罢了。 4.判定有效样本&emsp;&emsp;程序下一步，会在上面采样生成的所有有效正样本，进行直方图统计，统计出每个尺度下的样本数。例如有2500多个图像文件，计算所有正样本数，统计每个尺度下的正样本数。根据统计结果，剔除掉正样本数少于50的尺度。保存剩下的尺度统计结果，接着，对所有正负样本，统一分配到一个二维矩阵，垂直表示样本数，水平表示样本的88梯度特征值，直接保存。以上，属于该算法的第一个亮点。&emsp;&emsp;算法主要是用来加速传统的滑动窗口对象检测，通过训练通用的对象估计方法来产生候选对象窗口。作者观察到一般对象都会有定义完好的封闭轮廓，而且通过将相关图像窗口重置为固定大小，就可以通过梯度幅值进行区分。基于以上的观察以及复杂度的考虑，为了明确训练方法，将窗口固定为88的，并将梯度幅值转化为一个简单的64维的特征来描述这个窗口。这就相当于我们看路上走的人一样，在很远的地方即使我们没看清楚脸，只是看到一个轮廓也能识别出是不是我们认识的人，反而，如果脸贴着脸去看一个人可能会认不出来。&emsp;&emsp;也就是作者发现，在固定窗口的大小下，物体与背景的梯度模式有所不同。如下图所示。图（a）中绿框代表背景，红框代表物体。如果把这些框都resize成固定大小，比如8X8，然后求出8X8这些块中每个点的梯度（Normed Gradient，简称NG特征，叫赋范梯度特征，就是计算梯度范数，即!$\sqrt{(g_x^2 + g_y^2)}$,实际就是该点的L2范数梯度，但是作者实现时，采用-1,0,1方式计算gx或者gy,因此，用|gx| + |gy|近似代替梯度的L2范数），可以明显看到物体与背景的梯度模式的差别，如图1（c）所示，物体的梯度分布呈现出较为杂乱的模式，而背景的较为单一和清楚。其实这个道理很浅显，就是图像中背景区域往往呈现出homogeneous的特性，早期的图像区域分割方法就是依靠这种特性来做的。然后我个人觉得这里不一定要用梯度，用其他一些统计特征甚至是图像特征都有可能得到类似的结果。&emsp;&emsp;所以，作者首先将所有的标注样本，用不同尺度缩放采样，将采样出的有效正样本统一缩放到8 8，计算NG特征，也就是下面图中a生成c在过程。这样，通过SVM训练这些NG特征，得到目标和背景的第一次区分模型。&emsp;&emsp;下面是原文的解释&emsp;&emsp;对象一般是具有很好定义封闭轮廓和中心的。重置窗口的时候，就相当于将现实中的对象缩小到一个固定大小，因为在封闭的轮廓中，图像梯度变化很小，所以它是一个很好的可区分特征，就像是图1中，轮船和人在颜色，形状，纹理，光照等方面都有很大的不同，他们在梯度空间都存在共性。为了有效地利用观察结果，我们首先将输入图像重置为不同尺度的，在不同的尺度下计算梯度。然后再重置为取8 8大小的框，作为一个对应图像的64维的NG特征。我们采用的NG特征，是一个密集的且紧凑的objectness特性，有以下几点优势：首先，由于归一化了支持域，所以无论对象窗口如何改变位置，尺度以及纵横比，它对应的NG特征基本不会改变。也就是说，NG特征是对于位置，尺度，纵横比是不敏感的，这一点是对于任意类别对象检测是很有用的。 &emsp;&emsp;图1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。这种不敏感的特性是一个好的对象检测方法应该具备的。第二，NG特征的紧凑性，使得计算和核实更加有效率，而且能够很好的应用在实时应用程序中。NG特征的缺点就是识别能力不够。但一般而言，会采用检测器来最终缺点结果的误报率。 二、两级SVM训练：1.SVM第一级训练&emsp;&emsp;首先，算法传递进入第一级SVM的样本总数，在超过SVM默认参数值时，采用SVM默认训练总样本数。用所有正样本以及剩下的数量采用随机从原负样本中抽取。即，负样本在这种情况下，不是全部参加SVM第一级训练。而是随机抽取一部分，保证总样本数达到SVM默认训练总样本数。&emsp;&emsp;算法做一些SVM的初始化，涉及到样本标签Y，实际上，正样本默认都为有标签，以及SVM参数初始化等。&emsp;&emsp;通过第一级SVM训练后，算法生成第一级SVM模型，转换成8 * 8，并归一化到1~255，保存。该模型w是用来下文中投票打分的，为第二级SVM学习做准备。 2.二值化模型参数w&emsp;&emsp;首先通过上面的训练，我们可以得到分类的模型线性w，第一个要二值化的目标就是它，二值化的思想可以简单想象成找若干个基向量，并用这些基向量的线性组合来记表示w， 而且这些基向量的每一维只能取1或者-1（二值嘛）。那么假设我们用了Nw个基向量，每个基向量为aj, j = 1,…,Nw，那么就有!$ w ≈ \sum_{j=1}^{N_w} \beta_j \alpha_j$。具体模型的二值化近似可以按如下算法1的步骤进行： &emsp;&emsp;算法1的步骤也很明确，每一个都生成一个基向量，此基向量每一维都是由当前残差的符号决定，然后用当前残差减去残差在这基向量的投影（相当于去掉模型在这一维上的分量）。但在计算中因为二进制位只能为0或者1，所以为了处理方便，取：$\alpha_j^+∈{ 0,1 }^{64}$,那么就可以将基向量表示为$\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$。即基向量二进制与该二进制表示的补。&emsp;&emsp;也就是说，αj表示基向量{-1,1}，βj表示校准系数，同时，将每个基向量，映射到一个64位类型的数据中。这里，实际上采用Gram-Schmidt正交化，只取了包含大部分信息的前Nw个正交向量作为输出，目的也是为了降低计算量。二值化的目的在于后期位运算，后面还会把NG特征也二值化。直接采用硬件指令大幅度地提升速度。&emsp;&emsp;代码中，Nw取2，也就是SVM生成的W 是8 * 8矩阵，矩阵元素任意值，通过这个二值化过程，生成2个基向量，每个基向量完全覆盖了W中每个元素，但是此时在基向量中，每个元素对应的取值变成0或者1，因此，原w的64个元素，拼接成了一个64位的单个数据，即基向量。同时，对应该基向量的校准系数，算法为了后期加速，只近似处理高4位的数据，因此，校准系数只有保存4个，且都是一样的值，但是由于后期位移运算，这里就把校准值放置到了对应bit位。于是，2个基向量，生成8个校准系数，2个64位的数据。 3.打分窗口&emsp;&emsp;为了找到图像中的一般对象，对每张训练图像（注意，这里是原图像，不是标注框），进行上文生成正样本时得到所有尺度的量化，扫描每个尺度定义好的量化窗口（依据尺度或者是纵横比，也就是说，这里只是对原图像依据之前尺度系数做缩放，不是缩放到8 * 8,因此，才有下文的I）。每一个窗口通过上文得到模型w获得得分 $$s_l = &lt; w,g_l &gt;(1)$$ $$l = &lt; i,x,y &gt;(2)$$&emsp;&emsp;$s_l$ 代表过滤器得分， $g_l$ 代表NG特征， $l$表示坐标， $i$表示尺度， $(x,y)$表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 100），一些尺度（例如:10 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）： $$o_l = v_i · s_l + t_i (3)$$ &emsp;&emsp;只需要按位与和字节统计操作.下面解释如何得到b.因此，为了实现（1）的快速计算，作者先用上面的算法，二值化了w,现在开始二值化NG，即gl参数，得到上面的b. &emsp;&emsp;接下来我们还要对NG特征进行二值化，还记得我们刚才将NG归一化到[0,255]之间吧，那么8 * 8窗口上的每个点的NG特征值就可以用一个byte来存储，也就是每个值我们都可以用一个8位的二进制串来表示。那么我们就有一个8X8X8的三维矩阵，前两维是窗口位置（行，列），第三维是在二进制串中的位置（页）。举个例子，比如窗口中第1行，第2列的NG特征值是192，换成二进制就是1100 0000，那么矩阵的元素（1,2,1） = （1,2,2）= 1，（1,2,3），…,（1,2,8）= 0;那么我们一页一页地将矩阵元素取出来，再将每页8X8的矩阵元素排成一个64位的二进制串并存进一个int64里。既然思路已经有了，做法也就很简单了：对于每一页，将每一行每个元素取出来，不断加入int64中并左移1位，最后得到那个int64每一位对应的元素坐标排列就应该是（1,1）（1,2）（1,3）…(8,8)。然后作者在这里又玩了一个trick，他说你这样每次移动一位不是要循环64次嘛，如果先将8个拼成一组（就是刚才那样左移1次），那么只需要移动8组就好了啊！而且，这样在相邻的窗口中还能重用重叠的部分（在VS2010 的Debug模式下我试了下，1个数“每次左移1位，移动1万次”和“每次左移100位，移动100次”两种情况，的确是后者速度快）。最后，为了进一步节省存储空间，还可以只取NG值的高位来作二值化。因为比如192和193、194，它们的二进制表达分别是1100 0000， 1100 0001和 1100 0010，要是我只看前面4位，后面4位忽略（取0）的话，那么它们的取值都是192。也就是我们可以用192来约等于193和194，这样我们就不需要用到8位那么多了！写成公式就是下面的式（2）这样，其中Ng 是我们要用的高位的位数（也就是前面说的三维矩阵的页）,bk,l就是对应三维矩阵中的第k页（二值）。 最后将二值化模型w和二值化NG，结合起来对窗口打分的操作由卷积运算变成了大部分是位运算操作， &emsp;&emsp;一个图像窗口对应的BING特征 $b_{k,l}$ 的过滤器得分,见式(1),可以表示为： $$sl≈ \sum{j=1}^{N_w}\betaj\sum{k=1}^{Ng}C{j,k}$$ &emsp;&emsp;其中， $C_{j,k} = 2^{8-k}(2&lt; \alphaj^+,b{k,l}&gt;-|b_{k,l}|)$可以通过一些快速的按位操作以及SSE指令操作计算得到。 &emsp;&emsp;然后，运用非最大抑制(NMS)，做下滤波。 &emsp;&emsp;总结一下：首先，根据第一级SVM得到模型参数w,对每张训练图像，进行所有尺度变换（不是固定8*8大小），然后计算NG特征，接着根据上文的打分系统，计算每个尺度下的sl（实际上，二值化w和二值化NG特征，就是BING特征）.并重新排序，利用NMS消除掉高分点附近领域内的打分值。这里只选择指定阈值以上的高分点。然后，在原始图像，找到对应打分点对应的方框大小，并保存。这样，针对每张图像，我们计算了不同尺度i下的打分项以及相对应的可能目标匡。然后，针对所有可能的目标匡，我们将其与原始图像中所有有效正样本做重叠率比对，只要有一个正样本框与该可能目标匡重叠与大于0.5，则该可能目标匡作为正样本，否则为负样本。在传入第二级SVM时，作者将可能目标框的打分值，重新根据尺度整合，即不同尺度下下，所有的打分值，作为正负样本。在第二级训练时，针对每个尺度，训练一次。 4.第二级SVM训练&emsp;&emsp;作者针对每种尺度下的打分值，训练SVM，每种尺度下样本总数不超过10W。超过，则随机在正负样本中抽取。确保先读取正样本，后需剩余的位置随即用负样本填满。训练结束后，生成新的权值vi,ti. 测试程序&emsp;&emsp;在读入测试图片后，计算图像的BING特征，跟二级SVM训练预处理一样，对图像进行不同尺度的缩放，计算NG，打分统计得到sl（用的还是第一级模型的w） &emsp;&emsp;然后，为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 100），一些尺度（例如:10 500）的窗口包含对象的可能性是很小的。&emsp;&emsp;针对不同尺度i的窗口，得到不同的独立学习系数。使用校准函数(3)是非常快的，通常只需要在最终的建议窗口重排。这里，打分用的权值是二级模型训练出的，即上文的vi,ti.得到ol重新排序。整个过程，计算时间，给出每个检测图象的平均测试时间。并保存打分结果与对应的目标框。 &emsp;&emsp;打分越高，越接近目标。实际上，算法生成的就是打分窗口，也就是所为的对象状态。下面测试的时候，根据打分窗口与标注的测试窗口重叠率大于0.5就认为检测到了。接着，作者开始绘制结果，根据检测出的候选框与每个测试标注框计算重叠率，大于0.5，就认为检测到了，否则score为0未检到。之后，计算平均重叠率和平均检测率。 这里解释下重叠率： &emsp;&emsp;上面的精度曲线称为DR-#WIN curves，源自TPAMI 2012的一篇论文：Measuring the objectness of image windows。原文还提出了将窗口数量比如[[0,5000]归一化到[0,1]之间，用曲线下的面积作为目标检测的度量结果，并称之为the area under the curve(AUC)，这样AUC的范围就在[0,1]之间了。 &emsp;&emsp;DR的计算是参考The PASCAL Visual Object Classes (VOC) Challenge，目标检测任务中DR的计算的是true/false positive精度，将算法检测目标结果放到groud truth中，将“预测目标区域与groud truth区域的交集”除以“预测目标区域与groud truth区域的并集”作为DR： &emsp;&emsp;DR自少在50%以上才算目标检测正确，其实，50%已经是很低的了，几乎不能做为检测结果。 &emsp;&emsp;自己在程序中加了单张图片测试的显示部分，如果有同学需要可以私信我。 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BingObjectnessCVPR14单张图片检测]]></title>
    <url>%2F2017%2F10%2F01%2Fbing-4%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：VS2013+OpenCV2.4.13 编者: WordZzzz &emsp;&emsp;应邀，本人将自己加入单张图片检测的BING代码上传至GITHUB，源码编译及详解请跳转至我的CSDN博客或者私人博客。 源码编译：http://blog.csdn.net/u011475210/article/details/77822669源码详解：http://blog.csdn.net/u011475210/article/details/77916097 主要工作：&emsp;&emsp;在原有代码的基础上加入单张图片检测框提取代码（Objectness.cpp），大家可以直接在主函数中找到我定义的函数并直接跳转至定义查看即可。 检测框提取：123456789101112131415161718192021222324252627282930313233343536373839/*name：getObjBndBoxesForSingleImagefunction：get boxes from single imageedit by wordzzzz*/void Objectness::getObjBndBoxesForSingleImage(Mat img, ValStructVec&lt;float, Vec4i&gt; &amp;finalBoxes, int numDetPerSize)&#123; ValStructVec&lt;float, Vec4i&gt; boxes; finalBoxes.reserve(10000); int scales[3] = &#123; 1, 3, 5 &#125;; for (int clr = MAXBGR; clr &lt;= G; clr++) &#123; setColorSpace(clr); loadTrainedModel(); CmTimer tm("Predict"); tm.Start(); getObjBndBoxes(img, boxes, numDetPerSize); finalBoxes.append(boxes, scales[clr]); tm.Stop(); printf("Average time for predicting an image (%s) is %gs\n", _clrName[_Clr], tm.TimeInSeconds()); &#125; //Write on file the total number and the list of rectangles returned by objectess, one for each row. CStr fName = _bbResDir + "bb"; FILE *f = fopen(_S(fName + ".txt"), "w"); fprintf(f, "%d\n", boxes.size()); printf("boxes.size() is %d \n", boxes.size()); for (size_t k = 0; k &lt; boxes.size(); k++) fprintf(f, "%g, %s\n", boxes(k), _S(strVec4i(boxes[k]))); fclose(f); for (int j = 0; j &lt; boxes.size(); j++) finalBoxes[j] = boxes[j];&#125; 检测框显示：12345678910111213141516171819202122232425/*name：myilluTestReultsfunction：draw the resultedit by wordzzzz*/void Objectness::myilluTestReults(CStr imgPath, const ValStructVec&lt;float, Vec4i&gt; &amp;boxesTests)&#123; CStr resDir = _voc.localDir + "ResIlu2/"; CmFile::MkDir(resDir); const ValStructVec&lt;float, Vec4i&gt; &amp;boxes = boxesTests; Mat img = imread(imgPath);//如果想将所有检测框画到一张图片上，请取消该行注释 for (int k = 0; k &lt; boxes.size(); k++)&#123; // Mat img = imread(imgPath);//如果想将所有检测框画到一张图片上，请注释掉该行 const Vec4i &amp;bb = boxes[k]; rectangle(img, Point(bb[0], bb[1]), Point(bb[2], bb[3]), Scalar(0), 3); rectangle(img, Point(bb[0], bb[1]), Point(bb[2], bb[3]), Scalar(255, 255, 255), 2); rectangle(img, Point(bb[0], bb[1]), Point(bb[2], bb[3]), Scalar(0, 0, 255), 1); CStr resNameNE = CmFile::GetNameNE(imgPath) + to_string(k); // imwrite(resDir + resNameNE +"_Match.jpg", img);//如果想将所有检测框画到一张图片上，请注释掉该行 &#125; imwrite(resDir + "_Match.jpg", img);//如果想将所有检测框画到一张图片上，请取消该行注释 &#125; 本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVPR2014 Objectness BING 源码编译]]></title>
    <url>%2F2017%2F10%2F01%2Fbing-3%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：http://blog.csdn.net/u011475210 操作系统：WINDOWS 10 软件版本：VS2013+OpenCV2.4.13 编者: WordZzzz 一、资源1.论文作者主页：http://mmcheng.net/zh/bing/2.代码下载地址：http://mmcheng.net/zh/code-data/3.数据集下载地址：http://mmcheng.net/zh/bing/ 二、环境配置&emsp;&emsp;如果你用的是Visual Studio 2012，正好电脑也支持X64平台，那么你只需要配置一下VS2012下的OpenCV（版本要求2.4.8以上），下载的程序就可以直接用了。&emsp;&emsp;我做了一些排雷的动作，尝试了Visual Studio 2013中Release、Debug中的x64和win32版本，即：Release+x64、Debug+x64、Release+win32、Debug+win32.但是因为本渣渣能力有限，最终没能把Visual Studio 2013中的Debug+win32版本跑出来。 1.解压下载的源码：&emsp;&emsp;解压后文件夹内容如图所示： 2.解压VOC2007数据集：&emsp;&emsp;在上图的源码文件中我们也可以看到有个VOC2007文件夹，里面只有ImageSets一个文件夹（里面是训练时会用到的文本文档）。在这一步，我们要把下载好的800多MB的数据集解压到源码的VOC2007文件夹下。（注意在解压过程中当出现是否覆盖的选项时，一律选择跳过,虽然覆盖了也不是很影响效果。） 3.用VS2013打开解决方案，提示升级VC++编译器和库，直接点击确定就好： 4.X64-&gt;WIN32: 添加win32配置管理器，注意一定要从x64继承下来其他东西。 5.配置LibLinear： 右键LibLinear，选为启动项目； 在linear.cpp文件中，修改print_string_stdout函数为：extern “C” static void print_string_stdout(const char *s) 静态库配置： 6.LibLinear代码生成：&emsp;&emsp;最重要的就是这一块的东西了，我直接把四种配置的截图贴在这里，注意，MT对应Release，MTD对应Debug，但是作者的Debug版本用的是DLL(/MDd)，所以本渣渣在Debug版本中也没做更改： Release+x64： Debug+x64： Release+win32： Debug+win32（失败）： &emsp;&emsp;ctrl+F5之后在相应目录下生成LibLinear.lib静态库，记下这个地址。7.配置Objectness：&emsp;&emsp;以Debug+win32的配置为例进行介绍（虽然配置失败，但是这些属性设置是通用的，所以没有更新截图） 右键Objectness，选为启动项目； 打开Debug属性，链接器-&gt;附加库目录，添加LibLinear.lib的目录；（注意:链接库依赖项 要设为是（yes）） 用_popcnt函数实现_popcnt64函数功能：需要自己动手在INT64类型基础上写函数。要加头文件#include在stdafx.h中。 1234inline INT64 __popcnt64(INT64 x)&#123; return __popcnt((unsigned int)(x )) +__popcnt((unsigned int)(x&gt;&gt; 32));&#125; 8.配置opencv：&emsp;&emsp;这里大家可以参考浅墨的博客进行配置，当然本渣渣要是有时间了也会写一篇博客并在此更新链接。浅墨opencv配置链接：http://blog.csdn.net/poem_qianmo/article/details/19809337 &emsp;&emsp;这里我只贴出一些需要填写路径的截图： &emsp;&emsp;需要注意的是上图部分，Debug版本就用d结尾的库，Release版本就用不带d结尾的库，千万不要像浅墨那样两个版本都塞进去，否则会莫名其妙报错。 9.再次配置Objectness的代码生成，和第6步是一样的。 &emsp;&emsp;ctrl+F5之后，运行成功。 10.效果展示： 11.其他：&emsp;&emsp;如果想优化代码，可以打开openmp，并且设置一下优化等级，本渣渣在这里只是为了看处理效果，所以就没做优化的配置。关于优化配置可参考链接（有些情况不一定好使）：http://www.cnblogs.com/larch18/p/4560690.html 系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～ 完的汪(∪｡∪)｡｡｡zzz]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
